"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sanity";
exports.ids = ["vendor-chunks/@sanity"];
exports.modules = {

/***/ "(rsc)/./node_modules/@sanity/eventsource/node.js":
/*!**************************************************!*\
  !*** ./node_modules/@sanity/eventsource/node.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! eventsource */ \"(rsc)/./node_modules/eventsource/lib/eventsource.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ldmVudHNvdXJjZS9ub2RlLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsOEdBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWRhcHRhdGlvbi1pbnNpZ2h0cy8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2V2ZW50c291cmNlL25vZGUuanM/ZDg4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/eventsource/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/client/dist/index.browser.js":
/*!***********************************************************!*\
  !*** ./node_modules/@sanity/client/dist/index.browser.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BasePatch: () => (/* binding */ BasePatch),\n/* harmony export */   BaseTransaction: () => (/* binding */ BaseTransaction),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ObservablePatch: () => (/* binding */ ObservablePatch),\n/* harmony export */   ObservableSanityClient: () => (/* binding */ ObservableSanityClient),\n/* harmony export */   ObservableTransaction: () => (/* binding */ ObservableTransaction),\n/* harmony export */   Patch: () => (/* binding */ Patch),\n/* harmony export */   SanityClient: () => (/* binding */ SanityClient),\n/* harmony export */   ServerError: () => (/* binding */ ServerError),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   \"default\": () => (/* binding */ deprecatedCreateClient),\n/* harmony export */   requester: () => (/* binding */ requester),\n/* harmony export */   unstable__adapter: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.adapter),\n/* harmony export */   unstable__environment: () => (/* reexport safe */ get_it__WEBPACK_IMPORTED_MODULE_0__.environment)\n/* harmony export */ });\n/* harmony import */ var get_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! get-it */ \"(rsc)/./node_modules/get-it/dist/index.react-server.js\");\n/* harmony import */ var get_it_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! get-it/middleware */ \"(rsc)/./node_modules/get-it/dist/middleware.browser.js\");\n/* harmony import */ var _barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! __barrel_optimize__?names=Observable,lastValueFrom!=!rxjs */ \"(rsc)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=Observable,lastValueFrom!=!rxjs */ \"(rsc)/./node_modules/rxjs/dist/esm5/internal/lastValueFrom.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ \"(rsc)/./node_modules/rxjs/dist/cjs/operators/index.js\");\n\n\n\n\n\nvar envMiddleware = [];\nconst MAX_ITEMS_IN_ERROR_MESSAGE = 5;\nclass ClientError extends Error {\n    constructor(res){\n        const props = extractErrorProps(res);\n        super(props.message);\n        this.statusCode = 400;\n        Object.assign(this, props);\n    }\n}\nclass ServerError extends Error {\n    constructor(res){\n        const props = extractErrorProps(res);\n        super(props.message);\n        this.statusCode = 500;\n        Object.assign(this, props);\n    }\n}\nfunction extractErrorProps(res) {\n    const body = res.body;\n    const props = {\n        response: res,\n        statusCode: res.statusCode,\n        responseBody: stringifyBody(body, res),\n        message: \"\",\n        details: void 0\n    };\n    if (body.error && body.message) {\n        props.message = \"\".concat(body.error, \" - \").concat(body.message);\n        return props;\n    }\n    if (isMutationError(body)) {\n        const allItems = body.error.items || [];\n        const items = allItems.slice(0, MAX_ITEMS_IN_ERROR_MESSAGE).map((item)=>{\n            var _a;\n            return (_a = item.error) == null ? void 0 : _a.description;\n        }).filter(Boolean);\n        let itemsStr = items.length ? \":\\n- \".concat(items.join(\"\\n- \")) : \"\";\n        if (allItems.length > MAX_ITEMS_IN_ERROR_MESSAGE) {\n            itemsStr += \"\\n...and \".concat(allItems.length - MAX_ITEMS_IN_ERROR_MESSAGE, \" more\");\n        }\n        props.message = \"\".concat(body.error.description).concat(itemsStr);\n        props.details = body.error;\n        return props;\n    }\n    if (body.error && body.error.description) {\n        props.message = body.error.description;\n        props.details = body.error;\n        return props;\n    }\n    props.message = body.error || body.message || httpErrorMessage(res);\n    return props;\n}\nfunction isMutationError(body) {\n    return isPlainObject(body) && isPlainObject(body.error) && body.error.type === \"mutationError\" && typeof body.error.description === \"string\";\n}\nfunction isPlainObject(obj) {\n    return typeof obj === \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction httpErrorMessage(res) {\n    const statusMessage = res.statusMessage ? \" \".concat(res.statusMessage) : \"\";\n    return \"\".concat(res.method, \"-request to \").concat(res.url, \" resulted in HTTP \").concat(res.statusCode).concat(statusMessage);\n}\nfunction stringifyBody(body, res) {\n    const contentType = (res.headers[\"content-type\"] || \"\").toLowerCase();\n    const isJson = contentType.indexOf(\"application/json\") !== -1;\n    return isJson ? JSON.stringify(body, null, 2) : body;\n}\nconst httpError = {\n    onResponse: (res)=>{\n        if (res.statusCode >= 500) {\n            throw new ServerError(res);\n        } else if (res.statusCode >= 400) {\n            throw new ClientError(res);\n        }\n        return res;\n    }\n};\nconst printWarnings = {\n    onResponse: (res)=>{\n        const warn = res.headers[\"x-sanity-warning\"];\n        const warnings = Array.isArray(warn) ? warn : [\n            warn\n        ];\n        warnings.filter(Boolean).forEach((msg)=>console.warn(msg));\n        return res;\n    }\n};\nfunction defineHttpRequest(envMiddleware, _ref) {\n    let { maxRetries = 5, retryDelay } = _ref;\n    const request = (0,get_it__WEBPACK_IMPORTED_MODULE_0__.getIt)([\n        maxRetries > 0 ? (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry)({\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            retryDelay,\n            // This option is typed incorrectly in get-it.\n            maxRetries,\n            shouldRetry\n        }) : {},\n        ...envMiddleware,\n        printWarnings,\n        (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonRequest)(),\n        (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.jsonResponse)(),\n        (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.progress)(),\n        httpError,\n        (0,get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.observable)({\n            implementation: _barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable\n        })\n    ]);\n    function httpRequest(options) {\n        let requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : request;\n        return requester({\n            maxRedirects: 0,\n            ...options\n        });\n    }\n    httpRequest.defaultRequester = request;\n    return httpRequest;\n}\nfunction shouldRetry(err, attempt, options) {\n    const isSafe = options.method === \"GET\" || options.method === \"HEAD\";\n    const uri = options.uri || options.url;\n    const isQuery = uri.startsWith(\"/data/query\");\n    const isRetriableResponse = err.response && (err.response.statusCode === 429 || err.response.statusCode === 502 || err.response.statusCode === 503);\n    if ((isSafe || isQuery) && isRetriableResponse) return true;\n    return get_it_middleware__WEBPACK_IMPORTED_MODULE_1__.retry.shouldRetry(err, attempt, options);\n}\nconst BASE_URL = \"https://www.sanity.io/help/\";\nfunction generateHelpUrl(slug) {\n    return BASE_URL + slug;\n}\nconst VALID_ASSET_TYPES = [\n    \"image\",\n    \"file\"\n];\nconst VALID_INSERT_LOCATIONS = [\n    \"before\",\n    \"after\",\n    \"replace\"\n];\nconst dataset = (name)=>{\n    if (!/^(~[a-z0-9]{1}[-\\w]{0,63}|[a-z0-9]{1}[-\\w]{0,63})$/.test(name)) {\n        throw new Error(\"Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters\");\n    }\n};\nconst projectId = (id)=>{\n    if (!/^[-a-z0-9]+$/i.test(id)) {\n        throw new Error(\"`projectId` can only contain only a-z, 0-9 and dashes\");\n    }\n};\nconst validateAssetType = (type)=>{\n    if (VALID_ASSET_TYPES.indexOf(type) === -1) {\n        throw new Error(\"Invalid asset type: \".concat(type, \". Must be one of \").concat(VALID_ASSET_TYPES.join(\", \")));\n    }\n};\nconst validateObject = (op, val)=>{\n    if (val === null || typeof val !== \"object\" || Array.isArray(val)) {\n        throw new Error(\"\".concat(op, \"() takes an object of properties\"));\n    }\n};\nconst validateDocumentId = (op, id)=>{\n    if (typeof id !== \"string\" || !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(id) || id.includes(\"..\")) {\n        throw new Error(\"\".concat(op, '(): \"').concat(id, '\" is not a valid document ID'));\n    }\n};\nconst requireDocumentId = (op, doc)=>{\n    if (!doc._id) {\n        throw new Error(\"\".concat(op, '() requires that the document contains an ID (\"_id\" property)'));\n    }\n    validateDocumentId(op, doc._id);\n};\nconst validateInsert = (at, selector, items)=>{\n    const signature = \"insert(at, selector, items)\";\n    if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {\n        const valid = VALID_INSERT_LOCATIONS.map((loc)=>'\"'.concat(loc, '\"')).join(\", \");\n        throw new Error(\"\".concat(signature, ' takes an \"at\"-argument which is one of: ').concat(valid));\n    }\n    if (typeof selector !== \"string\") {\n        throw new Error(\"\".concat(signature, ' takes a \"selector\"-argument which must be a string'));\n    }\n    if (!Array.isArray(items)) {\n        throw new Error(\"\".concat(signature, ' takes an \"items\"-argument which must be an array'));\n    }\n};\nconst hasDataset = (config)=>{\n    if (!config.dataset) {\n        throw new Error(\"`dataset` must be provided to perform queries\");\n    }\n    return config.dataset || \"\";\n};\nconst requestTag = (tag)=>{\n    if (typeof tag !== \"string\" || !/^[a-z0-9._-]{1,75}$/i.test(tag)) {\n        throw new Error(\"Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.\");\n    }\n    return tag;\n};\nfunction once(fn) {\n    let didCall = false;\n    let returnValue;\n    return function() {\n        if (didCall) {\n            return returnValue;\n        }\n        returnValue = fn(...arguments);\n        didCall = true;\n        return returnValue;\n    };\n}\nconst createWarningPrinter = (message)=>// eslint-disable-next-line no-console\n    once(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return console.warn(message.join(\" \"), ...args);\n    });\nconst printCdnWarning = createWarningPrinter([\n    \"Since you haven't set a value for `useCdn`, we will deliver content using our\",\n    \"global, edge-cached API-CDN. If you wish to have content delivered faster, set\",\n    \"`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API.\"\n]);\nconst printCdnPreviewDraftsWarning = createWarningPrinter([\n    \"The Sanity client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.\",\n    \"The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning.\"\n]);\nconst printBrowserTokenWarning = createWarningPrinter([\n    \"You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.\",\n    \"See \".concat(generateHelpUrl(\"js-client-browser-token\"), \" for more information and how to hide this warning.\")\n]);\nconst printNoApiVersionSpecifiedWarning = createWarningPrinter([\n    \"Using the Sanity client without specifying an API version is deprecated.\",\n    \"See \".concat(generateHelpUrl(\"js-client-api-version\"))\n]);\nconst printNoDefaultExport = createWarningPrinter([\n    \"The default export of @sanity/client has been deprecated. Use the named export `createClient` instead.\"\n]);\nconst defaultCdnHost = \"apicdn.sanity.io\";\nconst defaultConfig = {\n    apiHost: \"https://api.sanity.io\",\n    apiVersion: \"1\",\n    useProjectHostname: true\n};\nconst LOCALHOSTS = [\n    \"localhost\",\n    \"127.0.0.1\",\n    \"0.0.0.0\"\n];\nconst isLocal = (host)=>LOCALHOSTS.indexOf(host) !== -1;\nconst validateApiVersion = function validateApiVersion2(apiVersion) {\n    if (apiVersion === \"1\" || apiVersion === \"X\") {\n        return;\n    }\n    const apiDate = new Date(apiVersion);\n    const apiVersionValid = /^\\d{4}-\\d{2}-\\d{2}$/.test(apiVersion) && apiDate instanceof Date && apiDate.getTime() > 0;\n    if (!apiVersionValid) {\n        throw new Error(\"Invalid API version string, expected `1` or date in format `YYYY-MM-DD`\");\n    }\n};\nconst validateApiPerspective = function validateApiPerspective2(perspective) {\n    switch(perspective){\n        case \"previewDrafts\":\n        case \"published\":\n        case \"raw\":\n            return;\n        default:\n            throw new TypeError(\"Invalid API perspective string, expected `published`, `previewDrafts` or `raw`\");\n    }\n};\nconst initConfig = (config, prevConfig)=>{\n    const specifiedConfig = Object.assign({}, prevConfig, config);\n    if (!specifiedConfig.apiVersion) {\n        printNoApiVersionSpecifiedWarning();\n    }\n    const newConfig = Object.assign({}, defaultConfig, specifiedConfig);\n    const projectBased = newConfig.useProjectHostname;\n    if (typeof Promise === \"undefined\") {\n        const helpUrl = generateHelpUrl(\"js-client-promise-polyfill\");\n        throw new Error(\"No native Promise-implementation found, polyfill needed - see \".concat(helpUrl));\n    }\n    if (projectBased && !newConfig.projectId) {\n        throw new Error(\"Configuration must contain `projectId`\");\n    }\n    if (typeof newConfig.perspective === \"string\") {\n        validateApiPerspective(newConfig.perspective);\n    }\n    if (\"encodeSourceMapAtPath\" in newConfig || \"encodeSourceMap\" in newConfig || \"studioUrl\" in newConfig || \"logger\" in newConfig) {\n        throw new Error(\"It looks like you're using options meant for '@sanity/preview-kit/client', such as 'encodeSourceMapAtPath', 'encodeSourceMap', 'studioUrl' and 'logger'. Make sure you're using the right import.\");\n    }\n    const isBrowser =  false && 0;\n    const isLocalhost = isBrowser && isLocal(window.location.hostname);\n    if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {\n        printBrowserTokenWarning();\n    } else if (typeof newConfig.useCdn === \"undefined\") {\n        printCdnWarning();\n    }\n    if (projectBased) {\n        projectId(newConfig.projectId);\n    }\n    if (newConfig.dataset) {\n        dataset(newConfig.dataset);\n    }\n    if (\"requestTagPrefix\" in newConfig) {\n        newConfig.requestTagPrefix = newConfig.requestTagPrefix ? requestTag(newConfig.requestTagPrefix).replace(/\\.+$/, \"\") : void 0;\n    }\n    newConfig.apiVersion = \"\".concat(newConfig.apiVersion).replace(/^v/, \"\");\n    newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost;\n    newConfig.useCdn = newConfig.useCdn !== false && !newConfig.withCredentials;\n    validateApiVersion(newConfig.apiVersion);\n    const hostParts = newConfig.apiHost.split(\"://\", 2);\n    const protocol = hostParts[0];\n    const host = hostParts[1];\n    const cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;\n    if (newConfig.useProjectHostname) {\n        newConfig.url = \"\".concat(protocol, \"://\").concat(newConfig.projectId, \".\").concat(host, \"/v\").concat(newConfig.apiVersion);\n        newConfig.cdnUrl = \"\".concat(protocol, \"://\").concat(newConfig.projectId, \".\").concat(cdnHost, \"/v\").concat(newConfig.apiVersion);\n    } else {\n        newConfig.url = \"\".concat(newConfig.apiHost, \"/v\").concat(newConfig.apiVersion);\n        newConfig.cdnUrl = newConfig.url;\n    }\n    return newConfig;\n};\nconst projectHeader = \"X-Sanity-Project-ID\";\nfunction requestOptions(config) {\n    let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const headers = {};\n    const token = overrides.token || config.token;\n    if (token) {\n        headers.Authorization = \"Bearer \".concat(token);\n    }\n    if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {\n        headers[projectHeader] = config.projectId;\n    }\n    const withCredentials = Boolean(typeof overrides.withCredentials === \"undefined\" ? config.token || config.withCredentials : overrides.withCredentials);\n    const timeout = typeof overrides.timeout === \"undefined\" ? config.timeout : overrides.timeout;\n    return Object.assign({}, overrides, {\n        headers: Object.assign({}, headers, overrides.headers || {}),\n        timeout: typeof timeout === \"undefined\" ? 5 * 60 * 1e3 : timeout,\n        proxy: overrides.proxy || config.proxy,\n        json: true,\n        withCredentials,\n        fetch: typeof overrides.fetch === \"object\" && typeof config.fetch === \"object\" ? {\n            ...config.fetch,\n            ...overrides.fetch\n        } : overrides.fetch || config.fetch\n    });\n}\nfunction getSelection(sel) {\n    if (typeof sel === \"string\" || Array.isArray(sel)) {\n        return {\n            id: sel\n        };\n    }\n    if (typeof sel === \"object\" && sel !== null && \"query\" in sel && typeof sel.query === \"string\") {\n        return \"params\" in sel && typeof sel.params === \"object\" && sel.params !== null ? {\n            query: sel.query,\n            params: sel.params\n        } : {\n            query: sel.query\n        };\n    }\n    const selectionOpts = [\n        \"* Document ID (<docId>)\",\n        \"* Array of document IDs\",\n        \"* Object containing `query`\"\n    ].join(\"\\n\");\n    throw new Error(\"Unknown selection - must be one of:\\n\\n\".concat(selectionOpts));\n}\nconst encodeQueryString = (_ref2)=>{\n    let { query, params = {}, options = {} } = _ref2;\n    const searchParams = new URLSearchParams();\n    const { tag, ...opts } = options;\n    if (tag) searchParams.append(\"tag\", tag);\n    searchParams.append(\"query\", query);\n    for (const [key, value] of Object.entries(params)){\n        searchParams.append(\"$\".concat(key), JSON.stringify(value));\n    }\n    for (const [key, value] of Object.entries(opts)){\n        if (value) searchParams.append(key, \"\".concat(value));\n    }\n    return \"?\".concat(searchParams);\n};\nvar __accessCheck$6 = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$6 = (obj, member, getter)=>{\n    __accessCheck$6(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$6 = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$6 = (obj, member, value, setter)=>{\n    __accessCheck$6(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _client$5, _client2$5;\nclass BasePatch {\n    constructor(selection){\n        let operations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.selection = selection;\n        this.operations = operations;\n    }\n    /**\n   * Sets the given attributes to the document. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */ set(attrs) {\n        return this._assign(\"set\", attrs);\n    }\n    /**\n   * Sets the given attributes to the document if they are not currently set. Does NOT merge objects.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to set. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"value\"\\}\n   */ setIfMissing(attrs) {\n        return this._assign(\"setIfMissing\", attrs);\n    }\n    /**\n   * Performs a \"diff-match-patch\" operation on the string attributes provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attributes to perform operation on. To set a deep attribute, use JSONMatch, eg: \\{\"nested.prop\": \"dmp\"\\}\n   */ diffMatchPatch(attrs) {\n        validateObject(\"diffMatchPatch\", attrs);\n        return this._assign(\"diffMatchPatch\", attrs);\n    }\n    /**\n   * Unsets the attribute paths provided.\n   * The operation is added to the current patch, ready to be commited by `commit()`\n   *\n   * @param attrs - Attribute paths to unset.\n   */ unset(attrs) {\n        if (!Array.isArray(attrs)) {\n            throw new Error(\"unset(attrs) takes an array of attributes to unset, non-array given\");\n        }\n        this.operations = Object.assign({}, this.operations, {\n            unset: attrs\n        });\n        return this;\n    }\n    /**\n   * Increment a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to increment, values representing the number to increment by.\n   */ inc(attrs) {\n        return this._assign(\"inc\", attrs);\n    }\n    /**\n   * Decrement a numeric value. Each entry in the argument is either an attribute or a JSON path. The value may be a positive or negative integer or floating-point value. The operation will fail if target value is not a numeric value, or doesn't exist.\n   *\n   * @param attrs - Object of attribute paths to decrement, values representing the number to decrement by.\n   */ dec(attrs) {\n        return this._assign(\"dec\", attrs);\n    }\n    /**\n   * Provides methods for modifying arrays, by inserting, appending and replacing elements via a JSONPath expression.\n   *\n   * @param at - Location to insert at, relative to the given selector, or 'replace' the matched path\n   * @param selector - JSONPath expression, eg `comments[-1]` or `blocks[_key==\"abc123\"]`\n   * @param items - Array of items to insert/replace\n   */ insert(at, selector, items) {\n        validateInsert(at, selector, items);\n        return this._assign(\"insert\", {\n            [at]: selector,\n            items\n        });\n    }\n    /**\n   * Append the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to append to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to append to the array\n   */ append(selector, items) {\n        return this.insert(\"after\", \"\".concat(selector, \"[-1]\"), items);\n    }\n    /**\n   * Prepend the given items to the array at the given JSONPath\n   *\n   * @param selector - Attribute/path to prepend to, eg `comments` or `person.hobbies`\n   * @param items - Array of items to prepend to the array\n   */ prepend(selector, items) {\n        return this.insert(\"before\", \"\".concat(selector, \"[0]\"), items);\n    }\n    /**\n   * Change the contents of an array by removing existing elements and/or adding new elements.\n   *\n   * @param selector - Attribute or JSONPath expression for array\n   * @param start - Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.x\n   * @param deleteCount - An integer indicating the number of old array elements to remove.\n   * @param items - The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.\n   */ splice(selector, start, deleteCount, items) {\n        const delAll = typeof deleteCount === \"undefined\" || deleteCount === -1;\n        const startIndex = start < 0 ? start - 1 : start;\n        const delCount = delAll ? -1 : Math.max(0, start + deleteCount);\n        const delRange = startIndex < 0 && delCount >= 0 ? \"\" : delCount;\n        const rangeSelector = \"\".concat(selector, \"[\").concat(startIndex, \":\").concat(delRange, \"]\");\n        return this.insert(\"replace\", rangeSelector, items || []);\n    }\n    /**\n   * Adds a revision clause, preventing the document from being patched if the `_rev` property does not match the given value\n   *\n   * @param rev - Revision to lock the patch to\n   */ ifRevisionId(rev) {\n        this.operations.ifRevisionID = rev;\n        return this;\n    }\n    /**\n   * Return a plain JSON representation of the patch\n   */ serialize() {\n        return {\n            ...getSelection(this.selection),\n            ...this.operations\n        };\n    }\n    /**\n   * Return a plain JSON representation of the patch\n   */ toJSON() {\n        return this.serialize();\n    }\n    /**\n   * Clears the patch of all operations\n   */ reset() {\n        this.operations = {};\n        return this;\n    }\n    _assign(op, props) {\n        let merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        validateObject(op, props);\n        this.operations = Object.assign({}, this.operations, {\n            [op]: Object.assign({}, merge && this.operations[op] || {}, props)\n        });\n        return this;\n    }\n    _set(op, props) {\n        return this._assign(op, props, false);\n    }\n}\nconst _ObservablePatch = class _ObservablePatch extends BasePatch {\n    constructor(selection, operations, client){\n        super(selection, operations);\n        __privateAdd$6(this, _client$5, void 0);\n        __privateSet$6(this, _client$5, client);\n    }\n    /**\n   * Clones the patch\n   */ clone() {\n        return new _ObservablePatch(this.selection, {\n            ...this.operations\n        }, __privateGet$6(this, _client$5));\n    }\n    commit(options) {\n        if (!__privateGet$6(this, _client$5)) {\n            throw new Error(\"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\");\n        }\n        const returnFirst = typeof this.selection === \"string\";\n        const opts = Object.assign({\n            returnFirst,\n            returnDocuments: true\n        }, options);\n        return __privateGet$6(this, _client$5).mutate({\n            patch: this.serialize()\n        }, opts);\n    }\n};\n_client$5 = new WeakMap();\nlet ObservablePatch = _ObservablePatch;\nconst _Patch = class _Patch extends BasePatch {\n    constructor(selection, operations, client){\n        super(selection, operations);\n        __privateAdd$6(this, _client2$5, void 0);\n        __privateSet$6(this, _client2$5, client);\n    }\n    /**\n   * Clones the patch\n   */ clone() {\n        return new _Patch(this.selection, {\n            ...this.operations\n        }, __privateGet$6(this, _client2$5));\n    }\n    commit(options) {\n        if (!__privateGet$6(this, _client2$5)) {\n            throw new Error(\"No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method\");\n        }\n        const returnFirst = typeof this.selection === \"string\";\n        const opts = Object.assign({\n            returnFirst,\n            returnDocuments: true\n        }, options);\n        return __privateGet$6(this, _client2$5).mutate({\n            patch: this.serialize()\n        }, opts);\n    }\n};\n_client2$5 = new WeakMap();\nlet Patch = _Patch;\nvar __accessCheck$5 = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$5 = (obj, member, getter)=>{\n    __accessCheck$5(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$5 = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$5 = (obj, member, value, setter)=>{\n    __accessCheck$5(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _client$4, _client2$4;\nconst defaultMutateOptions = {\n    returnDocuments: false\n};\nclass BaseTransaction {\n    constructor(){\n        let operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        let transactionId = arguments.length > 1 ? arguments[1] : undefined;\n        this.operations = operations;\n        this.trxId = transactionId;\n    }\n    /**\n   * Creates a new Sanity document. If `_id` is provided and already exists, the mutation will fail. If no `_id` is given, one will automatically be generated by the database.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create. Requires a `_type` property.\n   */ create(doc) {\n        validateObject(\"create\", doc);\n        return this._add({\n            create: doc\n        });\n    }\n    /**\n   * Creates a new Sanity document. If a document with the same `_id` already exists, the create operation will be ignored.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create if it does not already exist. Requires `_id` and `_type` properties.\n   */ createIfNotExists(doc) {\n        const op = \"createIfNotExists\";\n        validateObject(op, doc);\n        requireDocumentId(op, doc);\n        return this._add({\n            [op]: doc\n        });\n    }\n    /**\n   * Creates a new Sanity document, or replaces an existing one if the same `_id` is already used.\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param doc - Document to create or replace. Requires `_id` and `_type` properties.\n   */ createOrReplace(doc) {\n        const op = \"createOrReplace\";\n        validateObject(op, doc);\n        requireDocumentId(op, doc);\n        return this._add({\n            [op]: doc\n        });\n    }\n    /**\n   * Deletes the document with the given document ID\n   * The operation is added to the current transaction, ready to be commited by `commit()`\n   *\n   * @param documentId - Document ID to delete\n   */ delete(documentId) {\n        validateDocumentId(\"delete\", documentId);\n        return this._add({\n            delete: {\n                id: documentId\n            }\n        });\n    }\n    transactionId(id) {\n        if (!id) {\n            return this.trxId;\n        }\n        this.trxId = id;\n        return this;\n    }\n    /**\n   * Return a plain JSON representation of the transaction\n   */ serialize() {\n        return [\n            ...this.operations\n        ];\n    }\n    /**\n   * Return a plain JSON representation of the transaction\n   */ toJSON() {\n        return this.serialize();\n    }\n    /**\n   * Clears the transaction of all operations\n   */ reset() {\n        this.operations = [];\n        return this;\n    }\n    _add(mut) {\n        this.operations.push(mut);\n        return this;\n    }\n}\nconst _Transaction = class _Transaction extends BaseTransaction {\n    constructor(operations, client, transactionId){\n        super(operations, transactionId);\n        __privateAdd$5(this, _client$4, void 0);\n        __privateSet$5(this, _client$4, client);\n    }\n    /**\n   * Clones the transaction\n   */ clone() {\n        return new _Transaction([\n            ...this.operations\n        ], __privateGet$5(this, _client$4), this.trxId);\n    }\n    commit(options) {\n        if (!__privateGet$5(this, _client$4)) {\n            throw new Error(\"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\");\n        }\n        return __privateGet$5(this, _client$4).mutate(this.serialize(), Object.assign({\n            transactionId: this.trxId\n        }, defaultMutateOptions, options || {}));\n    }\n    patch(patchOrDocumentId, patchOps) {\n        const isBuilder = typeof patchOps === \"function\";\n        const isPatch = typeof patchOrDocumentId !== \"string\" && patchOrDocumentId instanceof Patch;\n        if (isPatch) {\n            return this._add({\n                patch: patchOrDocumentId.serialize()\n            });\n        }\n        if (isBuilder) {\n            const patch = patchOps(new Patch(patchOrDocumentId, {}, __privateGet$5(this, _client$4)));\n            if (!(patch instanceof Patch)) {\n                throw new Error(\"function passed to `patch()` must return the patch\");\n            }\n            return this._add({\n                patch: patch.serialize()\n            });\n        }\n        return this._add({\n            patch: {\n                id: patchOrDocumentId,\n                ...patchOps\n            }\n        });\n    }\n};\n_client$4 = new WeakMap();\nlet Transaction = _Transaction;\nconst _ObservableTransaction = class _ObservableTransaction extends BaseTransaction {\n    constructor(operations, client, transactionId){\n        super(operations, transactionId);\n        __privateAdd$5(this, _client2$4, void 0);\n        __privateSet$5(this, _client2$4, client);\n    }\n    /**\n   * Clones the transaction\n   */ clone() {\n        return new _ObservableTransaction([\n            ...this.operations\n        ], __privateGet$5(this, _client2$4), this.trxId);\n    }\n    commit(options) {\n        if (!__privateGet$5(this, _client2$4)) {\n            throw new Error(\"No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method\");\n        }\n        return __privateGet$5(this, _client2$4).mutate(this.serialize(), Object.assign({\n            transactionId: this.trxId\n        }, defaultMutateOptions, options || {}));\n    }\n    patch(patchOrDocumentId, patchOps) {\n        const isBuilder = typeof patchOps === \"function\";\n        const isPatch = typeof patchOrDocumentId !== \"string\" && patchOrDocumentId instanceof ObservablePatch;\n        if (isPatch) {\n            return this._add({\n                patch: patchOrDocumentId.serialize()\n            });\n        }\n        if (isBuilder) {\n            const patch = patchOps(new ObservablePatch(patchOrDocumentId, {}, __privateGet$5(this, _client2$4)));\n            if (!(patch instanceof ObservablePatch)) {\n                throw new Error(\"function passed to `patch()` must return the patch\");\n            }\n            return this._add({\n                patch: patch.serialize()\n            });\n        }\n        return this._add({\n            patch: {\n                id: patchOrDocumentId,\n                ...patchOps\n            }\n        });\n    }\n};\n_client2$4 = new WeakMap();\nlet ObservableTransaction = _ObservableTransaction;\nconst excludeFalsey = (param, defValue)=>{\n    const value = typeof param === \"undefined\" ? defValue : param;\n    return param === false ? void 0 : value;\n};\nconst getMutationQuery = function() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return {\n        dryRun: options.dryRun,\n        returnIds: true,\n        returnDocuments: excludeFalsey(options.returnDocuments, true),\n        visibility: options.visibility || \"sync\",\n        autoGenerateArrayKeys: options.autoGenerateArrayKeys,\n        skipCrossDatasetReferenceValidation: options.skipCrossDatasetReferenceValidation\n    };\n};\nconst isResponse = (event)=>event.type === \"response\";\nconst getBody = (event)=>event.body;\nconst indexBy = (docs, attr)=>docs.reduce((indexed, doc)=>{\n        indexed[attr(doc)] = doc;\n        return indexed;\n    }, /* @__PURE__ */ Object.create(null));\nconst getQuerySizeLimit = 11264;\nfunction _fetch(client, httpRequest, query, params) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const mapResponse = options.filterResponse === false ? (res)=>res : (res)=>res.result;\n    const { cache, next, ...opts } = {\n        // Opt out of setting a `signal` on an internal `fetch` if one isn't provided.\n        // This is necessary in React Server Components to avoid opting out of Request Memoization.\n        useAbortSignal: typeof options.signal !== \"undefined\",\n        ...options\n    };\n    const reqOpts = typeof cache !== \"undefined\" || typeof next !== \"undefined\" ? {\n        ...opts,\n        fetch: {\n            cache,\n            next\n        }\n    } : opts;\n    return _dataRequest(client, httpRequest, \"query\", {\n        query,\n        params\n    }, reqOpts).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(mapResponse));\n}\nfunction _getDocument(client, httpRequest, id) {\n    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const options = {\n        uri: _getDataUrl(client, \"doc\", id),\n        json: true,\n        tag: opts.tag\n    };\n    return _requestObservable(client, httpRequest, options).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(isResponse), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)((event)=>event.body.documents && event.body.documents[0]));\n}\nfunction _getDocuments(client, httpRequest, ids) {\n    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const options = {\n        uri: _getDataUrl(client, \"doc\", ids.join(\",\")),\n        json: true,\n        tag: opts.tag\n    };\n    return _requestObservable(client, httpRequest, options).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(isResponse), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)((event)=>{\n        const indexed = indexBy(event.body.documents || [], (doc)=>doc._id);\n        return ids.map((id)=>indexed[id] || null);\n    }));\n}\nfunction _createIfNotExists(client, httpRequest, doc, options) {\n    requireDocumentId(\"createIfNotExists\", doc);\n    return _create(client, httpRequest, doc, \"createIfNotExists\", options);\n}\nfunction _createOrReplace(client, httpRequest, doc, options) {\n    requireDocumentId(\"createOrReplace\", doc);\n    return _create(client, httpRequest, doc, \"createOrReplace\", options);\n}\nfunction _delete(client, httpRequest, selection, options) {\n    return _dataRequest(client, httpRequest, \"mutate\", {\n        mutations: [\n            {\n                delete: getSelection(selection)\n            }\n        ]\n    }, options);\n}\nfunction _mutate(client, httpRequest, mutations, options) {\n    let mut;\n    if (mutations instanceof Patch || mutations instanceof ObservablePatch) {\n        mut = {\n            patch: mutations.serialize()\n        };\n    } else if (mutations instanceof Transaction || mutations instanceof ObservableTransaction) {\n        mut = mutations.serialize();\n    } else {\n        mut = mutations;\n    }\n    const muts = Array.isArray(mut) ? mut : [\n        mut\n    ];\n    const transactionId = options && options.transactionId || void 0;\n    return _dataRequest(client, httpRequest, \"mutate\", {\n        mutations: muts,\n        transactionId\n    }, options);\n}\nfunction _dataRequest(client, httpRequest, endpoint, body) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const isMutation = endpoint === \"mutate\";\n    const isQuery = endpoint === \"query\";\n    const strQuery = isMutation ? \"\" : encodeQueryString(body);\n    const useGet = !isMutation && strQuery.length < getQuerySizeLimit;\n    const stringQuery = useGet ? strQuery : \"\";\n    const returnFirst = options.returnFirst;\n    const { timeout, token, tag, headers } = options;\n    const uri = _getDataUrl(client, endpoint, stringQuery);\n    const reqOptions = {\n        method: useGet ? \"GET\" : \"POST\",\n        uri,\n        json: true,\n        body: useGet ? void 0 : body,\n        query: isMutation && getMutationQuery(options),\n        timeout,\n        headers,\n        token,\n        tag,\n        perspective: options.perspective,\n        resultSourceMap: options.resultSourceMap,\n        canUseCdn: isQuery,\n        signal: options.signal,\n        fetch: options.fetch,\n        useAbortSignal: options.useAbortSignal\n    };\n    return _requestObservable(client, httpRequest, reqOptions).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(isResponse), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(getBody), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)((res)=>{\n        if (!isMutation) {\n            return res;\n        }\n        const results = res.results || [];\n        if (options.returnDocuments) {\n            return returnFirst ? results[0] && results[0].document : results.map((mut)=>mut.document);\n        }\n        const key = returnFirst ? \"documentId\" : \"documentIds\";\n        const ids = returnFirst ? results[0] && results[0].id : results.map((mut)=>mut.id);\n        return {\n            transactionId: res.transactionId,\n            results,\n            [key]: ids\n        };\n    }));\n}\nfunction _create(client, httpRequest, doc, op) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const mutation = {\n        [op]: doc\n    };\n    const opts = Object.assign({\n        returnFirst: true,\n        returnDocuments: true\n    }, options);\n    return _dataRequest(client, httpRequest, \"mutate\", {\n        mutations: [\n            mutation\n        ]\n    }, opts);\n}\nfunction _requestObservable(client, httpRequest, options) {\n    var _a;\n    const uri = options.url || options.uri;\n    const config = client.config();\n    const canUseCdn = typeof options.canUseCdn === \"undefined\" ? [\n        \"GET\",\n        \"HEAD\"\n    ].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/\") === 0 : options.canUseCdn;\n    let useCdn = config.useCdn && canUseCdn;\n    const tag = options.tag && config.requestTagPrefix ? [\n        config.requestTagPrefix,\n        options.tag\n    ].join(\".\") : options.tag || config.requestTagPrefix;\n    if (tag && options.tag !== null) {\n        options.query = {\n            tag: requestTag(tag),\n            ...options.query\n        };\n    }\n    if ([\n        \"GET\",\n        \"HEAD\",\n        \"POST\"\n    ].indexOf(options.method || \"GET\") >= 0 && uri.indexOf(\"/data/query/\") === 0) {\n        const resultSourceMap = (_a = options.resultSourceMap) != null ? _a : config.resultSourceMap;\n        if (resultSourceMap !== void 0 && resultSourceMap !== false) {\n            options.query = {\n                resultSourceMap,\n                ...options.query\n            };\n        }\n        const perspective = options.perspective || config.perspective;\n        if (typeof perspective === \"string\" && perspective !== \"raw\") {\n            validateApiPerspective(perspective);\n            options.query = {\n                perspective,\n                ...options.query\n            };\n            if (perspective === \"previewDrafts\" && useCdn) {\n                useCdn = false;\n                printCdnPreviewDraftsWarning();\n            }\n        }\n    }\n    const reqOptions = requestOptions(config, Object.assign({}, options, {\n        url: _getUrl(client, uri, useCdn)\n    }));\n    const request = new _barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((subscriber)=>httpRequest(reqOptions, config.requester).subscribe(subscriber));\n    return options.signal ? request.pipe(_withAbortSignal(options.signal)) : request;\n}\nfunction _request(client, httpRequest, options) {\n    const observable = _requestObservable(client, httpRequest, options).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)((event)=>event.type === \"response\"), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)((event)=>event.body));\n    return observable;\n}\nfunction _getDataUrl(client, operation, path) {\n    const config = client.config();\n    const catalog = hasDataset(config);\n    const baseUri = \"/\".concat(operation, \"/\").concat(catalog);\n    const uri = path ? \"\".concat(baseUri, \"/\").concat(path) : baseUri;\n    return \"/data\".concat(uri).replace(/\\/($|\\?)/, \"$1\");\n}\nfunction _getUrl(client, uri) {\n    let canUseCdn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const { url, cdnUrl } = client.config();\n    const base = canUseCdn ? cdnUrl : url;\n    return \"\".concat(base, \"/\").concat(uri.replace(/^\\//, \"\"));\n}\nfunction _withAbortSignal(signal) {\n    return (input)=>{\n        return new _barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer)=>{\n            const abort = ()=>observer.error(_createAbortError(signal));\n            if (signal && signal.aborted) {\n                abort();\n                return;\n            }\n            const subscription = input.subscribe(observer);\n            signal.addEventListener(\"abort\", abort);\n            return ()=>{\n                signal.removeEventListener(\"abort\", abort);\n                subscription.unsubscribe();\n            };\n        });\n    };\n}\nconst isDomExceptionSupported = Boolean(globalThis.DOMException);\nfunction _createAbortError(signal) {\n    var _a, _b;\n    if (isDomExceptionSupported) {\n        return new DOMException((_a = signal == null ? void 0 : signal.reason) != null ? _a : \"The operation was aborted.\", \"AbortError\");\n    }\n    const error = new Error((_b = signal == null ? void 0 : signal.reason) != null ? _b : \"The operation was aborted.\");\n    error.name = \"AbortError\";\n    return error;\n}\nvar __accessCheck$4 = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$4 = (obj, member, getter)=>{\n    __accessCheck$4(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$4 = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$4 = (obj, member, value, setter)=>{\n    __accessCheck$4(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _client$3, _httpRequest$4, _client2$3, _httpRequest2$4;\nclass ObservableAssetsClient {\n    constructor(client, httpRequest){\n        __privateAdd$4(this, _client$3, void 0);\n        __privateAdd$4(this, _httpRequest$4, void 0);\n        __privateSet$4(this, _client$3, client);\n        __privateSet$4(this, _httpRequest$4, httpRequest);\n    }\n    upload(assetType, body, options) {\n        return _upload(__privateGet$4(this, _client$3), __privateGet$4(this, _httpRequest$4), assetType, body, options);\n    }\n}\n_client$3 = new WeakMap();\n_httpRequest$4 = new WeakMap();\nclass AssetsClient {\n    constructor(client, httpRequest){\n        __privateAdd$4(this, _client2$3, void 0);\n        __privateAdd$4(this, _httpRequest2$4, void 0);\n        __privateSet$4(this, _client2$3, client);\n        __privateSet$4(this, _httpRequest2$4, httpRequest);\n    }\n    upload(assetType, body, options) {\n        const observable = _upload(__privateGet$4(this, _client2$3), __privateGet$4(this, _httpRequest2$4), assetType, body, options);\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(observable.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)((event)=>event.type === \"response\"), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)((event)=>event.body.document)));\n    }\n}\n_client2$3 = new WeakMap();\n_httpRequest2$4 = new WeakMap();\nfunction _upload(client, httpRequest, assetType, body) {\n    let opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    validateAssetType(assetType);\n    let meta = opts.extract || void 0;\n    if (meta && !meta.length) {\n        meta = [\n            \"none\"\n        ];\n    }\n    const dataset = hasDataset(client.config());\n    const assetEndpoint = assetType === \"image\" ? \"images\" : \"files\";\n    const options = optionsFromFile(opts, body);\n    const { tag, label, title, description, creditLine, filename, source } = options;\n    const query = {\n        label,\n        title,\n        description,\n        filename,\n        meta,\n        creditLine\n    };\n    if (source) {\n        query.sourceId = source.id;\n        query.sourceName = source.name;\n        query.sourceUrl = source.url;\n    }\n    return _requestObservable(client, httpRequest, {\n        tag,\n        method: \"POST\",\n        timeout: options.timeout || 0,\n        uri: \"/assets/\".concat(assetEndpoint, \"/\").concat(dataset),\n        headers: options.contentType ? {\n            \"Content-Type\": options.contentType\n        } : {},\n        query,\n        body\n    });\n}\nfunction optionsFromFile(opts, file) {\n    if (typeof File === \"undefined\" || !(file instanceof File)) {\n        return opts;\n    }\n    return Object.assign({\n        filename: opts.preserveFilename === false ? void 0 : file.name,\n        contentType: file.type\n    }, opts);\n}\nvar defaults = (obj, defaults)=>Object.keys(defaults).concat(Object.keys(obj)).reduce((target, prop)=>{\n        target[prop] = typeof obj[prop] === \"undefined\" ? defaults[prop] : obj[prop];\n        return target;\n    }, {});\nconst pick = (obj, props)=>props.reduce((selection, prop)=>{\n        if (typeof obj[prop] === \"undefined\") {\n            return selection;\n        }\n        selection[prop] = obj[prop];\n        return selection;\n    }, {});\nconst MAX_URL_LENGTH = 16e3 - 1200;\nconst possibleOptions = [\n    \"includePreviousRevision\",\n    \"includeResult\",\n    \"visibility\",\n    \"effectFormat\",\n    \"tag\"\n];\nconst defaultOptions = {\n    includeResult: true\n};\nfunction _listen(query, params) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const { url, token, withCredentials, requestTagPrefix } = this.config();\n    const tag = opts.tag && requestTagPrefix ? [\n        requestTagPrefix,\n        opts.tag\n    ].join(\".\") : opts.tag;\n    const options = {\n        ...defaults(opts, defaultOptions),\n        tag\n    };\n    const listenOpts = pick(options, possibleOptions);\n    const qs = encodeQueryString({\n        query,\n        params,\n        options: {\n            tag,\n            ...listenOpts\n        }\n    });\n    const uri = \"\".concat(url).concat(_getDataUrl(this, \"listen\", qs));\n    if (uri.length > MAX_URL_LENGTH) {\n        return new _barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer)=>observer.error(new Error(\"Query too large for listener\")));\n    }\n    const listenFor = options.events ? options.events : [\n        \"mutation\"\n    ];\n    const shouldEmitReconnect = listenFor.indexOf(\"reconnect\") !== -1;\n    const esOptions = {};\n    if (token || withCredentials) {\n        esOptions.withCredentials = true;\n    }\n    if (token) {\n        esOptions.headers = {\n            Authorization: \"Bearer \".concat(token)\n        };\n    }\n    return new _barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable((observer)=>{\n        let es;\n        getEventSource().then((eventSource)=>{\n            es = eventSource;\n        }).catch((reason)=>{\n            observer.error(reason);\n            stop();\n        });\n        let reconnectTimer;\n        let stopped = false;\n        function onError() {\n            if (stopped) {\n                return;\n            }\n            emitReconnect();\n            if (stopped) {\n                return;\n            }\n            if (es.readyState === es.CLOSED) {\n                unsubscribe();\n                clearTimeout(reconnectTimer);\n                reconnectTimer = setTimeout(open, 100);\n            }\n        }\n        function onChannelError(err) {\n            observer.error(cooerceError(err));\n        }\n        function onMessage(evt) {\n            const event = parseEvent(evt);\n            return event instanceof Error ? observer.error(event) : observer.next(event);\n        }\n        function onDisconnect() {\n            stopped = true;\n            unsubscribe();\n            observer.complete();\n        }\n        function unsubscribe() {\n            if (!es) return;\n            es.removeEventListener(\"error\", onError);\n            es.removeEventListener(\"channelError\", onChannelError);\n            es.removeEventListener(\"disconnect\", onDisconnect);\n            listenFor.forEach((type)=>es.removeEventListener(type, onMessage));\n            es.close();\n        }\n        function emitReconnect() {\n            if (shouldEmitReconnect) {\n                observer.next({\n                    type: \"reconnect\"\n                });\n            }\n        }\n        async function getEventSource() {\n            const { default: EventSource } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/@sanity\"), __webpack_require__.e(\"vendor-chunks/eventsource\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @sanity/eventsource */ \"(rsc)/./node_modules/@sanity/eventsource/node.js\", 19));\n            const evs = new EventSource(uri, esOptions);\n            evs.addEventListener(\"error\", onError);\n            evs.addEventListener(\"channelError\", onChannelError);\n            evs.addEventListener(\"disconnect\", onDisconnect);\n            listenFor.forEach((type)=>evs.addEventListener(type, onMessage));\n            return evs;\n        }\n        function open() {\n            getEventSource().then((eventSource)=>{\n                es = eventSource;\n            }).catch((reason)=>{\n                observer.error(reason);\n                stop();\n            });\n        }\n        function stop() {\n            stopped = true;\n            unsubscribe();\n        }\n        return stop;\n    });\n}\nfunction parseEvent(event) {\n    try {\n        const data = event.data && JSON.parse(event.data) || {};\n        return Object.assign({\n            type: event.type\n        }, data);\n    } catch (err) {\n        return err;\n    }\n}\nfunction cooerceError(err) {\n    if (err instanceof Error) {\n        return err;\n    }\n    const evt = parseEvent(err);\n    return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));\n}\nfunction extractErrorMessage(err) {\n    if (!err.error) {\n        return err.message || \"Unknown listener error\";\n    }\n    if (err.error.description) {\n        return err.error.description;\n    }\n    return typeof err.error === \"string\" ? err.error : JSON.stringify(err.error, null, 2);\n}\nvar __accessCheck$3 = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$3 = (obj, member, getter)=>{\n    __accessCheck$3(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$3 = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$3 = (obj, member, value, setter)=>{\n    __accessCheck$3(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _client$2, _httpRequest$3, _client2$2, _httpRequest2$3;\nclass ObservableDatasetsClient {\n    constructor(client, httpRequest){\n        __privateAdd$3(this, _client$2, void 0);\n        __privateAdd$3(this, _httpRequest$3, void 0);\n        __privateSet$3(this, _client$2, client);\n        __privateSet$3(this, _httpRequest$3, httpRequest);\n    }\n    /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */ create(name, options) {\n        return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), \"PUT\", name, options);\n    }\n    /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */ edit(name, options) {\n        return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), \"PATCH\", name, options);\n    }\n    /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */ delete(name) {\n        return _modify(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), \"DELETE\", name);\n    }\n    /**\n   * Fetch a list of datasets for the configured project\n   */ list() {\n        return _request(__privateGet$3(this, _client$2), __privateGet$3(this, _httpRequest$3), {\n            uri: \"/datasets\",\n            tag: null\n        });\n    }\n}\n_client$2 = new WeakMap();\n_httpRequest$3 = new WeakMap();\nclass DatasetsClient {\n    constructor(client, httpRequest){\n        __privateAdd$3(this, _client2$2, void 0);\n        __privateAdd$3(this, _httpRequest2$3, void 0);\n        __privateSet$3(this, _client2$2, client);\n        __privateSet$3(this, _httpRequest2$3, httpRequest);\n    }\n    /**\n   * Create a new dataset with the given name\n   *\n   * @param name - Name of the dataset to create\n   * @param options - Options for the dataset\n   */ create(name, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), \"PUT\", name, options));\n    }\n    /**\n   * Edit a dataset with the given name\n   *\n   * @param name - Name of the dataset to edit\n   * @param options - New options for the dataset\n   */ edit(name, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), \"PATCH\", name, options));\n    }\n    /**\n   * Delete a dataset with the given name\n   *\n   * @param name - Name of the dataset to delete\n   */ delete(name) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_modify(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), \"DELETE\", name));\n    }\n    /**\n   * Fetch a list of datasets for the configured project\n   */ list() {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_request(__privateGet$3(this, _client2$2), __privateGet$3(this, _httpRequest2$3), {\n            uri: \"/datasets\",\n            tag: null\n        }));\n    }\n}\n_client2$2 = new WeakMap();\n_httpRequest2$3 = new WeakMap();\nfunction _modify(client, httpRequest, method, name, options) {\n    dataset(name);\n    return _request(client, httpRequest, {\n        method,\n        uri: \"/datasets/\".concat(name),\n        body: options,\n        tag: null\n    });\n}\nvar __accessCheck$2 = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$2 = (obj, member, getter)=>{\n    __accessCheck$2(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$2 = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$2 = (obj, member, value, setter)=>{\n    __accessCheck$2(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _client$1, _httpRequest$2, _client2$1, _httpRequest2$2;\nclass ObservableProjectsClient {\n    constructor(client, httpRequest){\n        __privateAdd$2(this, _client$1, void 0);\n        __privateAdd$2(this, _httpRequest$2, void 0);\n        __privateSet$2(this, _client$1, client);\n        __privateSet$2(this, _httpRequest$2, httpRequest);\n    }\n    list(options) {\n        const uri = (options == null ? void 0 : options.includeMembers) === false ? \"/projects?includeMembers=false\" : \"/projects\";\n        return _request(__privateGet$2(this, _client$1), __privateGet$2(this, _httpRequest$2), {\n            uri\n        });\n    }\n    /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */ getById(projectId) {\n        return _request(__privateGet$2(this, _client$1), __privateGet$2(this, _httpRequest$2), {\n            uri: \"/projects/\".concat(projectId)\n        });\n    }\n}\n_client$1 = new WeakMap();\n_httpRequest$2 = new WeakMap();\nclass ProjectsClient {\n    constructor(client, httpRequest){\n        __privateAdd$2(this, _client2$1, void 0);\n        __privateAdd$2(this, _httpRequest2$2, void 0);\n        __privateSet$2(this, _client2$1, client);\n        __privateSet$2(this, _httpRequest2$2, httpRequest);\n    }\n    list(options) {\n        const uri = (options == null ? void 0 : options.includeMembers) === false ? \"/projects?includeMembers=false\" : \"/projects\";\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_request(__privateGet$2(this, _client2$1), __privateGet$2(this, _httpRequest2$2), {\n            uri\n        }));\n    }\n    /**\n   * Fetch a project by project ID\n   *\n   * @param projectId - ID of the project to fetch\n   */ getById(projectId) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_request(__privateGet$2(this, _client2$1), __privateGet$2(this, _httpRequest2$2), {\n            uri: \"/projects/\".concat(projectId)\n        }));\n    }\n}\n_client2$1 = new WeakMap();\n_httpRequest2$2 = new WeakMap();\nvar __accessCheck$1 = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet$1 = (obj, member, getter)=>{\n    __accessCheck$1(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd$1 = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet$1 = (obj, member, value, setter)=>{\n    __accessCheck$1(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _client, _httpRequest$1, _client2, _httpRequest2$1;\nclass ObservableUsersClient {\n    constructor(client, httpRequest){\n        __privateAdd$1(this, _client, void 0);\n        __privateAdd$1(this, _httpRequest$1, void 0);\n        __privateSet$1(this, _client, client);\n        __privateSet$1(this, _httpRequest$1, httpRequest);\n    }\n    /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */ getById(id) {\n        return _request(__privateGet$1(this, _client), __privateGet$1(this, _httpRequest$1), {\n            uri: \"/users/\".concat(id)\n        });\n    }\n}\n_client = new WeakMap();\n_httpRequest$1 = new WeakMap();\nclass UsersClient {\n    constructor(client, httpRequest){\n        __privateAdd$1(this, _client2, void 0);\n        __privateAdd$1(this, _httpRequest2$1, void 0);\n        __privateSet$1(this, _client2, client);\n        __privateSet$1(this, _httpRequest2$1, httpRequest);\n    }\n    /**\n   * Fetch a user by user ID\n   *\n   * @param id - User ID of the user to fetch. If `me` is provided, a minimal response including the users role is returned.\n   */ getById(id) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_request(__privateGet$1(this, _client2), __privateGet$1(this, _httpRequest2$1), {\n            uri: \"/users/\".concat(id)\n        }));\n    }\n}\n_client2 = new WeakMap();\n_httpRequest2$1 = new WeakMap();\nvar __accessCheck = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter)=>{\n    __accessCheck(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter)=>{\n    __accessCheck(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _clientConfig, _httpRequest, _clientConfig2, _httpRequest2;\nconst _ObservableSanityClient = class _ObservableSanityClient {\n    constructor(httpRequest){\n        let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConfig;\n        /**\n     * Private properties\n     */ __privateAdd(this, _clientConfig, void 0);\n        __privateAdd(this, _httpRequest, void 0);\n        /**\n     * Instance properties\n     */ this.listen = _listen;\n        this.config(config);\n        __privateSet(this, _httpRequest, httpRequest);\n        this.assets = new ObservableAssetsClient(this, __privateGet(this, _httpRequest));\n        this.datasets = new ObservableDatasetsClient(this, __privateGet(this, _httpRequest));\n        this.projects = new ObservableProjectsClient(this, __privateGet(this, _httpRequest));\n        this.users = new ObservableUsersClient(this, __privateGet(this, _httpRequest));\n    }\n    /**\n   * Clone the client - returns a new instance\n   */ clone() {\n        return new _ObservableSanityClient(__privateGet(this, _httpRequest), this.config());\n    }\n    config(newConfig) {\n        if (newConfig === void 0) {\n            return {\n                ...__privateGet(this, _clientConfig)\n            };\n        }\n        if (__privateGet(this, _clientConfig) && __privateGet(this, _clientConfig).allowReconfigure === false) {\n            throw new Error(\"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\");\n        }\n        __privateSet(this, _clientConfig, initConfig(newConfig, __privateGet(this, _clientConfig) || {}));\n        return this;\n    }\n    /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */ withConfig(newConfig) {\n        return new _ObservableSanityClient(__privateGet(this, _httpRequest), {\n            ...this.config(),\n            ...newConfig\n        });\n    }\n    fetch(query, params) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return _fetch(this, __privateGet(this, _httpRequest), query, params, options);\n    }\n    /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */ getDocument(id, options) {\n        return _getDocument(this, __privateGet(this, _httpRequest), id, options);\n    }\n    /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */ getDocuments(ids, options) {\n        return _getDocuments(this, __privateGet(this, _httpRequest), ids, options);\n    }\n    create(document, options) {\n        return _create(this, __privateGet(this, _httpRequest), document, \"create\", options);\n    }\n    createIfNotExists(document, options) {\n        return _createIfNotExists(this, __privateGet(this, _httpRequest), document, options);\n    }\n    createOrReplace(document, options) {\n        return _createOrReplace(this, __privateGet(this, _httpRequest), document, options);\n    }\n    delete(selection, options) {\n        return _delete(this, __privateGet(this, _httpRequest), selection, options);\n    }\n    mutate(operations, options) {\n        return _mutate(this, __privateGet(this, _httpRequest), operations, options);\n    }\n    /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */ patch(selection, operations) {\n        return new ObservablePatch(selection, operations, this);\n    }\n    /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */ transaction(operations) {\n        return new ObservableTransaction(operations, this);\n    }\n    /**\n   * Perform an HTTP request against the Sanity API\n   *\n   * @param options - Request options\n   */ request(options) {\n        return _request(this, __privateGet(this, _httpRequest), options);\n    }\n    /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */ getUrl(uri, canUseCdn) {\n        return _getUrl(this, uri, canUseCdn);\n    }\n    /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */ getDataUrl(operation, path) {\n        return _getDataUrl(this, operation, path);\n    }\n};\n_clientConfig = new WeakMap();\n_httpRequest = new WeakMap();\nlet ObservableSanityClient = _ObservableSanityClient;\nconst _SanityClient = class _SanityClient {\n    constructor(httpRequest){\n        let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultConfig;\n        /**\n     * Private properties\n     */ __privateAdd(this, _clientConfig2, void 0);\n        __privateAdd(this, _httpRequest2, void 0);\n        /**\n     * Instance properties\n     */ this.listen = _listen;\n        this.config(config);\n        __privateSet(this, _httpRequest2, httpRequest);\n        this.assets = new AssetsClient(this, __privateGet(this, _httpRequest2));\n        this.datasets = new DatasetsClient(this, __privateGet(this, _httpRequest2));\n        this.projects = new ProjectsClient(this, __privateGet(this, _httpRequest2));\n        this.users = new UsersClient(this, __privateGet(this, _httpRequest2));\n        this.observable = new ObservableSanityClient(httpRequest, config);\n    }\n    /**\n   * Clone the client - returns a new instance\n   */ clone() {\n        return new _SanityClient(__privateGet(this, _httpRequest2), this.config());\n    }\n    config(newConfig) {\n        if (newConfig === void 0) {\n            return {\n                ...__privateGet(this, _clientConfig2)\n            };\n        }\n        if (__privateGet(this, _clientConfig2) && __privateGet(this, _clientConfig2).allowReconfigure === false) {\n            throw new Error(\"Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client\");\n        }\n        if (this.observable) {\n            this.observable.config(newConfig);\n        }\n        __privateSet(this, _clientConfig2, initConfig(newConfig, __privateGet(this, _clientConfig2) || {}));\n        return this;\n    }\n    /**\n   * Clone the client with a new (partial) configuration.\n   *\n   * @param newConfig - New client configuration properties, shallowly merged with existing configuration\n   */ withConfig(newConfig) {\n        return new _SanityClient(__privateGet(this, _httpRequest2), {\n            ...this.config(),\n            ...newConfig\n        });\n    }\n    fetch(query, params) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_fetch(this, __privateGet(this, _httpRequest2), query, params, options));\n    }\n    /**\n   * Fetch a single document with the given ID.\n   *\n   * @param id - Document ID to fetch\n   * @param options - Request options\n   */ getDocument(id, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_getDocument(this, __privateGet(this, _httpRequest2), id, options));\n    }\n    /**\n   * Fetch multiple documents in one request.\n   * Should be used sparingly - performing a query is usually a better option.\n   * The order/position of documents is preserved based on the original array of IDs.\n   * If any of the documents are missing, they will be replaced by a `null` entry in the returned array\n   *\n   * @param ids - Document IDs to fetch\n   * @param options - Request options\n   */ getDocuments(ids, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_getDocuments(this, __privateGet(this, _httpRequest2), ids, options));\n    }\n    create(document, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_create(this, __privateGet(this, _httpRequest2), document, \"create\", options));\n    }\n    createIfNotExists(document, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_createIfNotExists(this, __privateGet(this, _httpRequest2), document, options));\n    }\n    createOrReplace(document, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_createOrReplace(this, __privateGet(this, _httpRequest2), document, options));\n    }\n    delete(selection, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_delete(this, __privateGet(this, _httpRequest2), selection, options));\n    }\n    mutate(operations, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_mutate(this, __privateGet(this, _httpRequest2), operations, options));\n    }\n    /**\n   * Create a new buildable patch of operations to perform\n   *\n   * @param selection - Document ID, an array of document IDs, or an object with `query` and optional `params`, defining which document(s) to patch\n   * @param operations - Optional object of patch operations to initialize the patch instance with\n   * @returns Patch instance - call `.commit()` to perform the operations defined\n   */ patch(documentId, operations) {\n        return new Patch(documentId, operations, this);\n    }\n    /**\n   * Create a new transaction of mutations\n   *\n   * @param operations - Optional array of mutation operations to initialize the transaction instance with\n   */ transaction(operations) {\n        return new Transaction(operations, this);\n    }\n    /**\n   * Perform a request against the Sanity API\n   * NOTE: Only use this for Sanity API endpoints, not for your own APIs!\n   *\n   * @param options - Request options\n   * @returns Promise resolving to the response body\n   */ request(options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_request(this, __privateGet(this, _httpRequest2), options));\n    }\n    /**\n   * Perform an HTTP request a `/data` sub-endpoint\n   * NOTE: Considered internal, thus marked as deprecated. Use `request` instead.\n   *\n   * @deprecated - Use `request()` or your own HTTP library instead\n   * @param endpoint - Endpoint to hit (mutate, query etc)\n   * @param body - Request body\n   * @param options - Request options\n   * @internal\n   */ dataRequest(endpoint, body, options) {\n        return (0,_barrel_optimize_names_Observable_lastValueFrom_rxjs__WEBPACK_IMPORTED_MODULE_4__.lastValueFrom)(_dataRequest(this, __privateGet(this, _httpRequest2), endpoint, body, options));\n    }\n    /**\n   * Get a Sanity API URL for the URI provided\n   *\n   * @param uri - URI/path to build URL for\n   * @param canUseCdn - Whether or not to allow using the API CDN for this route\n   */ getUrl(uri, canUseCdn) {\n        return _getUrl(this, uri, canUseCdn);\n    }\n    /**\n   * Get a Sanity API URL for the data operation and path provided\n   *\n   * @param operation - Data operation (eg `query`, `mutate`, `listen` or similar)\n   * @param path - Path to append after the operation\n   */ getDataUrl(operation, path) {\n        return _getDataUrl(this, operation, path);\n    }\n};\n_clientConfig2 = new WeakMap();\n_httpRequest2 = new WeakMap();\nlet SanityClient = _SanityClient;\nconst httpRequest = defineHttpRequest(envMiddleware, {});\nconst requester = httpRequest.defaultRequester;\nconst createClient = (config)=>new SanityClient(defineHttpRequest(envMiddleware, {\n        maxRetries: config.maxRetries,\n        retryDelay: config.retryDelay\n    }), config);\nfunction deprecatedCreateClient(config) {\n    printNoDefaultExport();\n    return new SanityClient(httpRequest, config);\n}\n //# sourceMappingURL=index.browser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9pbmRleC5icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQzZEO0FBQ0Q7QUFDMUM7QUFDSjtBQUM3QyxJQUFJYyxnQkFBZ0IsRUFBRTtBQUN0QixNQUFNQyw2QkFBNkI7QUFDbkMsTUFBTUMsb0JBQW9CQztJQUN4QkMsWUFBWUMsR0FBRyxDQUFFO1FBQ2YsTUFBTUMsUUFBUUMsa0JBQWtCRjtRQUNoQyxLQUFLLENBQUNDLE1BQU1FLE9BQU87UUFDbkIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEJDLE9BQU9DLE1BQU0sQ0FBQyxJQUFJLEVBQUVMO0lBQ3RCO0FBQ0Y7QUFDQSxNQUFNTSxvQkFBb0JUO0lBQ3hCQyxZQUFZQyxHQUFHLENBQUU7UUFDZixNQUFNQyxRQUFRQyxrQkFBa0JGO1FBQ2hDLEtBQUssQ0FBQ0MsTUFBTUUsT0FBTztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQkMsT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRUw7SUFDdEI7QUFDRjtBQUNBLFNBQVNDLGtCQUFrQkYsR0FBRztJQUM1QixNQUFNUSxPQUFPUixJQUFJUSxJQUFJO0lBQ3JCLE1BQU1QLFFBQVE7UUFDWlEsVUFBVVQ7UUFDVkksWUFBWUosSUFBSUksVUFBVTtRQUMxQk0sY0FBY0MsY0FBY0gsTUFBTVI7UUFDbENHLFNBQVM7UUFDVFMsU0FBUyxLQUFLO0lBQ2hCO0lBQ0EsSUFBSUosS0FBS0ssS0FBSyxJQUFJTCxLQUFLTCxPQUFPLEVBQUU7UUFDOUJGLE1BQU1FLE9BQU8sR0FBRyxHQUFHVyxNQUFNLENBQUNOLEtBQUtLLEtBQUssRUFBRSxPQUFPQyxNQUFNLENBQUNOLEtBQUtMLE9BQU87UUFDaEUsT0FBT0Y7SUFDVDtJQUNBLElBQUljLGdCQUFnQlAsT0FBTztRQUN6QixNQUFNUSxXQUFXUixLQUFLSyxLQUFLLENBQUNJLEtBQUssSUFBSSxF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T0FBT2xFLG1HQUFhQSxDQUFDd1MsYUFBYSxJQUFJLEVBQUUrSixhQUFhLElBQUksRUFBRU0sZ0JBQWdCdEosVUFBVXZTLE1BQU1rRDtJQUM3RjtJQUNBOzs7OztHQUtDLEdBQ0R1WixPQUFPOVksR0FBRyxFQUFFbVAsU0FBUyxFQUFFO1FBQ3JCLE9BQU9JLFFBQVEsSUFBSSxFQUFFdlAsS0FBS21QO0lBQzVCO0lBQ0E7Ozs7O0dBS0MsR0FDRDRKLFdBQVduSixTQUFTLEVBQUVDLElBQUksRUFBRTtRQUMxQixPQUFPN0IsWUFBWSxJQUFJLEVBQUU0QixXQUFXQztJQUN0QztBQUNGO0FBQ0FvSSxpQkFBaUIsSUFBSTdOO0FBQ3JCOE4sZ0JBQWdCLElBQUk5TjtBQUNwQixJQUFJK08sZUFBZUY7QUFDbkIsTUFBTTNaLGNBQWNQLGtCQUFrQnZELGVBQWUsQ0FBQztBQUN0RCxNQUFNZ0UsWUFBWUYsWUFBWU0sZ0JBQWdCO0FBQzlDLE1BQU13WixlQUFldFgsQ0FBQUEsU0FBVSxJQUFJcVgsYUFBYXBhLGtCQUFrQnZELGVBQWU7UUFDL0V5RCxZQUFZNkMsT0FBTzdDLFVBQVU7UUFDN0JDLFlBQVk0QyxPQUFPNUMsVUFBVTtJQUMvQixJQUFJNEM7QUFDSixTQUFTdVgsdUJBQXVCdlgsTUFBTTtJQUNwQ2U7SUFDQSxPQUFPLElBQUlzVyxhQUFhN1osYUFBYXdDO0FBQ3ZDO0FBQzhOLENBQzlOLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2FkYXB0YXRpb24taW5zaWdodHMvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9jbGllbnQvZGlzdC9pbmRleC5icm93c2VyLmpzPzk5OGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0SXQgfSBmcm9tICdnZXQtaXQnO1xuZXhwb3J0IHsgYWRhcHRlciBhcyB1bnN0YWJsZV9fYWRhcHRlciwgZW52aXJvbm1lbnQgYXMgdW5zdGFibGVfX2Vudmlyb25tZW50IH0gZnJvbSAnZ2V0LWl0JztcbmltcG9ydCB7IHJldHJ5LCBqc29uUmVxdWVzdCwganNvblJlc3BvbnNlLCBwcm9ncmVzcywgb2JzZXJ2YWJsZSB9IGZyb20gJ2dldC1pdC9taWRkbGV3YXJlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGxhc3RWYWx1ZUZyb20gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xudmFyIGVudk1pZGRsZXdhcmUgPSBbXTtcbmNvbnN0IE1BWF9JVEVNU19JTl9FUlJPUl9NRVNTQUdFID0gNTtcbmNsYXNzIENsaWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXMpIHtcbiAgICBjb25zdCBwcm9wcyA9IGV4dHJhY3RFcnJvclByb3BzKHJlcyk7XG4gICAgc3VwZXIocHJvcHMubWVzc2FnZSk7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gNDAwO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcHMpO1xuICB9XG59XG5jbGFzcyBTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocmVzKSB7XG4gICAgY29uc3QgcHJvcHMgPSBleHRyYWN0RXJyb3JQcm9wcyhyZXMpO1xuICAgIHN1cGVyKHByb3BzLm1lc3NhZ2UpO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXh0cmFjdEVycm9yUHJvcHMocmVzKSB7XG4gIGNvbnN0IGJvZHkgPSByZXMuYm9keTtcbiAgY29uc3QgcHJvcHMgPSB7XG4gICAgcmVzcG9uc2U6IHJlcyxcbiAgICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzQ29kZSxcbiAgICByZXNwb25zZUJvZHk6IHN0cmluZ2lmeUJvZHkoYm9keSwgcmVzKSxcbiAgICBtZXNzYWdlOiBcIlwiLFxuICAgIGRldGFpbHM6IHZvaWQgMFxuICB9O1xuICBpZiAoYm9keS5lcnJvciAmJiBib2R5Lm1lc3NhZ2UpIHtcbiAgICBwcm9wcy5tZXNzYWdlID0gXCJcIi5jb25jYXQoYm9keS5lcnJvciwgXCIgLSBcIikuY29uY2F0KGJvZHkubWVzc2FnZSk7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG4gIGlmIChpc011dGF0aW9uRXJyb3IoYm9keSkpIHtcbiAgICBjb25zdCBhbGxJdGVtcyA9IGJvZHkuZXJyb3IuaXRlbXMgfHwgW107XG4gICAgY29uc3QgaXRlbXMgPSBhbGxJdGVtcy5zbGljZSgwLCBNQVhfSVRFTVNfSU5fRVJST1JfTUVTU0FHRSkubWFwKGl0ZW0gPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGl0ZW0uZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZXNjcmlwdGlvbjtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgbGV0IGl0ZW1zU3RyID0gaXRlbXMubGVuZ3RoID8gXCI6XFxuLSBcIi5jb25jYXQoaXRlbXMuam9pbihcIlxcbi0gXCIpKSA6IFwiXCI7XG4gICAgaWYgKGFsbEl0ZW1zLmxlbmd0aCA+IE1BWF9JVEVNU19JTl9FUlJPUl9NRVNTQUdFKSB7XG4gICAgICBpdGVtc1N0ciArPSBcIlxcbi4uLmFuZCBcIi5jb25jYXQoYWxsSXRlbXMubGVuZ3RoIC0gTUFYX0lURU1TX0lOX0VSUk9SX01FU1NBR0UsIFwiIG1vcmVcIik7XG4gICAgfVxuICAgIHByb3BzLm1lc3NhZ2UgPSBcIlwiLmNvbmNhdChib2R5LmVycm9yLmRlc2NyaXB0aW9uKS5jb25jYXQoaXRlbXNTdHIpO1xuICAgIHByb3BzLmRldGFpbHMgPSBib2R5LmVycm9yO1xuICAgIHJldHVybiBwcm9wcztcbiAgfVxuICBpZiAoYm9keS5lcnJvciAmJiBib2R5LmVycm9yLmRlc2NyaXB0aW9uKSB7XG4gICAgcHJvcHMubWVzc2FnZSA9IGJvZHkuZXJyb3IuZGVzY3JpcHRpb247XG4gICAgcHJvcHMuZGV0YWlscyA9IGJvZHkuZXJyb3I7XG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG4gIHByb3BzLm1lc3NhZ2UgPSBib2R5LmVycm9yIHx8IGJvZHkubWVzc2FnZSB8fCBodHRwRXJyb3JNZXNzYWdlKHJlcyk7XG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGlzTXV0YXRpb25FcnJvcihib2R5KSB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGJvZHkpICYmIGlzUGxhaW5PYmplY3QoYm9keS5lcnJvcikgJiYgYm9keS5lcnJvci50eXBlID09PSBcIm11dGF0aW9uRXJyb3JcIiAmJiB0eXBlb2YgYm9keS5lcnJvci5kZXNjcmlwdGlvbiA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShvYmopO1xufVxuZnVuY3Rpb24gaHR0cEVycm9yTWVzc2FnZShyZXMpIHtcbiAgY29uc3Qgc3RhdHVzTWVzc2FnZSA9IHJlcy5zdGF0dXNNZXNzYWdlID8gXCIgXCIuY29uY2F0KHJlcy5zdGF0dXNNZXNzYWdlKSA6IFwiXCI7XG4gIHJldHVybiBcIlwiLmNvbmNhdChyZXMubWV0aG9kLCBcIi1yZXF1ZXN0IHRvIFwiKS5jb25jYXQocmVzLnVybCwgXCIgcmVzdWx0ZWQgaW4gSFRUUCBcIikuY29uY2F0KHJlcy5zdGF0dXNDb2RlKS5jb25jYXQoc3RhdHVzTWVzc2FnZSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlCb2R5KGJvZHksIHJlcykge1xuICBjb25zdCBjb250ZW50VHlwZSA9IChyZXMuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBpc0pzb24gPSBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTE7XG4gIHJldHVybiBpc0pzb24gPyBKU09OLnN0cmluZ2lmeShib2R5LCBudWxsLCAyKSA6IGJvZHk7XG59XG5jb25zdCBodHRwRXJyb3IgPSB7XG4gIG9uUmVzcG9uc2U6IHJlcyA9PiB7XG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDUwMCkge1xuICAgICAgdGhyb3cgbmV3IFNlcnZlckVycm9yKHJlcyk7XG4gICAgfSBlbHNlIGlmIChyZXMuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgIHRocm93IG5ldyBDbGllbnRFcnJvcihyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuY29uc3QgcHJpbnRXYXJuaW5ncyA9IHtcbiAgb25SZXNwb25zZTogcmVzID0+IHtcbiAgICBjb25zdCB3YXJuID0gcmVzLmhlYWRlcnNbXCJ4LXNhbml0eS13YXJuaW5nXCJdO1xuICAgIGNvbnN0IHdhcm5pbmdzID0gQXJyYXkuaXNBcnJheSh3YXJuKSA/IHdhcm4gOiBbd2Fybl07XG4gICAgd2FybmluZ3MuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2gobXNnID0+IGNvbnNvbGUud2Fybihtc2cpKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59O1xuZnVuY3Rpb24gZGVmaW5lSHR0cFJlcXVlc3QoZW52TWlkZGxld2FyZSwgX3JlZikge1xuICBsZXQge1xuICAgIG1heFJldHJpZXMgPSA1LFxuICAgIHJldHJ5RGVsYXlcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHJlcXVlc3QgPSBnZXRJdChbbWF4UmV0cmllcyA+IDAgPyByZXRyeSh7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXRyeURlbGF5LFxuICAgIC8vIFRoaXMgb3B0aW9uIGlzIHR5cGVkIGluY29ycmVjdGx5IGluIGdldC1pdC5cbiAgICBtYXhSZXRyaWVzLFxuICAgIHNob3VsZFJldHJ5XG4gIH0pIDoge30sIC4uLmVudk1pZGRsZXdhcmUsIHByaW50V2FybmluZ3MsIGpzb25SZXF1ZXN0KCksIGpzb25SZXNwb25zZSgpLCBwcm9ncmVzcygpLCBodHRwRXJyb3IsIG9ic2VydmFibGUoe1xuICAgIGltcGxlbWVudGF0aW9uOiBPYnNlcnZhYmxlXG4gIH0pXSk7XG4gIGZ1bmN0aW9uIGh0dHBSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBsZXQgcmVxdWVzdGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiByZXF1ZXN0O1xuICAgIHJldHVybiByZXF1ZXN0ZXIoe1xuICAgICAgbWF4UmVkaXJlY3RzOiAwLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIGh0dHBSZXF1ZXN0LmRlZmF1bHRSZXF1ZXN0ZXIgPSByZXF1ZXN0O1xuICByZXR1cm4gaHR0cFJlcXVlc3Q7XG59XG5mdW5jdGlvbiBzaG91bGRSZXRyeShlcnIsIGF0dGVtcHQsIG9wdGlvbnMpIHtcbiAgY29uc3QgaXNTYWZlID0gb3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIgfHwgb3B0aW9ucy5tZXRob2QgPT09IFwiSEVBRFwiO1xuICBjb25zdCB1cmkgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybDtcbiAgY29uc3QgaXNRdWVyeSA9IHVyaS5zdGFydHNXaXRoKFwiL2RhdGEvcXVlcnlcIik7XG4gIGNvbnN0IGlzUmV0cmlhYmxlUmVzcG9uc2UgPSBlcnIucmVzcG9uc2UgJiYgKGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkgfHwgZXJyLnJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDUwMiB8fCBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNTAzKTtcbiAgaWYgKChpc1NhZmUgfHwgaXNRdWVyeSkgJiYgaXNSZXRyaWFibGVSZXNwb25zZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiByZXRyeS5zaG91bGRSZXRyeShlcnIsIGF0dGVtcHQsIG9wdGlvbnMpO1xufVxuY29uc3QgQkFTRV9VUkwgPSBcImh0dHBzOi8vd3d3LnNhbml0eS5pby9oZWxwL1wiO1xuZnVuY3Rpb24gZ2VuZXJhdGVIZWxwVXJsKHNsdWcpIHtcbiAgcmV0dXJuIEJBU0VfVVJMICsgc2x1Zztcbn1cbmNvbnN0IFZBTElEX0FTU0VUX1RZUEVTID0gW1wiaW1hZ2VcIiwgXCJmaWxlXCJdO1xuY29uc3QgVkFMSURfSU5TRVJUX0xPQ0FUSU9OUyA9IFtcImJlZm9yZVwiLCBcImFmdGVyXCIsIFwicmVwbGFjZVwiXTtcbmNvbnN0IGRhdGFzZXQgPSBuYW1lID0+IHtcbiAgaWYgKCEvXih+W2EtejAtOV17MX1bLVxcd117MCw2M318W2EtejAtOV17MX1bLVxcd117MCw2M30pJC8udGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFzZXRzIGNhbiBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGNoYXJhY3RlcnMsIG51bWJlcnMsIHVuZGVyc2NvcmVzIGFuZCBkYXNoZXMsIGFuZCBzdGFydCB3aXRoIHRpbGRlLCBhbmQgYmUgbWF4aW11bSA2NCBjaGFyYWN0ZXJzXCIpO1xuICB9XG59O1xuY29uc3QgcHJvamVjdElkID0gaWQgPT4ge1xuICBpZiAoIS9eWy1hLXowLTldKyQvaS50ZXN0KGlkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBwcm9qZWN0SWRgIGNhbiBvbmx5IGNvbnRhaW4gb25seSBhLXosIDAtOSBhbmQgZGFzaGVzXCIpO1xuICB9XG59O1xuY29uc3QgdmFsaWRhdGVBc3NldFR5cGUgPSB0eXBlID0+IHtcbiAgaWYgKFZBTElEX0FTU0VUX1RZUEVTLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhc3NldCB0eXBlOiBcIi5jb25jYXQodHlwZSwgXCIuIE11c3QgYmUgb25lIG9mIFwiKS5jb25jYXQoVkFMSURfQVNTRVRfVFlQRVMuam9pbihcIiwgXCIpKSk7XG4gIH1cbn07XG5jb25zdCB2YWxpZGF0ZU9iamVjdCA9IChvcCwgdmFsKSA9PiB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQob3AsIFwiKCkgdGFrZXMgYW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcIikpO1xuICB9XG59O1xuY29uc3QgdmFsaWRhdGVEb2N1bWVudElkID0gKG9wLCBpZCkgPT4ge1xuICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiIHx8ICEvXlthLXowLTlfXVthLXowLTlfLi1dezAsMTI3fSQvaS50ZXN0KGlkKSB8fCBpZC5pbmNsdWRlcyhcIi4uXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KG9wLCAnKCk6IFwiJykuY29uY2F0KGlkLCAnXCIgaXMgbm90IGEgdmFsaWQgZG9jdW1lbnQgSUQnKSk7XG4gIH1cbn07XG5jb25zdCByZXF1aXJlRG9jdW1lbnRJZCA9IChvcCwgZG9jKSA9PiB7XG4gIGlmICghZG9jLl9pZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChvcCwgJygpIHJlcXVpcmVzIHRoYXQgdGhlIGRvY3VtZW50IGNvbnRhaW5zIGFuIElEIChcIl9pZFwiIHByb3BlcnR5KScpKTtcbiAgfVxuICB2YWxpZGF0ZURvY3VtZW50SWQob3AsIGRvYy5faWQpO1xufTtcbmNvbnN0IHZhbGlkYXRlSW5zZXJ0ID0gKGF0LCBzZWxlY3RvciwgaXRlbXMpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gXCJpbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcylcIjtcbiAgaWYgKFZBTElEX0lOU0VSVF9MT0NBVElPTlMuaW5kZXhPZihhdCkgPT09IC0xKSB7XG4gICAgY29uc3QgdmFsaWQgPSBWQUxJRF9JTlNFUlRfTE9DQVRJT05TLm1hcChsb2MgPT4gJ1wiJy5jb25jYXQobG9jLCAnXCInKSkuam9pbihcIiwgXCIpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChzaWduYXR1cmUsICcgdGFrZXMgYW4gXCJhdFwiLWFyZ3VtZW50IHdoaWNoIGlzIG9uZSBvZjogJykuY29uY2F0KHZhbGlkKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChzaWduYXR1cmUsICcgdGFrZXMgYSBcInNlbGVjdG9yXCItYXJndW1lbnQgd2hpY2ggbXVzdCBiZSBhIHN0cmluZycpKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KHNpZ25hdHVyZSwgJyB0YWtlcyBhbiBcIml0ZW1zXCItYXJndW1lbnQgd2hpY2ggbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxufTtcbmNvbnN0IGhhc0RhdGFzZXQgPSBjb25maWcgPT4ge1xuICBpZiAoIWNvbmZpZy5kYXRhc2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYGRhdGFzZXRgIG11c3QgYmUgcHJvdmlkZWQgdG8gcGVyZm9ybSBxdWVyaWVzXCIpO1xuICB9XG4gIHJldHVybiBjb25maWcuZGF0YXNldCB8fCBcIlwiO1xufTtcbmNvbnN0IHJlcXVlc3RUYWcgPSB0YWcgPT4ge1xuICBpZiAodHlwZW9mIHRhZyAhPT0gXCJzdHJpbmdcIiB8fCAhL15bYS16MC05Ll8tXXsxLDc1fSQvaS50ZXN0KHRhZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUYWcgY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycywgdW5kZXJzY29yZXMsIGRhc2hlcyBhbmQgZG90cywgYW5kIGJlIGJldHdlZW4gb25lIGFuZCA3NSBjaGFyYWN0ZXJzIGxvbmcuXCIpO1xuICB9XG4gIHJldHVybiB0YWc7XG59O1xuZnVuY3Rpb24gb25jZShmbikge1xuICBsZXQgZGlkQ2FsbCA9IGZhbHNlO1xuICBsZXQgcmV0dXJuVmFsdWU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGRpZENhbGwpIHtcbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuVmFsdWUgPSBmbiguLi5hcmd1bWVudHMpO1xuICAgIGRpZENhbGwgPSB0cnVlO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfTtcbn1cbmNvbnN0IGNyZWF0ZVdhcm5pbmdQcmludGVyID0gbWVzc2FnZSA9PlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbm9uY2UoZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBjb25zb2xlLndhcm4obWVzc2FnZS5qb2luKFwiIFwiKSwgLi4uYXJncyk7XG59KTtcbmNvbnN0IHByaW50Q2RuV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcIlNpbmNlIHlvdSBoYXZlbid0IHNldCBhIHZhbHVlIGZvciBgdXNlQ2RuYCwgd2Ugd2lsbCBkZWxpdmVyIGNvbnRlbnQgdXNpbmcgb3VyXCIsIFwiZ2xvYmFsLCBlZGdlLWNhY2hlZCBBUEktQ0ROLiBJZiB5b3Ugd2lzaCB0byBoYXZlIGNvbnRlbnQgZGVsaXZlcmVkIGZhc3Rlciwgc2V0XCIsIFwiYHVzZUNkbjogZmFsc2VgIHRvIHVzZSB0aGUgTGl2ZSBBUEkuIE5vdGU6IFlvdSBtYXkgaW5jdXIgaGlnaGVyIGNvc3RzIHVzaW5nIHRoZSBsaXZlIEFQSS5cIl0pO1xuY29uc3QgcHJpbnRDZG5QcmV2aWV3RHJhZnRzV2FybmluZyA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcIlRoZSBTYW5pdHkgY2xpZW50IGlzIGNvbmZpZ3VyZWQgd2l0aCB0aGUgYHBlcnNwZWN0aXZlYCBzZXQgdG8gYHByZXZpZXdEcmFmdHNgLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgdGhlIEFQSS1DRE4uXCIsIFwiVGhlIExpdmUgQVBJIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBTZXQgYHVzZUNkbjogZmFsc2VgIGluIHlvdXIgY29uZmlndXJhdGlvbiB0byBoaWRlIHRoaXMgd2FybmluZy5cIl0pO1xuY29uc3QgcHJpbnRCcm93c2VyVG9rZW5XYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1wiWW91IGhhdmUgY29uZmlndXJlZCBTYW5pdHkgY2xpZW50IHRvIHVzZSBhIHRva2VuIGluIHRoZSBicm93c2VyLiBUaGlzIG1heSBjYXVzZSB1bmludGVudGlvbmFsIHNlY3VyaXR5IGlzc3Vlcy5cIiwgXCJTZWUgXCIuY29uY2F0KGdlbmVyYXRlSGVscFVybChcImpzLWNsaWVudC1icm93c2VyLXRva2VuXCIpLCBcIiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgaG93IHRvIGhpZGUgdGhpcyB3YXJuaW5nLlwiKV0pO1xuY29uc3QgcHJpbnROb0FwaVZlcnNpb25TcGVjaWZpZWRXYXJuaW5nID0gY3JlYXRlV2FybmluZ1ByaW50ZXIoW1wiVXNpbmcgdGhlIFNhbml0eSBjbGllbnQgd2l0aG91dCBzcGVjaWZ5aW5nIGFuIEFQSSB2ZXJzaW9uIGlzIGRlcHJlY2F0ZWQuXCIsIFwiU2VlIFwiLmNvbmNhdChnZW5lcmF0ZUhlbHBVcmwoXCJqcy1jbGllbnQtYXBpLXZlcnNpb25cIikpXSk7XG5jb25zdCBwcmludE5vRGVmYXVsdEV4cG9ydCA9IGNyZWF0ZVdhcm5pbmdQcmludGVyKFtcIlRoZSBkZWZhdWx0IGV4cG9ydCBvZiBAc2FuaXR5L2NsaWVudCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgdGhlIG5hbWVkIGV4cG9ydCBgY3JlYXRlQ2xpZW50YCBpbnN0ZWFkLlwiXSk7XG5jb25zdCBkZWZhdWx0Q2RuSG9zdCA9IFwiYXBpY2RuLnNhbml0eS5pb1wiO1xuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgYXBpSG9zdDogXCJodHRwczovL2FwaS5zYW5pdHkuaW9cIixcbiAgYXBpVmVyc2lvbjogXCIxXCIsXG4gIHVzZVByb2plY3RIb3N0bmFtZTogdHJ1ZVxufTtcbmNvbnN0IExPQ0FMSE9TVFMgPSBbXCJsb2NhbGhvc3RcIiwgXCIxMjcuMC4wLjFcIiwgXCIwLjAuMC4wXCJdO1xuY29uc3QgaXNMb2NhbCA9IGhvc3QgPT4gTE9DQUxIT1NUUy5pbmRleE9mKGhvc3QpICE9PSAtMTtcbmNvbnN0IHZhbGlkYXRlQXBpVmVyc2lvbiA9IGZ1bmN0aW9uIHZhbGlkYXRlQXBpVmVyc2lvbjIoYXBpVmVyc2lvbikge1xuICBpZiAoYXBpVmVyc2lvbiA9PT0gXCIxXCIgfHwgYXBpVmVyc2lvbiA9PT0gXCJYXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYXBpRGF0ZSA9IG5ldyBEYXRlKGFwaVZlcnNpb24pO1xuICBjb25zdCBhcGlWZXJzaW9uVmFsaWQgPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9JC8udGVzdChhcGlWZXJzaW9uKSAmJiBhcGlEYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiBhcGlEYXRlLmdldFRpbWUoKSA+IDA7XG4gIGlmICghYXBpVmVyc2lvblZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBBUEkgdmVyc2lvbiBzdHJpbmcsIGV4cGVjdGVkIGAxYCBvciBkYXRlIGluIGZvcm1hdCBgWVlZWS1NTS1ERGBcIik7XG4gIH1cbn07XG5jb25zdCB2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlID0gZnVuY3Rpb24gdmFsaWRhdGVBcGlQZXJzcGVjdGl2ZTIocGVyc3BlY3RpdmUpIHtcbiAgc3dpdGNoIChwZXJzcGVjdGl2ZSkge1xuICAgIGNhc2UgXCJwcmV2aWV3RHJhZnRzXCI6XG4gICAgY2FzZSBcInB1Ymxpc2hlZFwiOlxuICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgQVBJIHBlcnNwZWN0aXZlIHN0cmluZywgZXhwZWN0ZWQgYHB1Ymxpc2hlZGAsIGBwcmV2aWV3RHJhZnRzYCBvciBgcmF3YFwiKTtcbiAgfVxufTtcbmNvbnN0IGluaXRDb25maWcgPSAoY29uZmlnLCBwcmV2Q29uZmlnKSA9PiB7XG4gIGNvbnN0IHNwZWNpZmllZENvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIHByZXZDb25maWcsIGNvbmZpZyk7XG4gIGlmICghc3BlY2lmaWVkQ29uZmlnLmFwaVZlcnNpb24pIHtcbiAgICBwcmludE5vQXBpVmVyc2lvblNwZWNpZmllZFdhcm5pbmcoKTtcbiAgfVxuICBjb25zdCBuZXdDb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnLCBzcGVjaWZpZWRDb25maWcpO1xuICBjb25zdCBwcm9qZWN0QmFzZWQgPSBuZXdDb25maWcudXNlUHJvamVjdEhvc3RuYW1lO1xuICBpZiAodHlwZW9mIFByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBoZWxwVXJsID0gZ2VuZXJhdGVIZWxwVXJsKFwianMtY2xpZW50LXByb21pc2UtcG9seWZpbGxcIik7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbmF0aXZlIFByb21pc2UtaW1wbGVtZW50YXRpb24gZm91bmQsIHBvbHlmaWxsIG5lZWRlZCAtIHNlZSBcIi5jb25jYXQoaGVscFVybCkpO1xuICB9XG4gIGlmIChwcm9qZWN0QmFzZWQgJiYgIW5ld0NvbmZpZy5wcm9qZWN0SWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWd1cmF0aW9uIG11c3QgY29udGFpbiBgcHJvamVjdElkYFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG5ld0NvbmZpZy5wZXJzcGVjdGl2ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhbGlkYXRlQXBpUGVyc3BlY3RpdmUobmV3Q29uZmlnLnBlcnNwZWN0aXZlKTtcbiAgfVxuICBpZiAoXCJlbmNvZGVTb3VyY2VNYXBBdFBhdGhcIiBpbiBuZXdDb25maWcgfHwgXCJlbmNvZGVTb3VyY2VNYXBcIiBpbiBuZXdDb25maWcgfHwgXCJzdHVkaW9VcmxcIiBpbiBuZXdDb25maWcgfHwgXCJsb2dnZXJcIiBpbiBuZXdDb25maWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyBvcHRpb25zIG1lYW50IGZvciAnQHNhbml0eS9wcmV2aWV3LWtpdC9jbGllbnQnLCBzdWNoIGFzICdlbmNvZGVTb3VyY2VNYXBBdFBhdGgnLCAnZW5jb2RlU291cmNlTWFwJywgJ3N0dWRpb1VybCcgYW5kICdsb2dnZXInLiBNYWtlIHN1cmUgeW91J3JlIHVzaW5nIHRoZSByaWdodCBpbXBvcnQuXCIpO1xuICB9XG4gIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgY29uc3QgaXNMb2NhbGhvc3QgPSBpc0Jyb3dzZXIgJiYgaXNMb2NhbCh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpO1xuICBpZiAoaXNCcm93c2VyICYmIGlzTG9jYWxob3N0ICYmIG5ld0NvbmZpZy50b2tlbiAmJiBuZXdDb25maWcuaWdub3JlQnJvd3NlclRva2VuV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgIHByaW50QnJvd3NlclRva2VuV2FybmluZygpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuZXdDb25maWcudXNlQ2RuID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcHJpbnRDZG5XYXJuaW5nKCk7XG4gIH1cbiAgaWYgKHByb2plY3RCYXNlZCkge1xuICAgIHByb2plY3RJZChuZXdDb25maWcucHJvamVjdElkKTtcbiAgfVxuICBpZiAobmV3Q29uZmlnLmRhdGFzZXQpIHtcbiAgICBkYXRhc2V0KG5ld0NvbmZpZy5kYXRhc2V0KTtcbiAgfVxuICBpZiAoXCJyZXF1ZXN0VGFnUHJlZml4XCIgaW4gbmV3Q29uZmlnKSB7XG4gICAgbmV3Q29uZmlnLnJlcXVlc3RUYWdQcmVmaXggPSBuZXdDb25maWcucmVxdWVzdFRhZ1ByZWZpeCA/IHJlcXVlc3RUYWcobmV3Q29uZmlnLnJlcXVlc3RUYWdQcmVmaXgpLnJlcGxhY2UoL1xcLiskLywgXCJcIikgOiB2b2lkIDA7XG4gIH1cbiAgbmV3Q29uZmlnLmFwaVZlcnNpb24gPSBcIlwiLmNvbmNhdChuZXdDb25maWcuYXBpVmVyc2lvbikucmVwbGFjZSgvXnYvLCBcIlwiKTtcbiAgbmV3Q29uZmlnLmlzRGVmYXVsdEFwaSA9IG5ld0NvbmZpZy5hcGlIb3N0ID09PSBkZWZhdWx0Q29uZmlnLmFwaUhvc3Q7XG4gIG5ld0NvbmZpZy51c2VDZG4gPSBuZXdDb25maWcudXNlQ2RuICE9PSBmYWxzZSAmJiAhbmV3Q29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgdmFsaWRhdGVBcGlWZXJzaW9uKG5ld0NvbmZpZy5hcGlWZXJzaW9uKTtcbiAgY29uc3QgaG9zdFBhcnRzID0gbmV3Q29uZmlnLmFwaUhvc3Quc3BsaXQoXCI6Ly9cIiwgMik7XG4gIGNvbnN0IHByb3RvY29sID0gaG9zdFBhcnRzWzBdO1xuICBjb25zdCBob3N0ID0gaG9zdFBhcnRzWzFdO1xuICBjb25zdCBjZG5Ib3N0ID0gbmV3Q29uZmlnLmlzRGVmYXVsdEFwaSA/IGRlZmF1bHRDZG5Ib3N0IDogaG9zdDtcbiAgaWYgKG5ld0NvbmZpZy51c2VQcm9qZWN0SG9zdG5hbWUpIHtcbiAgICBuZXdDb25maWcudXJsID0gXCJcIi5jb25jYXQocHJvdG9jb2wsIFwiOi8vXCIpLmNvbmNhdChuZXdDb25maWcucHJvamVjdElkLCBcIi5cIikuY29uY2F0KGhvc3QsIFwiL3ZcIikuY29uY2F0KG5ld0NvbmZpZy5hcGlWZXJzaW9uKTtcbiAgICBuZXdDb25maWcuY2RuVXJsID0gXCJcIi5jb25jYXQocHJvdG9jb2wsIFwiOi8vXCIpLmNvbmNhdChuZXdDb25maWcucHJvamVjdElkLCBcIi5cIikuY29uY2F0KGNkbkhvc3QsIFwiL3ZcIikuY29uY2F0KG5ld0NvbmZpZy5hcGlWZXJzaW9uKTtcbiAgfSBlbHNlIHtcbiAgICBuZXdDb25maWcudXJsID0gXCJcIi5jb25jYXQobmV3Q29uZmlnLmFwaUhvc3QsIFwiL3ZcIikuY29uY2F0KG5ld0NvbmZpZy5hcGlWZXJzaW9uKTtcbiAgICBuZXdDb25maWcuY2RuVXJsID0gbmV3Q29uZmlnLnVybDtcbiAgfVxuICByZXR1cm4gbmV3Q29uZmlnO1xufTtcbmNvbnN0IHByb2plY3RIZWFkZXIgPSBcIlgtU2FuaXR5LVByb2plY3QtSURcIjtcbmZ1bmN0aW9uIHJlcXVlc3RPcHRpb25zKGNvbmZpZykge1xuICBsZXQgb3ZlcnJpZGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBjb25zdCB0b2tlbiA9IG92ZXJyaWRlcy50b2tlbiB8fCBjb25maWcudG9rZW47XG4gIGlmICh0b2tlbikge1xuICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IFwiQmVhcmVyIFwiLmNvbmNhdCh0b2tlbik7XG4gIH1cbiAgaWYgKCFvdmVycmlkZXMudXNlR2xvYmFsQXBpICYmICFjb25maWcudXNlUHJvamVjdEhvc3RuYW1lICYmIGNvbmZpZy5wcm9qZWN0SWQpIHtcbiAgICBoZWFkZXJzW3Byb2plY3RIZWFkZXJdID0gY29uZmlnLnByb2plY3RJZDtcbiAgfVxuICBjb25zdCB3aXRoQ3JlZGVudGlhbHMgPSBCb29sZWFuKHR5cGVvZiBvdmVycmlkZXMud2l0aENyZWRlbnRpYWxzID09PSBcInVuZGVmaW5lZFwiID8gY29uZmlnLnRva2VuIHx8IGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgOiBvdmVycmlkZXMud2l0aENyZWRlbnRpYWxzKTtcbiAgY29uc3QgdGltZW91dCA9IHR5cGVvZiBvdmVycmlkZXMudGltZW91dCA9PT0gXCJ1bmRlZmluZWRcIiA/IGNvbmZpZy50aW1lb3V0IDogb3ZlcnJpZGVzLnRpbWVvdXQ7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZXMsIHtcbiAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzLCBvdmVycmlkZXMuaGVhZGVycyB8fCB7fSksXG4gICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09IFwidW5kZWZpbmVkXCIgPyA1ICogNjAgKiAxZTMgOiB0aW1lb3V0LFxuICAgIHByb3h5OiBvdmVycmlkZXMucHJveHkgfHwgY29uZmlnLnByb3h5LFxuICAgIGpzb246IHRydWUsXG4gICAgd2l0aENyZWRlbnRpYWxzLFxuICAgIGZldGNoOiB0eXBlb2Ygb3ZlcnJpZGVzLmZldGNoID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjb25maWcuZmV0Y2ggPT09IFwib2JqZWN0XCIgPyB7XG4gICAgICAuLi5jb25maWcuZmV0Y2gsXG4gICAgICAuLi5vdmVycmlkZXMuZmV0Y2hcbiAgICB9IDogb3ZlcnJpZGVzLmZldGNoIHx8IGNvbmZpZy5mZXRjaFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihzZWwpIHtcbiAgaWYgKHR5cGVvZiBzZWwgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShzZWwpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBzZWxcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2Ygc2VsID09PSBcIm9iamVjdFwiICYmIHNlbCAhPT0gbnVsbCAmJiBcInF1ZXJ5XCIgaW4gc2VsICYmIHR5cGVvZiBzZWwucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gXCJwYXJhbXNcIiBpbiBzZWwgJiYgdHlwZW9mIHNlbC5wYXJhbXMgPT09IFwib2JqZWN0XCIgJiYgc2VsLnBhcmFtcyAhPT0gbnVsbCA/IHtcbiAgICAgIHF1ZXJ5OiBzZWwucXVlcnksXG4gICAgICBwYXJhbXM6IHNlbC5wYXJhbXNcbiAgICB9IDoge1xuICAgICAgcXVlcnk6IHNlbC5xdWVyeVxuICAgIH07XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uT3B0cyA9IFtcIiogRG9jdW1lbnQgSUQgKDxkb2NJZD4pXCIsIFwiKiBBcnJheSBvZiBkb2N1bWVudCBJRHNcIiwgXCIqIE9iamVjdCBjb250YWluaW5nIGBxdWVyeWBcIl0uam9pbihcIlxcblwiKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBzZWxlY3Rpb24gLSBtdXN0IGJlIG9uZSBvZjpcXG5cXG5cIi5jb25jYXQoc2VsZWN0aW9uT3B0cykpO1xufVxuY29uc3QgZW5jb2RlUXVlcnlTdHJpbmcgPSBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgcXVlcnksXG4gICAgcGFyYW1zID0ge30sXG4gICAgb3B0aW9ucyA9IHt9XG4gIH0gPSBfcmVmMjtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBjb25zdCB7XG4gICAgdGFnLFxuICAgIC4uLm9wdHNcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICh0YWcpIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCJ0YWdcIiwgdGFnKTtcbiAgc2VhcmNoUGFyYW1zLmFwcGVuZChcInF1ZXJ5XCIsIHF1ZXJ5KTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoXCIkXCIuY29uY2F0KGtleSksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0cykpIHtcbiAgICBpZiAodmFsdWUpIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBcIlwiLmNvbmNhdCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBcIj9cIi5jb25jYXQoc2VhcmNoUGFyYW1zKTtcbn07XG52YXIgX19hY2Nlc3NDaGVjayQ2ID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCQ2ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayQ2KG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkJDYgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQkNiA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrJDYob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9jbGllbnQkNSwgX2NsaWVudDIkNTtcbmNsYXNzIEJhc2VQYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdGlvbikge1xuICAgIGxldCBvcGVyYXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBvcGVyYXRpb25zO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIHRvIHRoZSBkb2N1bWVudC4gRG9lcyBOT1QgbWVyZ2Ugb2JqZWN0cy5cbiAgICogVGhlIG9wZXJhdGlvbiBpcyBhZGRlZCB0byB0aGUgY3VycmVudCBwYXRjaCwgcmVhZHkgdG8gYmUgY29tbWl0ZWQgYnkgYGNvbW1pdCgpYFxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBBdHRyaWJ1dGVzIHRvIHNldC4gVG8gc2V0IGEgZGVlcCBhdHRyaWJ1dGUsIHVzZSBKU09OTWF0Y2gsIGVnOiBcXHtcIm5lc3RlZC5wcm9wXCI6IFwidmFsdWVcIlxcfVxuICAgKi9cbiAgc2V0KGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcInNldFwiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG8gdGhlIGRvY3VtZW50IGlmIHRoZXkgYXJlIG5vdCBjdXJyZW50bHkgc2V0LiBEb2VzIE5PVCBtZXJnZSBvYmplY3RzLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHBhdGNoLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZXMgdG8gc2V0LiBUbyBzZXQgYSBkZWVwIGF0dHJpYnV0ZSwgdXNlIEpTT05NYXRjaCwgZWc6IFxce1wibmVzdGVkLnByb3BcIjogXCJ2YWx1ZVwiXFx9XG4gICAqL1xuICBzZXRJZk1pc3NpbmcoYXR0cnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKFwic2V0SWZNaXNzaW5nXCIsIGF0dHJzKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgYSBcImRpZmYtbWF0Y2gtcGF0Y2hcIiBvcGVyYXRpb24gb24gdGhlIHN0cmluZyBhdHRyaWJ1dGVzIHByb3ZpZGVkLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHBhdGNoLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZXMgdG8gcGVyZm9ybSBvcGVyYXRpb24gb24uIFRvIHNldCBhIGRlZXAgYXR0cmlidXRlLCB1c2UgSlNPTk1hdGNoLCBlZzogXFx7XCJuZXN0ZWQucHJvcFwiOiBcImRtcFwiXFx9XG4gICAqL1xuICBkaWZmTWF0Y2hQYXRjaChhdHRycykge1xuICAgIHZhbGlkYXRlT2JqZWN0KFwiZGlmZk1hdGNoUGF0Y2hcIiwgYXR0cnMpO1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oXCJkaWZmTWF0Y2hQYXRjaFwiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFVuc2V0cyB0aGUgYXR0cmlidXRlIHBhdGhzIHByb3ZpZGVkLlxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHBhdGNoLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIEF0dHJpYnV0ZSBwYXRocyB0byB1bnNldC5cbiAgICovXG4gIHVuc2V0KGF0dHJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zZXQoYXR0cnMpIHRha2VzIGFuIGFycmF5IG9mIGF0dHJpYnV0ZXMgdG8gdW5zZXQsIG5vbi1hcnJheSBnaXZlblwiKTtcbiAgICB9XG4gICAgdGhpcy5vcGVyYXRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcGVyYXRpb25zLCB7XG4gICAgICB1bnNldDogYXR0cnNcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogSW5jcmVtZW50IGEgbnVtZXJpYyB2YWx1ZS4gRWFjaCBlbnRyeSBpbiB0aGUgYXJndW1lbnQgaXMgZWl0aGVyIGFuIGF0dHJpYnV0ZSBvciBhIEpTT04gcGF0aC4gVGhlIHZhbHVlIG1heSBiZSBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuIFRoZSBvcGVyYXRpb24gd2lsbCBmYWlsIGlmIHRhcmdldCB2YWx1ZSBpcyBub3QgYSBudW1lcmljIHZhbHVlLCBvciBkb2Vzbid0IGV4aXN0LlxuICAgKlxuICAgKiBAcGFyYW0gYXR0cnMgLSBPYmplY3Qgb2YgYXR0cmlidXRlIHBhdGhzIHRvIGluY3JlbWVudCwgdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIHRvIGluY3JlbWVudCBieS5cbiAgICovXG4gIGluYyhhdHRycykge1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oXCJpbmNcIiwgYXR0cnMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWNyZW1lbnQgYSBudW1lcmljIHZhbHVlLiBFYWNoIGVudHJ5IGluIHRoZSBhcmd1bWVudCBpcyBlaXRoZXIgYW4gYXR0cmlidXRlIG9yIGEgSlNPTiBwYXRoLiBUaGUgdmFsdWUgbWF5IGJlIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS4gVGhlIG9wZXJhdGlvbiB3aWxsIGZhaWwgaWYgdGFyZ2V0IHZhbHVlIGlzIG5vdCBhIG51bWVyaWMgdmFsdWUsIG9yIGRvZXNuJ3QgZXhpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBhdHRycyAtIE9iamVjdCBvZiBhdHRyaWJ1dGUgcGF0aHMgdG8gZGVjcmVtZW50LCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgdG8gZGVjcmVtZW50IGJ5LlxuICAgKi9cbiAgZGVjKGF0dHJzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihcImRlY1wiLCBhdHRycyk7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIG1vZGlmeWluZyBhcnJheXMsIGJ5IGluc2VydGluZywgYXBwZW5kaW5nIGFuZCByZXBsYWNpbmcgZWxlbWVudHMgdmlhIGEgSlNPTlBhdGggZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIGF0IC0gTG9jYXRpb24gdG8gaW5zZXJ0IGF0LCByZWxhdGl2ZSB0byB0aGUgZ2l2ZW4gc2VsZWN0b3IsIG9yICdyZXBsYWNlJyB0aGUgbWF0Y2hlZCBwYXRoXG4gICAqIEBwYXJhbSBzZWxlY3RvciAtIEpTT05QYXRoIGV4cHJlc3Npb24sIGVnIGBjb21tZW50c1stMV1gIG9yIGBibG9ja3NbX2tleT09XCJhYmMxMjNcIl1gXG4gICAqIEBwYXJhbSBpdGVtcyAtIEFycmF5IG9mIGl0ZW1zIHRvIGluc2VydC9yZXBsYWNlXG4gICAqL1xuICBpbnNlcnQoYXQsIHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHZhbGlkYXRlSW5zZXJ0KGF0LCBzZWxlY3RvciwgaXRlbXMpO1xuICAgIHJldHVybiB0aGlzLl9hc3NpZ24oXCJpbnNlcnRcIiwge1xuICAgICAgW2F0XTogc2VsZWN0b3IsXG4gICAgICBpdGVtc1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmQgdGhlIGdpdmVuIGl0ZW1zIHRvIHRoZSBhcnJheSBhdCB0aGUgZ2l2ZW4gSlNPTlBhdGhcbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdG9yIC0gQXR0cmlidXRlL3BhdGggdG8gYXBwZW5kIHRvLCBlZyBgY29tbWVudHNgIG9yIGBwZXJzb24uaG9iYmllc2BcbiAgICogQHBhcmFtIGl0ZW1zIC0gQXJyYXkgb2YgaXRlbXMgdG8gYXBwZW5kIHRvIHRoZSBhcnJheVxuICAgKi9cbiAgYXBwZW5kKHNlbGVjdG9yLCBpdGVtcykge1xuICAgIHJldHVybiB0aGlzLmluc2VydChcImFmdGVyXCIsIFwiXCIuY29uY2F0KHNlbGVjdG9yLCBcIlstMV1cIiksIGl0ZW1zKTtcbiAgfVxuICAvKipcbiAgICogUHJlcGVuZCB0aGUgZ2l2ZW4gaXRlbXMgdG8gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiBKU09OUGF0aFxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBBdHRyaWJ1dGUvcGF0aCB0byBwcmVwZW5kIHRvLCBlZyBgY29tbWVudHNgIG9yIGBwZXJzb24uaG9iYmllc2BcbiAgICogQHBhcmFtIGl0ZW1zIC0gQXJyYXkgb2YgaXRlbXMgdG8gcHJlcGVuZCB0byB0aGUgYXJyYXlcbiAgICovXG4gIHByZXBlbmQoc2VsZWN0b3IsIGl0ZW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0KFwiYmVmb3JlXCIsIFwiXCIuY29uY2F0KHNlbGVjdG9yLCBcIlswXVwiKSwgaXRlbXMpO1xuICB9XG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGNvbnRlbnRzIG9mIGFuIGFycmF5IGJ5IHJlbW92aW5nIGV4aXN0aW5nIGVsZW1lbnRzIGFuZC9vciBhZGRpbmcgbmV3IGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0b3IgLSBBdHRyaWJ1dGUgb3IgSlNPTlBhdGggZXhwcmVzc2lvbiBmb3IgYXJyYXlcbiAgICogQHBhcmFtIHN0YXJ0IC0gSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5ICh3aXRoIG9yaWdpbiAwKS4gSWYgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LCBhY3R1YWwgc3RhcnRpbmcgaW5kZXggd2lsbCBiZSBzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuIElmIG5lZ2F0aXZlLCB3aWxsIGJlZ2luIHRoYXQgbWFueSBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5ICh3aXRoIG9yaWdpbiAtMSkgYW5kIHdpbGwgYmUgc2V0IHRvIDAgaWYgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LnhcbiAgICogQHBhcmFtIGRlbGV0ZUNvdW50IC0gQW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2Ygb2xkIGFycmF5IGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIGl0ZW1zIC0gVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgYXJyYXksIGJlZ2lubmluZyBhdCB0aGUgc3RhcnQgaW5kZXguIElmIHlvdSBkb24ndCBzcGVjaWZ5IGFueSBlbGVtZW50cywgc3BsaWNlKCkgd2lsbCBvbmx5IHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBhcnJheS5cbiAgICovXG4gIHNwbGljZShzZWxlY3Rvciwgc3RhcnQsIGRlbGV0ZUNvdW50LCBpdGVtcykge1xuICAgIGNvbnN0IGRlbEFsbCA9IHR5cGVvZiBkZWxldGVDb3VudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBkZWxldGVDb3VudCA9PT0gLTE7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHN0YXJ0IDwgMCA/IHN0YXJ0IC0gMSA6IHN0YXJ0O1xuICAgIGNvbnN0IGRlbENvdW50ID0gZGVsQWxsID8gLTEgOiBNYXRoLm1heCgwLCBzdGFydCArIGRlbGV0ZUNvdW50KTtcbiAgICBjb25zdCBkZWxSYW5nZSA9IHN0YXJ0SW5kZXggPCAwICYmIGRlbENvdW50ID49IDAgPyBcIlwiIDogZGVsQ291bnQ7XG4gICAgY29uc3QgcmFuZ2VTZWxlY3RvciA9IFwiXCIuY29uY2F0KHNlbGVjdG9yLCBcIltcIikuY29uY2F0KHN0YXJ0SW5kZXgsIFwiOlwiKS5jb25jYXQoZGVsUmFuZ2UsIFwiXVwiKTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnQoXCJyZXBsYWNlXCIsIHJhbmdlU2VsZWN0b3IsIGl0ZW1zIHx8IFtdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJldmlzaW9uIGNsYXVzZSwgcHJldmVudGluZyB0aGUgZG9jdW1lbnQgZnJvbSBiZWluZyBwYXRjaGVkIGlmIHRoZSBgX3JldmAgcHJvcGVydHkgZG9lcyBub3QgbWF0Y2ggdGhlIGdpdmVuIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSByZXYgLSBSZXZpc2lvbiB0byBsb2NrIHRoZSBwYXRjaCB0b1xuICAgKi9cbiAgaWZSZXZpc2lvbklkKHJldikge1xuICAgIHRoaXMub3BlcmF0aW9ucy5pZlJldmlzaW9uSUQgPSByZXY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIHBsYWluIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhdGNoXG4gICAqL1xuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmdldFNlbGVjdGlvbih0aGlzLnNlbGVjdGlvbiksXG4gICAgICAuLi50aGlzLm9wZXJhdGlvbnNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXRjaFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHBhdGNoIG9mIGFsbCBvcGVyYXRpb25zXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfYXNzaWduKG9wLCBwcm9wcykge1xuICAgIGxldCBtZXJnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICB2YWxpZGF0ZU9iamVjdChvcCwgcHJvcHMpO1xuICAgIHRoaXMub3BlcmF0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3BlcmF0aW9ucywge1xuICAgICAgW29wXTogT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2UgJiYgdGhpcy5vcGVyYXRpb25zW29wXSB8fCB7fSwgcHJvcHMpXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX3NldChvcCwgcHJvcHMpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzaWduKG9wLCBwcm9wcywgZmFsc2UpO1xuICB9XG59XG5jb25zdCBfT2JzZXJ2YWJsZVBhdGNoID0gY2xhc3MgX09ic2VydmFibGVQYXRjaCBleHRlbmRzIEJhc2VQYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdGlvbiwgb3BlcmF0aW9ucywgY2xpZW50KSB7XG4gICAgc3VwZXIoc2VsZWN0aW9uLCBvcGVyYXRpb25zKTtcbiAgICBfX3ByaXZhdGVBZGQkNih0aGlzLCBfY2xpZW50JDUsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0JDYodGhpcywgX2NsaWVudCQ1LCBjbGllbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHBhdGNoXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9PYnNlcnZhYmxlUGF0Y2godGhpcy5zZWxlY3Rpb24sIHtcbiAgICAgIC4uLnRoaXMub3BlcmF0aW9uc1xuICAgIH0sIF9fcHJpdmF0ZUdldCQ2KHRoaXMsIF9jbGllbnQkNSkpO1xuICB9XG4gIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQkNih0aGlzLCBfY2xpZW50JDUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBgY2xpZW50YCBwYXNzZWQgdG8gcGF0Y2gsIGVpdGhlciBwcm92aWRlIG9uZSBvciBwYXNzIHRoZSBwYXRjaCB0byBhIGNsaWVudHMgYG11dGF0ZSgpYCBtZXRob2RcIik7XG4gICAgfVxuICAgIGNvbnN0IHJldHVybkZpcnN0ID0gdHlwZW9mIHRoaXMuc2VsZWN0aW9uID09PSBcInN0cmluZ1wiO1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHJldHVybkZpcnN0LFxuICAgICAgcmV0dXJuRG9jdW1lbnRzOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCQ2KHRoaXMsIF9jbGllbnQkNSkubXV0YXRlKHtcbiAgICAgIHBhdGNoOiB0aGlzLnNlcmlhbGl6ZSgpXG4gICAgfSwgb3B0cyk7XG4gIH1cbn07XG5fY2xpZW50JDUgPSBuZXcgV2Vha01hcCgpO1xubGV0IE9ic2VydmFibGVQYXRjaCA9IF9PYnNlcnZhYmxlUGF0Y2g7XG5jb25zdCBfUGF0Y2ggPSBjbGFzcyBfUGF0Y2ggZXh0ZW5kcyBCYXNlUGF0Y2gge1xuICBjb25zdHJ1Y3RvcihzZWxlY3Rpb24sIG9wZXJhdGlvbnMsIGNsaWVudCkge1xuICAgIHN1cGVyKHNlbGVjdGlvbiwgb3BlcmF0aW9ucyk7XG4gICAgX19wcml2YXRlQWRkJDYodGhpcywgX2NsaWVudDIkNSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVTZXQkNih0aGlzLCBfY2xpZW50MiQ1LCBjbGllbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHBhdGNoXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9QYXRjaCh0aGlzLnNlbGVjdGlvbiwge1xuICAgICAgLi4udGhpcy5vcGVyYXRpb25zXG4gICAgfSwgX19wcml2YXRlR2V0JDYodGhpcywgX2NsaWVudDIkNSkpO1xuICB9XG4gIGNvbW1pdChvcHRpb25zKSB7XG4gICAgaWYgKCFfX3ByaXZhdGVHZXQkNih0aGlzLCBfY2xpZW50MiQ1KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYGNsaWVudGAgcGFzc2VkIHRvIHBhdGNoLCBlaXRoZXIgcHJvdmlkZSBvbmUgb3IgcGFzcyB0aGUgcGF0Y2ggdG8gYSBjbGllbnRzIGBtdXRhdGUoKWAgbWV0aG9kXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXR1cm5GaXJzdCA9IHR5cGVvZiB0aGlzLnNlbGVjdGlvbiA9PT0gXCJzdHJpbmdcIjtcbiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICByZXR1cm5GaXJzdCxcbiAgICAgIHJldHVybkRvY3VtZW50czogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQkNih0aGlzLCBfY2xpZW50MiQ1KS5tdXRhdGUoe1xuICAgICAgcGF0Y2g6IHRoaXMuc2VyaWFsaXplKClcbiAgICB9LCBvcHRzKTtcbiAgfVxufTtcbl9jbGllbnQyJDUgPSBuZXcgV2Vha01hcCgpO1xubGV0IFBhdGNoID0gX1BhdGNoO1xudmFyIF9fYWNjZXNzQ2hlY2skNSA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQkNSA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2skNShvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCQ1ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0JDUgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayQ1KG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfY2xpZW50JDQsIF9jbGllbnQyJDQ7XG5jb25zdCBkZWZhdWx0TXV0YXRlT3B0aW9ucyA9IHtcbiAgcmV0dXJuRG9jdW1lbnRzOiBmYWxzZVxufTtcbmNsYXNzIEJhc2VUcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcGVyYXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcbiAgICBsZXQgdHJhbnNhY3Rpb25JZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHRoaXMub3BlcmF0aW9ucyA9IG9wZXJhdGlvbnM7XG4gICAgdGhpcy50cnhJZCA9IHRyYW5zYWN0aW9uSWQ7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU2FuaXR5IGRvY3VtZW50LiBJZiBgX2lkYCBpcyBwcm92aWRlZCBhbmQgYWxyZWFkeSBleGlzdHMsIHRoZSBtdXRhdGlvbiB3aWxsIGZhaWwuIElmIG5vIGBfaWRgIGlzIGdpdmVuLCBvbmUgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGdlbmVyYXRlZCBieSB0aGUgZGF0YWJhc2UuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24sIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGRvYyAtIERvY3VtZW50IHRvIGNyZWF0ZS4gUmVxdWlyZXMgYSBgX3R5cGVgIHByb3BlcnR5LlxuICAgKi9cbiAgY3JlYXRlKGRvYykge1xuICAgIHZhbGlkYXRlT2JqZWN0KFwiY3JlYXRlXCIsIGRvYyk7XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh7XG4gICAgICBjcmVhdGU6IGRvY1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNhbml0eSBkb2N1bWVudC4gSWYgYSBkb2N1bWVudCB3aXRoIHRoZSBzYW1lIGBfaWRgIGFscmVhZHkgZXhpc3RzLCB0aGUgY3JlYXRlIG9wZXJhdGlvbiB3aWxsIGJlIGlnbm9yZWQuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24sIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGRvYyAtIERvY3VtZW50IHRvIGNyZWF0ZSBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0LiBSZXF1aXJlcyBgX2lkYCBhbmQgYF90eXBlYCBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgY3JlYXRlSWZOb3RFeGlzdHMoZG9jKSB7XG4gICAgY29uc3Qgb3AgPSBcImNyZWF0ZUlmTm90RXhpc3RzXCI7XG4gICAgdmFsaWRhdGVPYmplY3Qob3AsIGRvYyk7XG4gICAgcmVxdWlyZURvY3VtZW50SWQob3AsIGRvYyk7XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh7XG4gICAgICBbb3BdOiBkb2NcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTYW5pdHkgZG9jdW1lbnQsIG9yIHJlcGxhY2VzIGFuIGV4aXN0aW5nIG9uZSBpZiB0aGUgc2FtZSBgX2lkYCBpcyBhbHJlYWR5IHVzZWQuXG4gICAqIFRoZSBvcGVyYXRpb24gaXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24sIHJlYWR5IHRvIGJlIGNvbW1pdGVkIGJ5IGBjb21taXQoKWBcbiAgICpcbiAgICogQHBhcmFtIGRvYyAtIERvY3VtZW50IHRvIGNyZWF0ZSBvciByZXBsYWNlLiBSZXF1aXJlcyBgX2lkYCBhbmQgYF90eXBlYCBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgY3JlYXRlT3JSZXBsYWNlKGRvYykge1xuICAgIGNvbnN0IG9wID0gXCJjcmVhdGVPclJlcGxhY2VcIjtcbiAgICB2YWxpZGF0ZU9iamVjdChvcCwgZG9jKTtcbiAgICByZXF1aXJlRG9jdW1lbnRJZChvcCwgZG9jKTtcbiAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgIFtvcF06IGRvY1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSBkb2N1bWVudCB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudCBJRFxuICAgKiBUaGUgb3BlcmF0aW9uIGlzIGFkZGVkIHRvIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLCByZWFkeSB0byBiZSBjb21taXRlZCBieSBgY29tbWl0KClgXG4gICAqXG4gICAqIEBwYXJhbSBkb2N1bWVudElkIC0gRG9jdW1lbnQgSUQgdG8gZGVsZXRlXG4gICAqL1xuICBkZWxldGUoZG9jdW1lbnRJZCkge1xuICAgIHZhbGlkYXRlRG9jdW1lbnRJZChcImRlbGV0ZVwiLCBkb2N1bWVudElkKTtcbiAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgIGRlbGV0ZToge1xuICAgICAgICBpZDogZG9jdW1lbnRJZFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRyYW5zYWN0aW9uSWQoaWQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICByZXR1cm4gdGhpcy50cnhJZDtcbiAgICB9XG4gICAgdGhpcy50cnhJZCA9IGlkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwbGFpbiBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBbLi4udGhpcy5vcGVyYXRpb25zXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgcGxhaW4gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHRoZSB0cmFuc2FjdGlvbiBvZiBhbGwgb3BlcmF0aW9uc1xuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5vcGVyYXRpb25zID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2FkZChtdXQpIHtcbiAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChtdXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jb25zdCBfVHJhbnNhY3Rpb24gPSBjbGFzcyBfVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihvcGVyYXRpb25zLCBjbGllbnQsIHRyYW5zYWN0aW9uSWQpIHtcbiAgICBzdXBlcihvcGVyYXRpb25zLCB0cmFuc2FjdGlvbklkKTtcbiAgICBfX3ByaXZhdGVBZGQkNSh0aGlzLCBfY2xpZW50JDQsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0JDUodGhpcywgX2NsaWVudCQ0LCBjbGllbnQpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9UcmFuc2FjdGlvbihbLi4udGhpcy5vcGVyYXRpb25zXSwgX19wcml2YXRlR2V0JDUodGhpcywgX2NsaWVudCQ0KSwgdGhpcy50cnhJZCk7XG4gIH1cbiAgY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCQ1KHRoaXMsIF9jbGllbnQkNCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGBjbGllbnRgIHBhc3NlZCB0byB0cmFuc2FjdGlvbiwgZWl0aGVyIHByb3ZpZGUgb25lIG9yIHBhc3MgdGhlIHRyYW5zYWN0aW9uIHRvIGEgY2xpZW50cyBgbXV0YXRlKClgIG1ldGhvZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCQ1KHRoaXMsIF9jbGllbnQkNCkubXV0YXRlKHRoaXMuc2VyaWFsaXplKCksIE9iamVjdC5hc3NpZ24oe1xuICAgICAgdHJhbnNhY3Rpb25JZDogdGhpcy50cnhJZFxuICAgIH0sIGRlZmF1bHRNdXRhdGVPcHRpb25zLCBvcHRpb25zIHx8IHt9KSk7XG4gIH1cbiAgcGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHBhdGNoT3BzKSB7XG4gICAgY29uc3QgaXNCdWlsZGVyID0gdHlwZW9mIHBhdGNoT3BzID09PSBcImZ1bmN0aW9uXCI7XG4gICAgY29uc3QgaXNQYXRjaCA9IHR5cGVvZiBwYXRjaE9yRG9jdW1lbnRJZCAhPT0gXCJzdHJpbmdcIiAmJiBwYXRjaE9yRG9jdW1lbnRJZCBpbnN0YW5jZW9mIFBhdGNoO1xuICAgIGlmIChpc1BhdGNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgICAgcGF0Y2g6IHBhdGNoT3JEb2N1bWVudElkLnNlcmlhbGl6ZSgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzQnVpbGRlcikge1xuICAgICAgY29uc3QgcGF0Y2ggPSBwYXRjaE9wcyhuZXcgUGF0Y2gocGF0Y2hPckRvY3VtZW50SWQsIHt9LCBfX3ByaXZhdGVHZXQkNSh0aGlzLCBfY2xpZW50JDQpKSk7XG4gICAgICBpZiAoIShwYXRjaCBpbnN0YW5jZW9mIFBhdGNoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmdW5jdGlvbiBwYXNzZWQgdG8gYHBhdGNoKClgIG11c3QgcmV0dXJuIHRoZSBwYXRjaFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9hZGQoe1xuICAgICAgICBwYXRjaDogcGF0Y2guc2VyaWFsaXplKClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgIHBhdGNoOiB7XG4gICAgICAgIGlkOiBwYXRjaE9yRG9jdW1lbnRJZCxcbiAgICAgICAgLi4ucGF0Y2hPcHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbl9jbGllbnQkNCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgVHJhbnNhY3Rpb24gPSBfVHJhbnNhY3Rpb247XG5jb25zdCBfT2JzZXJ2YWJsZVRyYW5zYWN0aW9uID0gY2xhc3MgX09ic2VydmFibGVUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9wZXJhdGlvbnMsIGNsaWVudCwgdHJhbnNhY3Rpb25JZCkge1xuICAgIHN1cGVyKG9wZXJhdGlvbnMsIHRyYW5zYWN0aW9uSWQpO1xuICAgIF9fcHJpdmF0ZUFkZCQ1KHRoaXMsIF9jbGllbnQyJDQsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0JDUodGhpcywgX2NsaWVudDIkNCwgY2xpZW50KTtcbiAgfVxuICAvKipcbiAgICogQ2xvbmVzIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfT2JzZXJ2YWJsZVRyYW5zYWN0aW9uKFsuLi50aGlzLm9wZXJhdGlvbnNdLCBfX3ByaXZhdGVHZXQkNSh0aGlzLCBfY2xpZW50MiQ0KSwgdGhpcy50cnhJZCk7XG4gIH1cbiAgY29tbWl0KG9wdGlvbnMpIHtcbiAgICBpZiAoIV9fcHJpdmF0ZUdldCQ1KHRoaXMsIF9jbGllbnQyJDQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBgY2xpZW50YCBwYXNzZWQgdG8gdHJhbnNhY3Rpb24sIGVpdGhlciBwcm92aWRlIG9uZSBvciBwYXNzIHRoZSB0cmFuc2FjdGlvbiB0byBhIGNsaWVudHMgYG11dGF0ZSgpYCBtZXRob2RcIik7XG4gICAgfVxuICAgIHJldHVybiBfX3ByaXZhdGVHZXQkNSh0aGlzLCBfY2xpZW50MiQ0KS5tdXRhdGUodGhpcy5zZXJpYWxpemUoKSwgT2JqZWN0LmFzc2lnbih7XG4gICAgICB0cmFuc2FjdGlvbklkOiB0aGlzLnRyeElkXG4gICAgfSwgZGVmYXVsdE11dGF0ZU9wdGlvbnMsIG9wdGlvbnMgfHwge30pKTtcbiAgfVxuICBwYXRjaChwYXRjaE9yRG9jdW1lbnRJZCwgcGF0Y2hPcHMpIHtcbiAgICBjb25zdCBpc0J1aWxkZXIgPSB0eXBlb2YgcGF0Y2hPcHMgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBjb25zdCBpc1BhdGNoID0gdHlwZW9mIHBhdGNoT3JEb2N1bWVudElkICE9PSBcInN0cmluZ1wiICYmIHBhdGNoT3JEb2N1bWVudElkIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVBhdGNoO1xuICAgIGlmIChpc1BhdGNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgICAgcGF0Y2g6IHBhdGNoT3JEb2N1bWVudElkLnNlcmlhbGl6ZSgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzQnVpbGRlcikge1xuICAgICAgY29uc3QgcGF0Y2ggPSBwYXRjaE9wcyhuZXcgT2JzZXJ2YWJsZVBhdGNoKHBhdGNoT3JEb2N1bWVudElkLCB7fSwgX19wcml2YXRlR2V0JDUodGhpcywgX2NsaWVudDIkNCkpKTtcbiAgICAgIGlmICghKHBhdGNoIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVBhdGNoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmdW5jdGlvbiBwYXNzZWQgdG8gYHBhdGNoKClgIG11c3QgcmV0dXJuIHRoZSBwYXRjaFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9hZGQoe1xuICAgICAgICBwYXRjaDogcGF0Y2guc2VyaWFsaXplKClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkKHtcbiAgICAgIHBhdGNoOiB7XG4gICAgICAgIGlkOiBwYXRjaE9yRG9jdW1lbnRJZCxcbiAgICAgICAgLi4ucGF0Y2hPcHNcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbl9jbGllbnQyJDQgPSBuZXcgV2Vha01hcCgpO1xubGV0IE9ic2VydmFibGVUcmFuc2FjdGlvbiA9IF9PYnNlcnZhYmxlVHJhbnNhY3Rpb247XG5jb25zdCBleGNsdWRlRmFsc2V5ID0gKHBhcmFtLCBkZWZWYWx1ZSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBwYXJhbSA9PT0gXCJ1bmRlZmluZWRcIiA/IGRlZlZhbHVlIDogcGFyYW07XG4gIHJldHVybiBwYXJhbSA9PT0gZmFsc2UgPyB2b2lkIDAgOiB2YWx1ZTtcbn07XG5jb25zdCBnZXRNdXRhdGlvblF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHJldHVybiB7XG4gICAgZHJ5UnVuOiBvcHRpb25zLmRyeVJ1bixcbiAgICByZXR1cm5JZHM6IHRydWUsXG4gICAgcmV0dXJuRG9jdW1lbnRzOiBleGNsdWRlRmFsc2V5KG9wdGlvbnMucmV0dXJuRG9jdW1lbnRzLCB0cnVlKSxcbiAgICB2aXNpYmlsaXR5OiBvcHRpb25zLnZpc2liaWxpdHkgfHwgXCJzeW5jXCIsXG4gICAgYXV0b0dlbmVyYXRlQXJyYXlLZXlzOiBvcHRpb25zLmF1dG9HZW5lcmF0ZUFycmF5S2V5cyxcbiAgICBza2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvbjogb3B0aW9ucy5za2lwQ3Jvc3NEYXRhc2V0UmVmZXJlbmNlVmFsaWRhdGlvblxuICB9O1xufTtcbmNvbnN0IGlzUmVzcG9uc2UgPSBldmVudCA9PiBldmVudC50eXBlID09PSBcInJlc3BvbnNlXCI7XG5jb25zdCBnZXRCb2R5ID0gZXZlbnQgPT4gZXZlbnQuYm9keTtcbmNvbnN0IGluZGV4QnkgPSAoZG9jcywgYXR0cikgPT4gZG9jcy5yZWR1Y2UoKGluZGV4ZWQsIGRvYykgPT4ge1xuICBpbmRleGVkW2F0dHIoZG9jKV0gPSBkb2M7XG4gIHJldHVybiBpbmRleGVkO1xufSwgLyogQF9fUFVSRV9fICovT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5jb25zdCBnZXRRdWVyeVNpemVMaW1pdCA9IDExMjY0O1xuZnVuY3Rpb24gX2ZldGNoKGNsaWVudCwgaHR0cFJlcXVlc3QsIHF1ZXJ5LCBwYXJhbXMpIHtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICBjb25zdCBtYXBSZXNwb25zZSA9IG9wdGlvbnMuZmlsdGVyUmVzcG9uc2UgPT09IGZhbHNlID8gcmVzID0+IHJlcyA6IHJlcyA9PiByZXMucmVzdWx0O1xuICBjb25zdCB7XG4gICAgY2FjaGUsXG4gICAgbmV4dCxcbiAgICAuLi5vcHRzXG4gIH0gPSB7XG4gICAgLy8gT3B0IG91dCBvZiBzZXR0aW5nIGEgYHNpZ25hbGAgb24gYW4gaW50ZXJuYWwgYGZldGNoYCBpZiBvbmUgaXNuJ3QgcHJvdmlkZWQuXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgaW4gUmVhY3QgU2VydmVyIENvbXBvbmVudHMgdG8gYXZvaWQgb3B0aW5nIG91dCBvZiBSZXF1ZXN0IE1lbW9pemF0aW9uLlxuICAgIHVzZUFib3J0U2lnbmFsOiB0eXBlb2Ygb3B0aW9ucy5zaWduYWwgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCByZXFPcHRzID0gdHlwZW9mIGNhY2hlICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBuZXh0ICE9PSBcInVuZGVmaW5lZFwiID8ge1xuICAgIC4uLm9wdHMsXG4gICAgZmV0Y2g6IHtcbiAgICAgIGNhY2hlLFxuICAgICAgbmV4dFxuICAgIH1cbiAgfSA6IG9wdHM7XG4gIHJldHVybiBfZGF0YVJlcXVlc3QoY2xpZW50LCBodHRwUmVxdWVzdCwgXCJxdWVyeVwiLCB7XG4gICAgcXVlcnksXG4gICAgcGFyYW1zXG4gIH0sIHJlcU9wdHMpLnBpcGUobWFwKG1hcFJlc3BvbnNlKSk7XG59XG5mdW5jdGlvbiBfZ2V0RG9jdW1lbnQoY2xpZW50LCBodHRwUmVxdWVzdCwgaWQpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHVyaTogX2dldERhdGFVcmwoY2xpZW50LCBcImRvY1wiLCBpZCksXG4gICAganNvbjogdHJ1ZSxcbiAgICB0YWc6IG9wdHMudGFnXG4gIH07XG4gIHJldHVybiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykucGlwZShmaWx0ZXIoaXNSZXNwb25zZSksIG1hcChldmVudCA9PiBldmVudC5ib2R5LmRvY3VtZW50cyAmJiBldmVudC5ib2R5LmRvY3VtZW50c1swXSkpO1xufVxuZnVuY3Rpb24gX2dldERvY3VtZW50cyhjbGllbnQsIGh0dHBSZXF1ZXN0LCBpZHMpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHVyaTogX2dldERhdGFVcmwoY2xpZW50LCBcImRvY1wiLCBpZHMuam9pbihcIixcIikpLFxuICAgIGpzb246IHRydWUsXG4gICAgdGFnOiBvcHRzLnRhZ1xuICB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpLnBpcGUoZmlsdGVyKGlzUmVzcG9uc2UpLCBtYXAoZXZlbnQgPT4ge1xuICAgIGNvbnN0IGluZGV4ZWQgPSBpbmRleEJ5KGV2ZW50LmJvZHkuZG9jdW1lbnRzIHx8IFtdLCBkb2MgPT4gZG9jLl9pZCk7XG4gICAgcmV0dXJuIGlkcy5tYXAoaWQgPT4gaW5kZXhlZFtpZF0gfHwgbnVsbCk7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVJZk5vdEV4aXN0cyhjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIG9wdGlvbnMpIHtcbiAgcmVxdWlyZURvY3VtZW50SWQoXCJjcmVhdGVJZk5vdEV4aXN0c1wiLCBkb2MpO1xuICByZXR1cm4gX2NyZWF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIFwiY3JlYXRlSWZOb3RFeGlzdHNcIiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBfY3JlYXRlT3JSZXBsYWNlKGNsaWVudCwgaHR0cFJlcXVlc3QsIGRvYywgb3B0aW9ucykge1xuICByZXF1aXJlRG9jdW1lbnRJZChcImNyZWF0ZU9yUmVwbGFjZVwiLCBkb2MpO1xuICByZXR1cm4gX2NyZWF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBkb2MsIFwiY3JlYXRlT3JSZXBsYWNlXCIsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gX2RlbGV0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBzZWxlY3Rpb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBcIm11dGF0ZVwiLCB7XG4gICAgbXV0YXRpb25zOiBbe1xuICAgICAgZGVsZXRlOiBnZXRTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgIH1dXG4gIH0sIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gX211dGF0ZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBtdXRhdGlvbnMsIG9wdGlvbnMpIHtcbiAgbGV0IG11dDtcbiAgaWYgKG11dGF0aW9ucyBpbnN0YW5jZW9mIFBhdGNoIHx8IG11dGF0aW9ucyBpbnN0YW5jZW9mIE9ic2VydmFibGVQYXRjaCkge1xuICAgIG11dCA9IHtcbiAgICAgIHBhdGNoOiBtdXRhdGlvbnMuc2VyaWFsaXplKClcbiAgICB9O1xuICB9IGVsc2UgaWYgKG11dGF0aW9ucyBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uIHx8IG11dGF0aW9ucyBpbnN0YW5jZW9mIE9ic2VydmFibGVUcmFuc2FjdGlvbikge1xuICAgIG11dCA9IG11dGF0aW9ucy5zZXJpYWxpemUoKTtcbiAgfSBlbHNlIHtcbiAgICBtdXQgPSBtdXRhdGlvbnM7XG4gIH1cbiAgY29uc3QgbXV0cyA9IEFycmF5LmlzQXJyYXkobXV0KSA/IG11dCA6IFttdXRdO1xuICBjb25zdCB0cmFuc2FjdGlvbklkID0gb3B0aW9ucyAmJiBvcHRpb25zLnRyYW5zYWN0aW9uSWQgfHwgdm9pZCAwO1xuICByZXR1cm4gX2RhdGFSZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIFwibXV0YXRlXCIsIHtcbiAgICBtdXRhdGlvbnM6IG11dHMsXG4gICAgdHJhbnNhY3Rpb25JZFxuICB9LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIF9kYXRhUmVxdWVzdChjbGllbnQsIGh0dHBSZXF1ZXN0LCBlbmRwb2ludCwgYm9keSkge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gIGNvbnN0IGlzTXV0YXRpb24gPSBlbmRwb2ludCA9PT0gXCJtdXRhdGVcIjtcbiAgY29uc3QgaXNRdWVyeSA9IGVuZHBvaW50ID09PSBcInF1ZXJ5XCI7XG4gIGNvbnN0IHN0clF1ZXJ5ID0gaXNNdXRhdGlvbiA/IFwiXCIgOiBlbmNvZGVRdWVyeVN0cmluZyhib2R5KTtcbiAgY29uc3QgdXNlR2V0ID0gIWlzTXV0YXRpb24gJiYgc3RyUXVlcnkubGVuZ3RoIDwgZ2V0UXVlcnlTaXplTGltaXQ7XG4gIGNvbnN0IHN0cmluZ1F1ZXJ5ID0gdXNlR2V0ID8gc3RyUXVlcnkgOiBcIlwiO1xuICBjb25zdCByZXR1cm5GaXJzdCA9IG9wdGlvbnMucmV0dXJuRmlyc3Q7XG4gIGNvbnN0IHtcbiAgICB0aW1lb3V0LFxuICAgIHRva2VuLFxuICAgIHRhZyxcbiAgICBoZWFkZXJzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB1cmkgPSBfZ2V0RGF0YVVybChjbGllbnQsIGVuZHBvaW50LCBzdHJpbmdRdWVyeSk7XG4gIGNvbnN0IHJlcU9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiB1c2VHZXQgPyBcIkdFVFwiIDogXCJQT1NUXCIsXG4gICAgdXJpLFxuICAgIGpzb246IHRydWUsXG4gICAgYm9keTogdXNlR2V0ID8gdm9pZCAwIDogYm9keSxcbiAgICBxdWVyeTogaXNNdXRhdGlvbiAmJiBnZXRNdXRhdGlvblF1ZXJ5KG9wdGlvbnMpLFxuICAgIHRpbWVvdXQsXG4gICAgaGVhZGVycyxcbiAgICB0b2tlbixcbiAgICB0YWcsXG4gICAgcGVyc3BlY3RpdmU6IG9wdGlvbnMucGVyc3BlY3RpdmUsXG4gICAgcmVzdWx0U291cmNlTWFwOiBvcHRpb25zLnJlc3VsdFNvdXJjZU1hcCxcbiAgICBjYW5Vc2VDZG46IGlzUXVlcnksXG4gICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICB1c2VBYm9ydFNpZ25hbDogb3B0aW9ucy51c2VBYm9ydFNpZ25hbFxuICB9O1xuICByZXR1cm4gX3JlcXVlc3RPYnNlcnZhYmxlKGNsaWVudCwgaHR0cFJlcXVlc3QsIHJlcU9wdGlvbnMpLnBpcGUoZmlsdGVyKGlzUmVzcG9uc2UpLCBtYXAoZ2V0Qm9keSksIG1hcChyZXMgPT4ge1xuICAgIGlmICghaXNNdXRhdGlvbikge1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IHJlcy5yZXN1bHRzIHx8IFtdO1xuICAgIGlmIChvcHRpb25zLnJldHVybkRvY3VtZW50cykge1xuICAgICAgcmV0dXJuIHJldHVybkZpcnN0ID8gcmVzdWx0c1swXSAmJiByZXN1bHRzWzBdLmRvY3VtZW50IDogcmVzdWx0cy5tYXAobXV0ID0+IG11dC5kb2N1bWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHJldHVybkZpcnN0ID8gXCJkb2N1bWVudElkXCIgOiBcImRvY3VtZW50SWRzXCI7XG4gICAgY29uc3QgaWRzID0gcmV0dXJuRmlyc3QgPyByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uaWQgOiByZXN1bHRzLm1hcChtdXQgPT4gbXV0LmlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25JZDogcmVzLnRyYW5zYWN0aW9uSWQsXG4gICAgICByZXN1bHRzLFxuICAgICAgW2tleV06IGlkc1xuICAgIH07XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGUoY2xpZW50LCBodHRwUmVxdWVzdCwgZG9jLCBvcCkge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gIGNvbnN0IG11dGF0aW9uID0ge1xuICAgIFtvcF06IGRvY1xuICB9O1xuICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcmV0dXJuRmlyc3Q6IHRydWUsXG4gICAgcmV0dXJuRG9jdW1lbnRzOiB0cnVlXG4gIH0sIG9wdGlvbnMpO1xuICByZXR1cm4gX2RhdGFSZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIFwibXV0YXRlXCIsIHtcbiAgICBtdXRhdGlvbnM6IFttdXRhdGlvbl1cbiAgfSwgb3B0cyk7XG59XG5mdW5jdGlvbiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwgb3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHVyaSA9IG9wdGlvbnMudXJsIHx8IG9wdGlvbnMudXJpO1xuICBjb25zdCBjb25maWcgPSBjbGllbnQuY29uZmlnKCk7XG4gIGNvbnN0IGNhblVzZUNkbiA9IHR5cGVvZiBvcHRpb25zLmNhblVzZUNkbiA9PT0gXCJ1bmRlZmluZWRcIiA/IFtcIkdFVFwiLCBcIkhFQURcIl0uaW5kZXhPZihvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKSA+PSAwICYmIHVyaS5pbmRleE9mKFwiL2RhdGEvXCIpID09PSAwIDogb3B0aW9ucy5jYW5Vc2VDZG47XG4gIGxldCB1c2VDZG4gPSBjb25maWcudXNlQ2RuICYmIGNhblVzZUNkbjtcbiAgY29uc3QgdGFnID0gb3B0aW9ucy50YWcgJiYgY29uZmlnLnJlcXVlc3RUYWdQcmVmaXggPyBbY29uZmlnLnJlcXVlc3RUYWdQcmVmaXgsIG9wdGlvbnMudGFnXS5qb2luKFwiLlwiKSA6IG9wdGlvbnMudGFnIHx8IGNvbmZpZy5yZXF1ZXN0VGFnUHJlZml4O1xuICBpZiAodGFnICYmIG9wdGlvbnMudGFnICE9PSBudWxsKSB7XG4gICAgb3B0aW9ucy5xdWVyeSA9IHtcbiAgICAgIHRhZzogcmVxdWVzdFRhZyh0YWcpLFxuICAgICAgLi4ub3B0aW9ucy5xdWVyeVxuICAgIH07XG4gIH1cbiAgaWYgKFtcIkdFVFwiLCBcIkhFQURcIiwgXCJQT1NUXCJdLmluZGV4T2Yob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIikgPj0gMCAmJiB1cmkuaW5kZXhPZihcIi9kYXRhL3F1ZXJ5L1wiKSA9PT0gMCkge1xuICAgIGNvbnN0IHJlc3VsdFNvdXJjZU1hcCA9IChfYSA9IG9wdGlvbnMucmVzdWx0U291cmNlTWFwKSAhPSBudWxsID8gX2EgOiBjb25maWcucmVzdWx0U291cmNlTWFwO1xuICAgIGlmIChyZXN1bHRTb3VyY2VNYXAgIT09IHZvaWQgMCAmJiByZXN1bHRTb3VyY2VNYXAgIT09IGZhbHNlKSB7XG4gICAgICBvcHRpb25zLnF1ZXJ5ID0ge1xuICAgICAgICByZXN1bHRTb3VyY2VNYXAsXG4gICAgICAgIC4uLm9wdGlvbnMucXVlcnlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBlcnNwZWN0aXZlID0gb3B0aW9ucy5wZXJzcGVjdGl2ZSB8fCBjb25maWcucGVyc3BlY3RpdmU7XG4gICAgaWYgKHR5cGVvZiBwZXJzcGVjdGl2ZSA9PT0gXCJzdHJpbmdcIiAmJiBwZXJzcGVjdGl2ZSAhPT0gXCJyYXdcIikge1xuICAgICAgdmFsaWRhdGVBcGlQZXJzcGVjdGl2ZShwZXJzcGVjdGl2ZSk7XG4gICAgICBvcHRpb25zLnF1ZXJ5ID0ge1xuICAgICAgICBwZXJzcGVjdGl2ZSxcbiAgICAgICAgLi4ub3B0aW9ucy5xdWVyeVxuICAgICAgfTtcbiAgICAgIGlmIChwZXJzcGVjdGl2ZSA9PT0gXCJwcmV2aWV3RHJhZnRzXCIgJiYgdXNlQ2RuKSB7XG4gICAgICAgIHVzZUNkbiA9IGZhbHNlO1xuICAgICAgICBwcmludENkblByZXZpZXdEcmFmdHNXYXJuaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlcU9wdGlvbnMgPSByZXF1ZXN0T3B0aW9ucyhjb25maWcsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICB1cmw6IF9nZXRVcmwoY2xpZW50LCB1cmksIHVzZUNkbilcbiAgfSkpO1xuICBjb25zdCByZXF1ZXN0ID0gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlciA9PiBodHRwUmVxdWVzdChyZXFPcHRpb25zLCBjb25maWcucmVxdWVzdGVyKS5zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xuICByZXR1cm4gb3B0aW9ucy5zaWduYWwgPyByZXF1ZXN0LnBpcGUoX3dpdGhBYm9ydFNpZ25hbChvcHRpb25zLnNpZ25hbCkpIDogcmVxdWVzdDtcbn1cbmZ1bmN0aW9uIF9yZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb2JzZXJ2YWJsZSA9IF9yZXF1ZXN0T2JzZXJ2YWJsZShjbGllbnQsIGh0dHBSZXF1ZXN0LCBvcHRpb25zKS5waXBlKGZpbHRlcihldmVudCA9PiBldmVudC50eXBlID09PSBcInJlc3BvbnNlXCIpLCBtYXAoZXZlbnQgPT4gZXZlbnQuYm9keSkpO1xuICByZXR1cm4gb2JzZXJ2YWJsZTtcbn1cbmZ1bmN0aW9uIF9nZXREYXRhVXJsKGNsaWVudCwgb3BlcmF0aW9uLCBwYXRoKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGNsaWVudC5jb25maWcoKTtcbiAgY29uc3QgY2F0YWxvZyA9IGhhc0RhdGFzZXQoY29uZmlnKTtcbiAgY29uc3QgYmFzZVVyaSA9IFwiL1wiLmNvbmNhdChvcGVyYXRpb24sIFwiL1wiKS5jb25jYXQoY2F0YWxvZyk7XG4gIGNvbnN0IHVyaSA9IHBhdGggPyBcIlwiLmNvbmNhdChiYXNlVXJpLCBcIi9cIikuY29uY2F0KHBhdGgpIDogYmFzZVVyaTtcbiAgcmV0dXJuIFwiL2RhdGFcIi5jb25jYXQodXJpKS5yZXBsYWNlKC9cXC8oJHxcXD8pLywgXCIkMVwiKTtcbn1cbmZ1bmN0aW9uIF9nZXRVcmwoY2xpZW50LCB1cmkpIHtcbiAgbGV0IGNhblVzZUNkbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIGNvbnN0IHtcbiAgICB1cmwsXG4gICAgY2RuVXJsXG4gIH0gPSBjbGllbnQuY29uZmlnKCk7XG4gIGNvbnN0IGJhc2UgPSBjYW5Vc2VDZG4gPyBjZG5VcmwgOiB1cmw7XG4gIHJldHVybiBcIlwiLmNvbmNhdChiYXNlLCBcIi9cIikuY29uY2F0KHVyaS5yZXBsYWNlKC9eXFwvLywgXCJcIikpO1xufVxuZnVuY3Rpb24gX3dpdGhBYm9ydFNpZ25hbChzaWduYWwpIHtcbiAgcmV0dXJuIGlucHV0ID0+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgY29uc3QgYWJvcnQgPSAoKSA9PiBvYnNlcnZlci5lcnJvcihfY3JlYXRlQWJvcnRFcnJvcihzaWduYWwpKTtcbiAgICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gaW5wdXQuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydCk7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbn1cbmNvbnN0IGlzRG9tRXhjZXB0aW9uU3VwcG9ydGVkID0gQm9vbGVhbihnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbik7XG5mdW5jdGlvbiBfY3JlYXRlQWJvcnRFcnJvcihzaWduYWwpIHtcbiAgdmFyIF9hLCBfYjtcbiAgaWYgKGlzRG9tRXhjZXB0aW9uU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIG5ldyBET01FeGNlcHRpb24oKF9hID0gc2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBzaWduYWwucmVhc29uKSAhPSBudWxsID8gX2EgOiBcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIsIFwiQWJvcnRFcnJvclwiKTtcbiAgfVxuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigoX2IgPSBzaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IHNpZ25hbC5yZWFzb24pICE9IG51bGwgPyBfYiA6IFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIik7XG4gIGVycm9yLm5hbWUgPSBcIkFib3J0RXJyb3JcIjtcbiAgcmV0dXJuIGVycm9yO1xufVxudmFyIF9fYWNjZXNzQ2hlY2skNCA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQkNCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2skNChvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCQ0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0JDQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayQ0KG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfY2xpZW50JDMsIF9odHRwUmVxdWVzdCQ0LCBfY2xpZW50MiQzLCBfaHR0cFJlcXVlc3QyJDQ7XG5jbGFzcyBPYnNlcnZhYmxlQXNzZXRzQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIF9fcHJpdmF0ZUFkZCQ0KHRoaXMsIF9jbGllbnQkMywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQkNCh0aGlzLCBfaHR0cFJlcXVlc3QkNCwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVTZXQkNCh0aGlzLCBfY2xpZW50JDMsIGNsaWVudCk7XG4gICAgX19wcml2YXRlU2V0JDQodGhpcywgX2h0dHBSZXF1ZXN0JDQsIGh0dHBSZXF1ZXN0KTtcbiAgfVxuICB1cGxvYWQoYXNzZXRUeXBlLCBib2R5LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF91cGxvYWQoX19wcml2YXRlR2V0JDQodGhpcywgX2NsaWVudCQzKSwgX19wcml2YXRlR2V0JDQodGhpcywgX2h0dHBSZXF1ZXN0JDQpLCBhc3NldFR5cGUsIGJvZHksIG9wdGlvbnMpO1xuICB9XG59XG5fY2xpZW50JDMgPSBuZXcgV2Vha01hcCgpO1xuX2h0dHBSZXF1ZXN0JDQgPSBuZXcgV2Vha01hcCgpO1xuY2xhc3MgQXNzZXRzQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIF9fcHJpdmF0ZUFkZCQ0KHRoaXMsIF9jbGllbnQyJDMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkJDQodGhpcywgX2h0dHBSZXF1ZXN0MiQ0LCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZVNldCQ0KHRoaXMsIF9jbGllbnQyJDMsIGNsaWVudCk7XG4gICAgX19wcml2YXRlU2V0JDQodGhpcywgX2h0dHBSZXF1ZXN0MiQ0LCBodHRwUmVxdWVzdCk7XG4gIH1cbiAgdXBsb2FkKGFzc2V0VHlwZSwgYm9keSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9ic2VydmFibGUgPSBfdXBsb2FkKF9fcHJpdmF0ZUdldCQ0KHRoaXMsIF9jbGllbnQyJDMpLCBfX3ByaXZhdGVHZXQkNCh0aGlzLCBfaHR0cFJlcXVlc3QyJDQpLCBhc3NldFR5cGUsIGJvZHksIG9wdGlvbnMpO1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKG9ic2VydmFibGUucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQudHlwZSA9PT0gXCJyZXNwb25zZVwiKSwgbWFwKGV2ZW50ID0+IGV2ZW50LmJvZHkuZG9jdW1lbnQpKSk7XG4gIH1cbn1cbl9jbGllbnQyJDMgPSBuZXcgV2Vha01hcCgpO1xuX2h0dHBSZXF1ZXN0MiQ0ID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIF91cGxvYWQoY2xpZW50LCBodHRwUmVxdWVzdCwgYXNzZXRUeXBlLCBib2R5KSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcbiAgdmFsaWRhdGVBc3NldFR5cGUoYXNzZXRUeXBlKTtcbiAgbGV0IG1ldGEgPSBvcHRzLmV4dHJhY3QgfHwgdm9pZCAwO1xuICBpZiAobWV0YSAmJiAhbWV0YS5sZW5ndGgpIHtcbiAgICBtZXRhID0gW1wibm9uZVwiXTtcbiAgfVxuICBjb25zdCBkYXRhc2V0ID0gaGFzRGF0YXNldChjbGllbnQuY29uZmlnKCkpO1xuICBjb25zdCBhc3NldEVuZHBvaW50ID0gYXNzZXRUeXBlID09PSBcImltYWdlXCIgPyBcImltYWdlc1wiIDogXCJmaWxlc1wiO1xuICBjb25zdCBvcHRpb25zID0gb3B0aW9uc0Zyb21GaWxlKG9wdHMsIGJvZHkpO1xuICBjb25zdCB7XG4gICAgdGFnLFxuICAgIGxhYmVsLFxuICAgIHRpdGxlLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIGNyZWRpdExpbmUsXG4gICAgZmlsZW5hbWUsXG4gICAgc291cmNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBxdWVyeSA9IHtcbiAgICBsYWJlbCxcbiAgICB0aXRsZSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBmaWxlbmFtZSxcbiAgICBtZXRhLFxuICAgIGNyZWRpdExpbmVcbiAgfTtcbiAgaWYgKHNvdXJjZSkge1xuICAgIHF1ZXJ5LnNvdXJjZUlkID0gc291cmNlLmlkO1xuICAgIHF1ZXJ5LnNvdXJjZU5hbWUgPSBzb3VyY2UubmFtZTtcbiAgICBxdWVyeS5zb3VyY2VVcmwgPSBzb3VyY2UudXJsO1xuICB9XG4gIHJldHVybiBfcmVxdWVzdE9ic2VydmFibGUoY2xpZW50LCBodHRwUmVxdWVzdCwge1xuICAgIHRhZyxcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCB8fCAwLFxuICAgIHVyaTogXCIvYXNzZXRzL1wiLmNvbmNhdChhc3NldEVuZHBvaW50LCBcIi9cIikuY29uY2F0KGRhdGFzZXQpLFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuY29udGVudFR5cGUgPyB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBvcHRpb25zLmNvbnRlbnRUeXBlXG4gICAgfSA6IHt9LFxuICAgIHF1ZXJ5LFxuICAgIGJvZHlcbiAgfSk7XG59XG5mdW5jdGlvbiBvcHRpb25zRnJvbUZpbGUob3B0cywgZmlsZSkge1xuICBpZiAodHlwZW9mIEZpbGUgPT09IFwidW5kZWZpbmVkXCIgfHwgIShmaWxlIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICByZXR1cm4gb3B0cztcbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgZmlsZW5hbWU6IG9wdHMucHJlc2VydmVGaWxlbmFtZSA9PT0gZmFsc2UgPyB2b2lkIDAgOiBmaWxlLm5hbWUsXG4gICAgY29udGVudFR5cGU6IGZpbGUudHlwZVxuICB9LCBvcHRzKTtcbn1cbnZhciBkZWZhdWx0cyA9IChvYmosIGRlZmF1bHRzKSA9PiBPYmplY3Qua2V5cyhkZWZhdWx0cykuY29uY2F0KE9iamVjdC5rZXlzKG9iaikpLnJlZHVjZSgodGFyZ2V0LCBwcm9wKSA9PiB7XG4gIHRhcmdldFtwcm9wXSA9IHR5cGVvZiBvYmpbcHJvcF0gPT09IFwidW5kZWZpbmVkXCIgPyBkZWZhdWx0c1twcm9wXSA6IG9ialtwcm9wXTtcbiAgcmV0dXJuIHRhcmdldDtcbn0sIHt9KTtcbmNvbnN0IHBpY2sgPSAob2JqLCBwcm9wcykgPT4gcHJvcHMucmVkdWNlKChzZWxlY3Rpb24sIHByb3ApID0+IHtcbiAgaWYgKHR5cGVvZiBvYmpbcHJvcF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG4gIHNlbGVjdGlvbltwcm9wXSA9IG9ialtwcm9wXTtcbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn0sIHt9KTtcbmNvbnN0IE1BWF9VUkxfTEVOR1RIID0gMTZlMyAtIDEyMDA7XG5jb25zdCBwb3NzaWJsZU9wdGlvbnMgPSBbXCJpbmNsdWRlUHJldmlvdXNSZXZpc2lvblwiLCBcImluY2x1ZGVSZXN1bHRcIiwgXCJ2aXNpYmlsaXR5XCIsIFwiZWZmZWN0Rm9ybWF0XCIsIFwidGFnXCJdO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGluY2x1ZGVSZXN1bHQ6IHRydWVcbn07XG5mdW5jdGlvbiBfbGlzdGVuKHF1ZXJ5LCBwYXJhbXMpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICBjb25zdCB7XG4gICAgdXJsLFxuICAgIHRva2VuLFxuICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICByZXF1ZXN0VGFnUHJlZml4XG4gIH0gPSB0aGlzLmNvbmZpZygpO1xuICBjb25zdCB0YWcgPSBvcHRzLnRhZyAmJiByZXF1ZXN0VGFnUHJlZml4ID8gW3JlcXVlc3RUYWdQcmVmaXgsIG9wdHMudGFnXS5qb2luKFwiLlwiKSA6IG9wdHMudGFnO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRzKG9wdHMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICB0YWdcbiAgfTtcbiAgY29uc3QgbGlzdGVuT3B0cyA9IHBpY2sob3B0aW9ucywgcG9zc2libGVPcHRpb25zKTtcbiAgY29uc3QgcXMgPSBlbmNvZGVRdWVyeVN0cmluZyh7XG4gICAgcXVlcnksXG4gICAgcGFyYW1zLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHRhZyxcbiAgICAgIC4uLmxpc3Rlbk9wdHNcbiAgICB9XG4gIH0pO1xuICBjb25zdCB1cmkgPSBcIlwiLmNvbmNhdCh1cmwpLmNvbmNhdChfZ2V0RGF0YVVybCh0aGlzLCBcImxpc3RlblwiLCBxcykpO1xuICBpZiAodXJpLmxlbmd0aCA+IE1BWF9VUkxfTEVOR1RIKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKG9ic2VydmVyID0+IG9ic2VydmVyLmVycm9yKG5ldyBFcnJvcihcIlF1ZXJ5IHRvbyBsYXJnZSBmb3IgbGlzdGVuZXJcIikpKTtcbiAgfVxuICBjb25zdCBsaXN0ZW5Gb3IgPSBvcHRpb25zLmV2ZW50cyA/IG9wdGlvbnMuZXZlbnRzIDogW1wibXV0YXRpb25cIl07XG4gIGNvbnN0IHNob3VsZEVtaXRSZWNvbm5lY3QgPSBsaXN0ZW5Gb3IuaW5kZXhPZihcInJlY29ubmVjdFwiKSAhPT0gLTE7XG4gIGNvbnN0IGVzT3B0aW9ucyA9IHt9O1xuICBpZiAodG9rZW4gfHwgd2l0aENyZWRlbnRpYWxzKSB7XG4gICAgZXNPcHRpb25zLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIH1cbiAgaWYgKHRva2VuKSB7XG4gICAgZXNPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICBBdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIi5jb25jYXQodG9rZW4pXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgIGxldCBlcztcbiAgICBnZXRFdmVudFNvdXJjZSgpLnRoZW4oZXZlbnRTb3VyY2UgPT4ge1xuICAgICAgZXMgPSBldmVudFNvdXJjZTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVhc29uKTtcbiAgICAgIHN0b3AoKTtcbiAgICB9KTtcbiAgICBsZXQgcmVjb25uZWN0VGltZXI7XG4gICAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBvbkVycm9yKCkge1xuICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZW1pdFJlY29ubmVjdCgpO1xuICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVzLnJlYWR5U3RhdGUgPT09IGVzLkNMT1NFRCkge1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICBjbGVhclRpbWVvdXQocmVjb25uZWN0VGltZXIpO1xuICAgICAgICByZWNvbm5lY3RUaW1lciA9IHNldFRpbWVvdXQob3BlbiwgMTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25DaGFubmVsRXJyb3IoZXJyKSB7XG4gICAgICBvYnNlcnZlci5lcnJvcihjb29lcmNlRXJyb3IoZXJyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTWVzc2FnZShldnQpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gcGFyc2VFdmVudChldnQpO1xuICAgICAgcmV0dXJuIGV2ZW50IGluc3RhbmNlb2YgRXJyb3IgPyBvYnNlcnZlci5lcnJvcihldmVudCkgOiBvYnNlcnZlci5uZXh0KGV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25EaXNjb25uZWN0KCkge1xuICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICBpZiAoIWVzKSByZXR1cm47XG4gICAgICBlcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICBlcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbm5lbEVycm9yXCIsIG9uQ2hhbm5lbEVycm9yKTtcbiAgICAgIGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkaXNjb25uZWN0XCIsIG9uRGlzY29ubmVjdCk7XG4gICAgICBsaXN0ZW5Gb3IuZm9yRWFjaCh0eXBlID0+IGVzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgb25NZXNzYWdlKSk7XG4gICAgICBlcy5jbG9zZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbWl0UmVjb25uZWN0KCkge1xuICAgICAgaWYgKHNob3VsZEVtaXRSZWNvbm5lY3QpIHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgICAgdHlwZTogXCJyZWNvbm5lY3RcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2UoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRlZmF1bHQ6IEV2ZW50U291cmNlXG4gICAgICB9ID0gYXdhaXQgaW1wb3J0KCdAc2FuaXR5L2V2ZW50c291cmNlJyk7XG4gICAgICBjb25zdCBldnMgPSBuZXcgRXZlbnRTb3VyY2UodXJpLCBlc09wdGlvbnMpO1xuICAgICAgZXZzLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgIGV2cy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbm5lbEVycm9yXCIsIG9uQ2hhbm5lbEVycm9yKTtcbiAgICAgIGV2cy5hZGRFdmVudExpc3RlbmVyKFwiZGlzY29ubmVjdFwiLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgbGlzdGVuRm9yLmZvckVhY2godHlwZSA9PiBldnMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBvbk1lc3NhZ2UpKTtcbiAgICAgIHJldHVybiBldnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICBnZXRFdmVudFNvdXJjZSgpLnRoZW4oZXZlbnRTb3VyY2UgPT4ge1xuICAgICAgICBlcyA9IGV2ZW50U291cmNlO1xuICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IocmVhc29uKTtcbiAgICAgICAgc3RvcCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdG9wO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXZlbnQoZXZlbnQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YSAmJiBKU09OLnBhcnNlKGV2ZW50LmRhdGEpIHx8IHt9O1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6IGV2ZW50LnR5cGVcbiAgICB9LCBkYXRhKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGVycjtcbiAgfVxufVxuZnVuY3Rpb24gY29vZXJjZUVycm9yKGVycikge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG4gIGNvbnN0IGV2dCA9IHBhcnNlRXZlbnQoZXJyKTtcbiAgcmV0dXJuIGV2dCBpbnN0YW5jZW9mIEVycm9yID8gZXZ0IDogbmV3IEVycm9yKGV4dHJhY3RFcnJvck1lc3NhZ2UoZXZ0KSk7XG59XG5mdW5jdGlvbiBleHRyYWN0RXJyb3JNZXNzYWdlKGVycikge1xuICBpZiAoIWVyci5lcnJvcikge1xuICAgIHJldHVybiBlcnIubWVzc2FnZSB8fCBcIlVua25vd24gbGlzdGVuZXIgZXJyb3JcIjtcbiAgfVxuICBpZiAoZXJyLmVycm9yLmRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGVyci5lcnJvci5kZXNjcmlwdGlvbjtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGVyci5lcnJvciA9PT0gXCJzdHJpbmdcIiA/IGVyci5lcnJvciA6IEpTT04uc3RyaW5naWZ5KGVyci5lcnJvciwgbnVsbCwgMik7XG59XG52YXIgX19hY2Nlc3NDaGVjayQzID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCQzID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayQzKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkJDMgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQkMyA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrJDMob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9jbGllbnQkMiwgX2h0dHBSZXF1ZXN0JDMsIF9jbGllbnQyJDIsIF9odHRwUmVxdWVzdDIkMztcbmNsYXNzIE9ic2VydmFibGVEYXRhc2V0c0NsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICBfX3ByaXZhdGVBZGQkMyh0aGlzLCBfY2xpZW50JDIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkJDModGhpcywgX2h0dHBSZXF1ZXN0JDMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0JDModGhpcywgX2NsaWVudCQyLCBjbGllbnQpO1xuICAgIF9fcHJpdmF0ZVNldCQzKHRoaXMsIF9odHRwUmVxdWVzdCQzLCBodHRwUmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGNyZWF0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBkYXRhc2V0XG4gICAqL1xuICBjcmVhdGUobmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfbW9kaWZ5KF9fcHJpdmF0ZUdldCQzKHRoaXMsIF9jbGllbnQkMiksIF9fcHJpdmF0ZUdldCQzKHRoaXMsIF9odHRwUmVxdWVzdCQzKSwgXCJQVVRcIiwgbmFtZSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEVkaXQgYSBkYXRhc2V0IHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSBkYXRhc2V0IHRvIGVkaXRcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBOZXcgb3B0aW9ucyBmb3IgdGhlIGRhdGFzZXRcbiAgICovXG4gIGVkaXQobmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfbW9kaWZ5KF9fcHJpdmF0ZUdldCQzKHRoaXMsIF9jbGllbnQkMiksIF9fcHJpdmF0ZUdldCQzKHRoaXMsIF9odHRwUmVxdWVzdCQzKSwgXCJQQVRDSFwiLCBuYW1lLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIF9tb2RpZnkoX19wcml2YXRlR2V0JDModGhpcywgX2NsaWVudCQyKSwgX19wcml2YXRlR2V0JDModGhpcywgX2h0dHBSZXF1ZXN0JDMpLCBcIkRFTEVURVwiLCBuYW1lKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIGRhdGFzZXRzIGZvciB0aGUgY29uZmlndXJlZCBwcm9qZWN0XG4gICAqL1xuICBsaXN0KCkge1xuICAgIHJldHVybiBfcmVxdWVzdChfX3ByaXZhdGVHZXQkMyh0aGlzLCBfY2xpZW50JDIpLCBfX3ByaXZhdGVHZXQkMyh0aGlzLCBfaHR0cFJlcXVlc3QkMyksIHtcbiAgICAgIHVyaTogXCIvZGF0YXNldHNcIixcbiAgICAgIHRhZzogbnVsbFxuICAgIH0pO1xuICB9XG59XG5fY2xpZW50JDIgPSBuZXcgV2Vha01hcCgpO1xuX2h0dHBSZXF1ZXN0JDMgPSBuZXcgV2Vha01hcCgpO1xuY2xhc3MgRGF0YXNldHNDbGllbnQge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgX19wcml2YXRlQWRkJDModGhpcywgX2NsaWVudDIkMiwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQkMyh0aGlzLCBfaHR0cFJlcXVlc3QyJDMsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0JDModGhpcywgX2NsaWVudDIkMiwgY2xpZW50KTtcbiAgICBfX3ByaXZhdGVTZXQkMyh0aGlzLCBfaHR0cFJlcXVlc3QyJDMsIGh0dHBSZXF1ZXN0KTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGRhdGFzZXQgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGRhdGFzZXRcbiAgICovXG4gIGNyZWF0ZShuYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX21vZGlmeShfX3ByaXZhdGVHZXQkMyh0aGlzLCBfY2xpZW50MiQyKSwgX19wcml2YXRlR2V0JDModGhpcywgX2h0dHBSZXF1ZXN0MiQzKSwgXCJQVVRcIiwgbmFtZSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBFZGl0IGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBlZGl0XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gTmV3IG9wdGlvbnMgZm9yIHRoZSBkYXRhc2V0XG4gICAqL1xuICBlZGl0KG5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfbW9kaWZ5KF9fcHJpdmF0ZUdldCQzKHRoaXMsIF9jbGllbnQyJDIpLCBfX3ByaXZhdGVHZXQkMyh0aGlzLCBfaHR0cFJlcXVlc3QyJDMpLCBcIlBBVENIXCIsIG5hbWUsIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIC0gTmFtZSBvZiB0aGUgZGF0YXNldCB0byBkZWxldGVcbiAgICovXG4gIGRlbGV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX21vZGlmeShfX3ByaXZhdGVHZXQkMyh0aGlzLCBfY2xpZW50MiQyKSwgX19wcml2YXRlR2V0JDModGhpcywgX2h0dHBSZXF1ZXN0MiQzKSwgXCJERUxFVEVcIiwgbmFtZSkpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgZGF0YXNldHMgZm9yIHRoZSBjb25maWd1cmVkIHByb2plY3RcbiAgICovXG4gIGxpc3QoKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX3JlcXVlc3QoX19wcml2YXRlR2V0JDModGhpcywgX2NsaWVudDIkMiksIF9fcHJpdmF0ZUdldCQzKHRoaXMsIF9odHRwUmVxdWVzdDIkMyksIHtcbiAgICAgIHVyaTogXCIvZGF0YXNldHNcIixcbiAgICAgIHRhZzogbnVsbFxuICAgIH0pKTtcbiAgfVxufVxuX2NsaWVudDIkMiA9IG5ldyBXZWFrTWFwKCk7XG5faHR0cFJlcXVlc3QyJDMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gX21vZGlmeShjbGllbnQsIGh0dHBSZXF1ZXN0LCBtZXRob2QsIG5hbWUsIG9wdGlvbnMpIHtcbiAgZGF0YXNldChuYW1lKTtcbiAgcmV0dXJuIF9yZXF1ZXN0KGNsaWVudCwgaHR0cFJlcXVlc3QsIHtcbiAgICBtZXRob2QsXG4gICAgdXJpOiBcIi9kYXRhc2V0cy9cIi5jb25jYXQobmFtZSksXG4gICAgYm9keTogb3B0aW9ucyxcbiAgICB0YWc6IG51bGxcbiAgfSk7XG59XG52YXIgX19hY2Nlc3NDaGVjayQyID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCQyID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayQyKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkJDIgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQkMiA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrJDIob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9jbGllbnQkMSwgX2h0dHBSZXF1ZXN0JDIsIF9jbGllbnQyJDEsIF9odHRwUmVxdWVzdDIkMjtcbmNsYXNzIE9ic2VydmFibGVQcm9qZWN0c0NsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICBfX3ByaXZhdGVBZGQkMih0aGlzLCBfY2xpZW50JDEsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkJDIodGhpcywgX2h0dHBSZXF1ZXN0JDIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0JDIodGhpcywgX2NsaWVudCQxLCBjbGllbnQpO1xuICAgIF9fcHJpdmF0ZVNldCQyKHRoaXMsIF9odHRwUmVxdWVzdCQyLCBodHRwUmVxdWVzdCk7XG4gIH1cbiAgbGlzdChvcHRpb25zKSB7XG4gICAgY29uc3QgdXJpID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaW5jbHVkZU1lbWJlcnMpID09PSBmYWxzZSA/IFwiL3Byb2plY3RzP2luY2x1ZGVNZW1iZXJzPWZhbHNlXCIgOiBcIi9wcm9qZWN0c1wiO1xuICAgIHJldHVybiBfcmVxdWVzdChfX3ByaXZhdGVHZXQkMih0aGlzLCBfY2xpZW50JDEpLCBfX3ByaXZhdGVHZXQkMih0aGlzLCBfaHR0cFJlcXVlc3QkMiksIHtcbiAgICAgIHVyaVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHByb2plY3QgYnkgcHJvamVjdCBJRFxuICAgKlxuICAgKiBAcGFyYW0gcHJvamVjdElkIC0gSUQgb2YgdGhlIHByb2plY3QgdG8gZmV0Y2hcbiAgICovXG4gIGdldEJ5SWQocHJvamVjdElkKSB7XG4gICAgcmV0dXJuIF9yZXF1ZXN0KF9fcHJpdmF0ZUdldCQyKHRoaXMsIF9jbGllbnQkMSksIF9fcHJpdmF0ZUdldCQyKHRoaXMsIF9odHRwUmVxdWVzdCQyKSwge1xuICAgICAgdXJpOiBcIi9wcm9qZWN0cy9cIi5jb25jYXQocHJvamVjdElkKVxuICAgIH0pO1xuICB9XG59XG5fY2xpZW50JDEgPSBuZXcgV2Vha01hcCgpO1xuX2h0dHBSZXF1ZXN0JDIgPSBuZXcgV2Vha01hcCgpO1xuY2xhc3MgUHJvamVjdHNDbGllbnQge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIGh0dHBSZXF1ZXN0KSB7XG4gICAgX19wcml2YXRlQWRkJDIodGhpcywgX2NsaWVudDIkMSwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQkMih0aGlzLCBfaHR0cFJlcXVlc3QyJDIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0JDIodGhpcywgX2NsaWVudDIkMSwgY2xpZW50KTtcbiAgICBfX3ByaXZhdGVTZXQkMih0aGlzLCBfaHR0cFJlcXVlc3QyJDIsIGh0dHBSZXF1ZXN0KTtcbiAgfVxuICBsaXN0KG9wdGlvbnMpIHtcbiAgICBjb25zdCB1cmkgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pbmNsdWRlTWVtYmVycykgPT09IGZhbHNlID8gXCIvcHJvamVjdHM/aW5jbHVkZU1lbWJlcnM9ZmFsc2VcIiA6IFwiL3Byb2plY3RzXCI7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX3JlcXVlc3QoX19wcml2YXRlR2V0JDIodGhpcywgX2NsaWVudDIkMSksIF9fcHJpdmF0ZUdldCQyKHRoaXMsIF9odHRwUmVxdWVzdDIkMiksIHtcbiAgICAgIHVyaVxuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9qZWN0IGJ5IHByb2plY3QgSURcbiAgICpcbiAgICogQHBhcmFtIHByb2plY3RJZCAtIElEIG9mIHRoZSBwcm9qZWN0IHRvIGZldGNoXG4gICAqL1xuICBnZXRCeUlkKHByb2plY3RJZCkge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9yZXF1ZXN0KF9fcHJpdmF0ZUdldCQyKHRoaXMsIF9jbGllbnQyJDEpLCBfX3ByaXZhdGVHZXQkMih0aGlzLCBfaHR0cFJlcXVlc3QyJDIpLCB7XG4gICAgICB1cmk6IFwiL3Byb2plY3RzL1wiLmNvbmNhdChwcm9qZWN0SWQpXG4gICAgfSkpO1xuICB9XG59XG5fY2xpZW50MiQxID0gbmV3IFdlYWtNYXAoKTtcbl9odHRwUmVxdWVzdDIkMiA9IG5ldyBXZWFrTWFwKCk7XG52YXIgX19hY2Nlc3NDaGVjayQxID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCQxID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayQxKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkJDEgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQkMSA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrJDEob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9jbGllbnQsIF9odHRwUmVxdWVzdCQxLCBfY2xpZW50MiwgX2h0dHBSZXF1ZXN0MiQxO1xuY2xhc3MgT2JzZXJ2YWJsZVVzZXJzQ2xpZW50IHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCBodHRwUmVxdWVzdCkge1xuICAgIF9fcHJpdmF0ZUFkZCQxKHRoaXMsIF9jbGllbnQsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkJDEodGhpcywgX2h0dHBSZXF1ZXN0JDEsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0JDEodGhpcywgX2NsaWVudCwgY2xpZW50KTtcbiAgICBfX3ByaXZhdGVTZXQkMSh0aGlzLCBfaHR0cFJlcXVlc3QkMSwgaHR0cFJlcXVlc3QpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHVzZXIgYnkgdXNlciBJRFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBVc2VyIElEIG9mIHRoZSB1c2VyIHRvIGZldGNoLiBJZiBgbWVgIGlzIHByb3ZpZGVkLCBhIG1pbmltYWwgcmVzcG9uc2UgaW5jbHVkaW5nIHRoZSB1c2VycyByb2xlIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfcmVxdWVzdChfX3ByaXZhdGVHZXQkMSh0aGlzLCBfY2xpZW50KSwgX19wcml2YXRlR2V0JDEodGhpcywgX2h0dHBSZXF1ZXN0JDEpLCB7XG4gICAgICB1cmk6IFwiL3VzZXJzL1wiLmNvbmNhdChpZClcbiAgICB9KTtcbiAgfVxufVxuX2NsaWVudCA9IG5ldyBXZWFrTWFwKCk7XG5faHR0cFJlcXVlc3QkMSA9IG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBVc2Vyc0NsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaHR0cFJlcXVlc3QpIHtcbiAgICBfX3ByaXZhdGVBZGQkMSh0aGlzLCBfY2xpZW50Miwgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVBZGQkMSh0aGlzLCBfaHR0cFJlcXVlc3QyJDEsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlU2V0JDEodGhpcywgX2NsaWVudDIsIGNsaWVudCk7XG4gICAgX19wcml2YXRlU2V0JDEodGhpcywgX2h0dHBSZXF1ZXN0MiQxLCBodHRwUmVxdWVzdCk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGEgdXNlciBieSB1c2VyIElEXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIFVzZXIgSUQgb2YgdGhlIHVzZXIgdG8gZmV0Y2guIElmIGBtZWAgaXMgcHJvdmlkZWQsIGEgbWluaW1hbCByZXNwb25zZSBpbmNsdWRpbmcgdGhlIHVzZXJzIHJvbGUgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXRCeUlkKGlkKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX3JlcXVlc3QoX19wcml2YXRlR2V0JDEodGhpcywgX2NsaWVudDIpLCBfX3ByaXZhdGVHZXQkMSh0aGlzLCBfaHR0cFJlcXVlc3QyJDEpLCB7XG4gICAgICB1cmk6IFwiL3VzZXJzL1wiLmNvbmNhdChpZClcbiAgICB9KSk7XG4gIH1cbn1cbl9jbGllbnQyID0gbmV3IFdlYWtNYXAoKTtcbl9odHRwUmVxdWVzdDIkMSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9jbGllbnRDb25maWcsIF9odHRwUmVxdWVzdCwgX2NsaWVudENvbmZpZzIsIF9odHRwUmVxdWVzdDI7XG5jb25zdCBfT2JzZXJ2YWJsZVNhbml0eUNsaWVudCA9IGNsYXNzIF9PYnNlcnZhYmxlU2FuaXR5Q2xpZW50IHtcbiAgY29uc3RydWN0b3IoaHR0cFJlcXVlc3QpIHtcbiAgICBsZXQgY29uZmlnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBkZWZhdWx0Q29uZmlnO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgcHJvcGVydGllc1xuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfY2xpZW50Q29uZmlnLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaHR0cFJlcXVlc3QsIHZvaWQgMCk7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2UgcHJvcGVydGllc1xuICAgICAqL1xuICAgIHRoaXMubGlzdGVuID0gX2xpc3RlbjtcbiAgICB0aGlzLmNvbmZpZyhjb25maWcpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaHR0cFJlcXVlc3QsIGh0dHBSZXF1ZXN0KTtcbiAgICB0aGlzLmFzc2V0cyA9IG5ldyBPYnNlcnZhYmxlQXNzZXRzQ2xpZW50KHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QpKTtcbiAgICB0aGlzLmRhdGFzZXRzID0gbmV3IE9ic2VydmFibGVEYXRhc2V0c0NsaWVudCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSk7XG4gICAgdGhpcy5wcm9qZWN0cyA9IG5ldyBPYnNlcnZhYmxlUHJvamVjdHNDbGllbnQodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCkpO1xuICAgIHRoaXMudXNlcnMgPSBuZXcgT2JzZXJ2YWJsZVVzZXJzQ2xpZW50KHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QpKTtcbiAgfVxuICAvKipcbiAgICogQ2xvbmUgdGhlIGNsaWVudCAtIHJldHVybnMgYSBuZXcgaW5zdGFuY2VcbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX09ic2VydmFibGVTYW5pdHlDbGllbnQoX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCksIHRoaXMuY29uZmlnKCkpO1xuICB9XG4gIGNvbmZpZyhuZXdDb25maWcpIHtcbiAgICBpZiAobmV3Q29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLl9fcHJpdmF0ZUdldCh0aGlzLCBfY2xpZW50Q29uZmlnKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xpZW50Q29uZmlnKSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2NsaWVudENvbmZpZykuYWxsb3dSZWNvbmZpZ3VyZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4aXN0aW5nIGNsaWVudCBpbnN0YW5jZSBjYW5ub3QgYmUgcmVjb25maWd1cmVkIC0gdXNlIGB3aXRoQ29uZmlnKG5ld0NvbmZpZylgIHRvIHJldHVybiBhIG5ldyBjbGllbnRcIik7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2xpZW50Q29uZmlnLCBpbml0Q29uZmlnKG5ld0NvbmZpZywgX19wcml2YXRlR2V0KHRoaXMsIF9jbGllbnRDb25maWcpIHx8IHt9KSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgd2l0aCBhIG5ldyAocGFydGlhbCkgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ld0NvbmZpZyAtIE5ldyBjbGllbnQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLCBzaGFsbG93bHkgbWVyZ2VkIHdpdGggZXhpc3RpbmcgY29uZmlndXJhdGlvblxuICAgKi9cbiAgd2l0aENvbmZpZyhuZXdDb25maWcpIHtcbiAgICByZXR1cm4gbmV3IF9PYnNlcnZhYmxlU2FuaXR5Q2xpZW50KF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QpLCB7XG4gICAgICAuLi50aGlzLmNvbmZpZygpLFxuICAgICAgLi4ubmV3Q29uZmlnXG4gICAgfSk7XG4gIH1cbiAgZmV0Y2gocXVlcnksIHBhcmFtcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gX2ZldGNoKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QpLCBxdWVyeSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIERvY3VtZW50IElEIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICBnZXREb2N1bWVudChpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZ2V0RG9jdW1lbnQodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCksIGlkLCBvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggbXVsdGlwbGUgZG9jdW1lbnRzIGluIG9uZSByZXF1ZXN0LlxuICAgKiBTaG91bGQgYmUgdXNlZCBzcGFyaW5nbHkgLSBwZXJmb3JtaW5nIGEgcXVlcnkgaXMgdXN1YWxseSBhIGJldHRlciBvcHRpb24uXG4gICAqIFRoZSBvcmRlci9wb3NpdGlvbiBvZiBkb2N1bWVudHMgaXMgcHJlc2VydmVkIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBhcnJheSBvZiBJRHMuXG4gICAqIElmIGFueSBvZiB0aGUgZG9jdW1lbnRzIGFyZSBtaXNzaW5nLCB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYnkgYSBgbnVsbGAgZW50cnkgaW4gdGhlIHJldHVybmVkIGFycmF5XG4gICAqXG4gICAqIEBwYXJhbSBpZHMgLSBEb2N1bWVudCBJRHMgdG8gZmV0Y2hcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICovXG4gIGdldERvY3VtZW50cyhpZHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldERvY3VtZW50cyh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSwgaWRzLCBvcHRpb25zKTtcbiAgfVxuICBjcmVhdGUoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZSh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSwgZG9jdW1lbnQsIFwiY3JlYXRlXCIsIG9wdGlvbnMpO1xuICB9XG4gIGNyZWF0ZUlmTm90RXhpc3RzKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVJZk5vdEV4aXN0cyh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSwgZG9jdW1lbnQsIG9wdGlvbnMpO1xuICB9XG4gIGNyZWF0ZU9yUmVwbGFjZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfY3JlYXRlT3JSZXBsYWNlKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QpLCBkb2N1bWVudCwgb3B0aW9ucyk7XG4gIH1cbiAgZGVsZXRlKHNlbGVjdGlvbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZGVsZXRlKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QpLCBzZWxlY3Rpb24sIG9wdGlvbnMpO1xuICB9XG4gIG11dGF0ZShvcGVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9tdXRhdGUodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdCksIG9wZXJhdGlvbnMsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYnVpbGRhYmxlIHBhdGNoIG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybVxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gRG9jdW1lbnQgSUQsIGFuIGFycmF5IG9mIGRvY3VtZW50IElEcywgb3IgYW4gb2JqZWN0IHdpdGggYHF1ZXJ5YCBhbmQgb3B0aW9uYWwgYHBhcmFtc2AsIGRlZmluaW5nIHdoaWNoIGRvY3VtZW50KHMpIHRvIHBhdGNoXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgb2JqZWN0IG9mIHBhdGNoIG9wZXJhdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgcGF0Y2ggaW5zdGFuY2Ugd2l0aFxuICAgKiBAcmV0dXJucyBQYXRjaCBpbnN0YW5jZSAtIGNhbGwgYC5jb21taXQoKWAgdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9ucyBkZWZpbmVkXG4gICAqL1xuICBwYXRjaChzZWxlY3Rpb24sIG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQYXRjaChzZWxlY3Rpb24sIG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gb2YgbXV0YXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb25zIC0gT3B0aW9uYWwgYXJyYXkgb2YgbXV0YXRpb24gb3BlcmF0aW9ucyB0byBpbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoXG4gICAqL1xuICB0cmFuc2FjdGlvbihvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlVHJhbnNhY3Rpb24ob3BlcmF0aW9ucywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gSFRUUCByZXF1ZXN0IGFnYWluc3QgdGhlIFNhbml0eSBBUElcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZXF1ZXN0IG9wdGlvbnNcbiAgICovXG4gIHJlcXVlc3Qob3B0aW9ucykge1xuICAgIHJldHVybiBfcmVxdWVzdCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0KSwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIFNhbml0eSBBUEkgVVJMIGZvciB0aGUgVVJJIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSB1cmkgLSBVUkkvcGF0aCB0byBidWlsZCBVUkwgZm9yXG4gICAqIEBwYXJhbSBjYW5Vc2VDZG4gLSBXaGV0aGVyIG9yIG5vdCB0byBhbGxvdyB1c2luZyB0aGUgQVBJIENETiBmb3IgdGhpcyByb3V0ZVxuICAgKi9cbiAgZ2V0VXJsKHVyaSwgY2FuVXNlQ2RuKSB7XG4gICAgcmV0dXJuIF9nZXRVcmwodGhpcywgdXJpLCBjYW5Vc2VDZG4pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBTYW5pdHkgQVBJIFVSTCBmb3IgdGhlIGRhdGEgb3BlcmF0aW9uIGFuZCBwYXRoIHByb3ZpZGVkXG4gICAqXG4gICAqIEBwYXJhbSBvcGVyYXRpb24gLSBEYXRhIG9wZXJhdGlvbiAoZWcgYHF1ZXJ5YCwgYG11dGF0ZWAsIGBsaXN0ZW5gIG9yIHNpbWlsYXIpXG4gICAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBhcHBlbmQgYWZ0ZXIgdGhlIG9wZXJhdGlvblxuICAgKi9cbiAgZ2V0RGF0YVVybChvcGVyYXRpb24sIHBhdGgpIHtcbiAgICByZXR1cm4gX2dldERhdGFVcmwodGhpcywgb3BlcmF0aW9uLCBwYXRoKTtcbiAgfVxufTtcbl9jbGllbnRDb25maWcgPSBuZXcgV2Vha01hcCgpO1xuX2h0dHBSZXF1ZXN0ID0gbmV3IFdlYWtNYXAoKTtcbmxldCBPYnNlcnZhYmxlU2FuaXR5Q2xpZW50ID0gX09ic2VydmFibGVTYW5pdHlDbGllbnQ7XG5jb25zdCBfU2FuaXR5Q2xpZW50ID0gY2xhc3MgX1Nhbml0eUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGh0dHBSZXF1ZXN0KSB7XG4gICAgbGV0IGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZGVmYXVsdENvbmZpZztcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NsaWVudENvbmZpZzIsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9odHRwUmVxdWVzdDIsIHZvaWQgMCk7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2UgcHJvcGVydGllc1xuICAgICAqL1xuICAgIHRoaXMubGlzdGVuID0gX2xpc3RlbjtcbiAgICB0aGlzLmNvbmZpZyhjb25maWcpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaHR0cFJlcXVlc3QyLCBodHRwUmVxdWVzdCk7XG4gICAgdGhpcy5hc3NldHMgPSBuZXcgQXNzZXRzQ2xpZW50KHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QyKSk7XG4gICAgdGhpcy5kYXRhc2V0cyA9IG5ldyBEYXRhc2V0c0NsaWVudCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MikpO1xuICAgIHRoaXMucHJvamVjdHMgPSBuZXcgUHJvamVjdHNDbGllbnQodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpKTtcbiAgICB0aGlzLnVzZXJzID0gbmV3IFVzZXJzQ2xpZW50KHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QyKSk7XG4gICAgdGhpcy5vYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVTYW5pdHlDbGllbnQoaHR0cFJlcXVlc3QsIGNvbmZpZyk7XG4gIH1cbiAgLyoqXG4gICAqIENsb25lIHRoZSBjbGllbnQgLSByZXR1cm5zIGEgbmV3IGluc3RhbmNlXG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9TYW5pdHlDbGllbnQoX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCB0aGlzLmNvbmZpZygpKTtcbiAgfVxuICBjb25maWcobmV3Q29uZmlnKSB7XG4gICAgaWYgKG5ld0NvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5fX3ByaXZhdGVHZXQodGhpcywgX2NsaWVudENvbmZpZzIpXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9jbGllbnRDb25maWcyKSAmJiBfX3ByaXZhdGVHZXQodGhpcywgX2NsaWVudENvbmZpZzIpLmFsbG93UmVjb25maWd1cmUgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGlzdGluZyBjbGllbnQgaW5zdGFuY2UgY2Fubm90IGJlIHJlY29uZmlndXJlZCAtIHVzZSBgd2l0aENvbmZpZyhuZXdDb25maWcpYCB0byByZXR1cm4gYSBuZXcgY2xpZW50XCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vYnNlcnZhYmxlKSB7XG4gICAgICB0aGlzLm9ic2VydmFibGUuY29uZmlnKG5ld0NvbmZpZyk7XG4gICAgfVxuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2xpZW50Q29uZmlnMiwgaW5pdENvbmZpZyhuZXdDb25maWcsIF9fcHJpdmF0ZUdldCh0aGlzLCBfY2xpZW50Q29uZmlnMikgfHwge30pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ2xvbmUgdGhlIGNsaWVudCB3aXRoIGEgbmV3IChwYXJ0aWFsKSBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gbmV3Q29uZmlnIC0gTmV3IGNsaWVudCBjb25maWd1cmF0aW9uIHByb3BlcnRpZXMsIHNoYWxsb3dseSBtZXJnZWQgd2l0aCBleGlzdGluZyBjb25maWd1cmF0aW9uXG4gICAqL1xuICB3aXRoQ29uZmlnKG5ld0NvbmZpZykge1xuICAgIHJldHVybiBuZXcgX1Nhbml0eUNsaWVudChfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MiksIHtcbiAgICAgIC4uLnRoaXMuY29uZmlnKCksXG4gICAgICAuLi5uZXdDb25maWdcbiAgICB9KTtcbiAgfVxuICBmZXRjaChxdWVyeSwgcGFyYW1zKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9mZXRjaCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MiksIHF1ZXJ5LCBwYXJhbXMsIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZG9jdW1lbnQgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAqXG4gICAqIEBwYXJhbSBpZCAtIERvY3VtZW50IElEIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICBnZXREb2N1bWVudChpZCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9nZXREb2N1bWVudCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MiksIGlkLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIG11bHRpcGxlIGRvY3VtZW50cyBpbiBvbmUgcmVxdWVzdC5cbiAgICogU2hvdWxkIGJlIHVzZWQgc3BhcmluZ2x5IC0gcGVyZm9ybWluZyBhIHF1ZXJ5IGlzIHVzdWFsbHkgYSBiZXR0ZXIgb3B0aW9uLlxuICAgKiBUaGUgb3JkZXIvcG9zaXRpb24gb2YgZG9jdW1lbnRzIGlzIHByZXNlcnZlZCBiYXNlZCBvbiB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgSURzLlxuICAgKiBJZiBhbnkgb2YgdGhlIGRvY3VtZW50cyBhcmUgbWlzc2luZywgdGhleSB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgYG51bGxgIGVudHJ5IGluIHRoZSByZXR1cm5lZCBhcnJheVxuICAgKlxuICAgKiBAcGFyYW0gaWRzIC0gRG9jdW1lbnQgSURzIHRvIGZldGNoXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqL1xuICBnZXREb2N1bWVudHMoaWRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2dldERvY3VtZW50cyh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MiksIGlkcywgb3B0aW9ucykpO1xuICB9XG4gIGNyZWF0ZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBsYXN0VmFsdWVGcm9tKF9jcmVhdGUodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCBkb2N1bWVudCwgXCJjcmVhdGVcIiwgb3B0aW9ucykpO1xuICB9XG4gIGNyZWF0ZUlmTm90RXhpc3RzKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2NyZWF0ZUlmTm90RXhpc3RzKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QyKSwgZG9jdW1lbnQsIG9wdGlvbnMpKTtcbiAgfVxuICBjcmVhdGVPclJlcGxhY2UoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfY3JlYXRlT3JSZXBsYWNlKHRoaXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfaHR0cFJlcXVlc3QyKSwgZG9jdW1lbnQsIG9wdGlvbnMpKTtcbiAgfVxuICBkZWxldGUoc2VsZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX2RlbGV0ZSh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MiksIHNlbGVjdGlvbiwgb3B0aW9ucykpO1xuICB9XG4gIG11dGF0ZShvcGVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGxhc3RWYWx1ZUZyb20oX211dGF0ZSh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MiksIG9wZXJhdGlvbnMsIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGJ1aWxkYWJsZSBwYXRjaCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIERvY3VtZW50IElELCBhbiBhcnJheSBvZiBkb2N1bWVudCBJRHMsIG9yIGFuIG9iamVjdCB3aXRoIGBxdWVyeWAgYW5kIG9wdGlvbmFsIGBwYXJhbXNgLCBkZWZpbmluZyB3aGljaCBkb2N1bWVudChzKSB0byBwYXRjaFxuICAgKiBAcGFyYW0gb3BlcmF0aW9ucyAtIE9wdGlvbmFsIG9iamVjdCBvZiBwYXRjaCBvcGVyYXRpb25zIHRvIGluaXRpYWxpemUgdGhlIHBhdGNoIGluc3RhbmNlIHdpdGhcbiAgICogQHJldHVybnMgUGF0Y2ggaW5zdGFuY2UgLSBjYWxsIGAuY29tbWl0KClgIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbnMgZGVmaW5lZFxuICAgKi9cbiAgcGF0Y2goZG9jdW1lbnRJZCwgb3BlcmF0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGF0Y2goZG9jdW1lbnRJZCwgb3BlcmF0aW9ucywgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0cmFuc2FjdGlvbiBvZiBtdXRhdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIG9wZXJhdGlvbnMgLSBPcHRpb25hbCBhcnJheSBvZiBtdXRhdGlvbiBvcGVyYXRpb25zIHRvIGluaXRpYWxpemUgdGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIHdpdGhcbiAgICovXG4gIHRyYW5zYWN0aW9uKG9wZXJhdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKG9wZXJhdGlvbnMsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgcmVxdWVzdCBhZ2FpbnN0IHRoZSBTYW5pdHkgQVBJXG4gICAqIE5PVEU6IE9ubHkgdXNlIHRoaXMgZm9yIFNhbml0eSBBUEkgZW5kcG9pbnRzLCBub3QgZm9yIHlvdXIgb3duIEFQSXMhXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXNwb25zZSBib2R5XG4gICAqL1xuICByZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfcmVxdWVzdCh0aGlzLCBfX3ByaXZhdGVHZXQodGhpcywgX2h0dHBSZXF1ZXN0MiksIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybSBhbiBIVFRQIHJlcXVlc3QgYSBgL2RhdGFgIHN1Yi1lbmRwb2ludFxuICAgKiBOT1RFOiBDb25zaWRlcmVkIGludGVybmFsLCB0aHVzIG1hcmtlZCBhcyBkZXByZWNhdGVkLiBVc2UgYHJlcXVlc3RgIGluc3RlYWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIC0gVXNlIGByZXF1ZXN0KClgIG9yIHlvdXIgb3duIEhUVFAgbGlicmFyeSBpbnN0ZWFkXG4gICAqIEBwYXJhbSBlbmRwb2ludCAtIEVuZHBvaW50IHRvIGhpdCAobXV0YXRlLCBxdWVyeSBldGMpXG4gICAqIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5XG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVxdWVzdCBvcHRpb25zXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGF0YVJlcXVlc3QoZW5kcG9pbnQsIGJvZHksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlRnJvbShfZGF0YVJlcXVlc3QodGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9odHRwUmVxdWVzdDIpLCBlbmRwb2ludCwgYm9keSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBTYW5pdHkgQVBJIFVSTCBmb3IgdGhlIFVSSSBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gdXJpIC0gVVJJL3BhdGggdG8gYnVpbGQgVVJMIGZvclxuICAgKiBAcGFyYW0gY2FuVXNlQ2RuIC0gV2hldGhlciBvciBub3QgdG8gYWxsb3cgdXNpbmcgdGhlIEFQSSBDRE4gZm9yIHRoaXMgcm91dGVcbiAgICovXG4gIGdldFVybCh1cmksIGNhblVzZUNkbikge1xuICAgIHJldHVybiBfZ2V0VXJsKHRoaXMsIHVyaSwgY2FuVXNlQ2RuKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgU2FuaXR5IEFQSSBVUkwgZm9yIHRoZSBkYXRhIG9wZXJhdGlvbiBhbmQgcGF0aCBwcm92aWRlZFxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uIC0gRGF0YSBvcGVyYXRpb24gKGVnIGBxdWVyeWAsIGBtdXRhdGVgLCBgbGlzdGVuYCBvciBzaW1pbGFyKVxuICAgKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gYXBwZW5kIGFmdGVyIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIGdldERhdGFVcmwob3BlcmF0aW9uLCBwYXRoKSB7XG4gICAgcmV0dXJuIF9nZXREYXRhVXJsKHRoaXMsIG9wZXJhdGlvbiwgcGF0aCk7XG4gIH1cbn07XG5fY2xpZW50Q29uZmlnMiA9IG5ldyBXZWFrTWFwKCk7XG5faHR0cFJlcXVlc3QyID0gbmV3IFdlYWtNYXAoKTtcbmxldCBTYW5pdHlDbGllbnQgPSBfU2FuaXR5Q2xpZW50O1xuY29uc3QgaHR0cFJlcXVlc3QgPSBkZWZpbmVIdHRwUmVxdWVzdChlbnZNaWRkbGV3YXJlLCB7fSk7XG5jb25zdCByZXF1ZXN0ZXIgPSBodHRwUmVxdWVzdC5kZWZhdWx0UmVxdWVzdGVyO1xuY29uc3QgY3JlYXRlQ2xpZW50ID0gY29uZmlnID0+IG5ldyBTYW5pdHlDbGllbnQoZGVmaW5lSHR0cFJlcXVlc3QoZW52TWlkZGxld2FyZSwge1xuICBtYXhSZXRyaWVzOiBjb25maWcubWF4UmV0cmllcyxcbiAgcmV0cnlEZWxheTogY29uZmlnLnJldHJ5RGVsYXlcbn0pLCBjb25maWcpO1xuZnVuY3Rpb24gZGVwcmVjYXRlZENyZWF0ZUNsaWVudChjb25maWcpIHtcbiAgcHJpbnROb0RlZmF1bHRFeHBvcnQoKTtcbiAgcmV0dXJuIG5ldyBTYW5pdHlDbGllbnQoaHR0cFJlcXVlc3QsIGNvbmZpZyk7XG59XG5leHBvcnQgeyBCYXNlUGF0Y2gsIEJhc2VUcmFuc2FjdGlvbiwgQ2xpZW50RXJyb3IsIE9ic2VydmFibGVQYXRjaCwgT2JzZXJ2YWJsZVNhbml0eUNsaWVudCwgT2JzZXJ2YWJsZVRyYW5zYWN0aW9uLCBQYXRjaCwgU2FuaXR5Q2xpZW50LCBTZXJ2ZXJFcnJvciwgVHJhbnNhY3Rpb24sIGNyZWF0ZUNsaWVudCwgZGVwcmVjYXRlZENyZWF0ZUNsaWVudCBhcyBkZWZhdWx0LCByZXF1ZXN0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmJyb3dzZXIuanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0SXQiLCJhZGFwdGVyIiwidW5zdGFibGVfX2FkYXB0ZXIiLCJlbnZpcm9ubWVudCIsInVuc3RhYmxlX19lbnZpcm9ubWVudCIsInJldHJ5IiwianNvblJlcXVlc3QiLCJqc29uUmVzcG9uc2UiLCJwcm9ncmVzcyIsIm9ic2VydmFibGUiLCJPYnNlcnZhYmxlIiwibGFzdFZhbHVlRnJvbSIsIm1hcCIsImZpbHRlciIsImVudk1pZGRsZXdhcmUiLCJNQVhfSVRFTVNfSU5fRVJST1JfTUVTU0FHRSIsIkNsaWVudEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsInJlcyIsInByb3BzIiwiZXh0cmFjdEVycm9yUHJvcHMiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsIk9iamVjdCIsImFzc2lnbiIsIlNlcnZlckVycm9yIiwiYm9keSIsInJlc3BvbnNlIiwicmVzcG9uc2VCb2R5Iiwic3RyaW5naWZ5Qm9keSIsImRldGFpbHMiLCJlcnJvciIsImNvbmNhdCIsImlzTXV0YXRpb25FcnJvciIsImFsbEl0ZW1zIiwiaXRlbXMiLCJzbGljZSIsIml0ZW0iLCJfYSIsImRlc2NyaXB0aW9uIiwiQm9vbGVhbiIsIml0ZW1zU3RyIiwibGVuZ3RoIiwiam9pbiIsImh0dHBFcnJvck1lc3NhZ2UiLCJpc1BsYWluT2JqZWN0IiwidHlwZSIsIm9iaiIsIkFycmF5IiwiaXNBcnJheSIsInN0YXR1c01lc3NhZ2UiLCJtZXRob2QiLCJ1cmwiLCJjb250ZW50VHlwZSIsImhlYWRlcnMiLCJ0b0xvd2VyQ2FzZSIsImlzSnNvbiIsImluZGV4T2YiLCJKU09OIiwic3RyaW5naWZ5IiwiaHR0cEVycm9yIiwib25SZXNwb25zZSIsInByaW50V2FybmluZ3MiLCJ3YXJuIiwid2FybmluZ3MiLCJmb3JFYWNoIiwibXNnIiwiY29uc29sZSIsImRlZmluZUh0dHBSZXF1ZXN0IiwiX3JlZiIsIm1heFJldHJpZXMiLCJyZXRyeURlbGF5IiwicmVxdWVzdCIsInNob3VsZFJldHJ5IiwiaW1wbGVtZW50YXRpb24iLCJodHRwUmVxdWVzdCIsIm9wdGlvbnMiLCJyZXF1ZXN0ZXIiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJtYXhSZWRpcmVjdHMiLCJkZWZhdWx0UmVxdWVzdGVyIiwiZXJyIiwiYXR0ZW1wdCIsImlzU2FmZSIsInVyaSIsImlzUXVlcnkiLCJzdGFydHNXaXRoIiwiaXNSZXRyaWFibGVSZXNwb25zZSIsIkJBU0VfVVJMIiwiZ2VuZXJhdGVIZWxwVXJsIiwic2x1ZyIsIlZBTElEX0FTU0VUX1RZUEVTIiwiVkFMSURfSU5TRVJUX0xPQ0FUSU9OUyIsImRhdGFzZXQiLCJuYW1lIiwidGVzdCIsInByb2plY3RJZCIsImlkIiwidmFsaWRhdGVBc3NldFR5cGUiLCJ2YWxpZGF0ZU9iamVjdCIsIm9wIiwidmFsIiwidmFsaWRhdGVEb2N1bWVudElkIiwiaW5jbHVkZXMiLCJyZXF1aXJlRG9jdW1lbnRJZCIsImRvYyIsIl9pZCIsInZhbGlkYXRlSW5zZXJ0IiwiYXQiLCJzZWxlY3RvciIsInNpZ25hdHVyZSIsInZhbGlkIiwibG9jIiwiaGFzRGF0YXNldCIsImNvbmZpZyIsInJlcXVlc3RUYWciLCJ0YWciLCJvbmNlIiwiZm4iLCJkaWRDYWxsIiwicmV0dXJuVmFsdWUiLCJjcmVhdGVXYXJuaW5nUHJpbnRlciIsIl9sZW4iLCJhcmdzIiwiX2tleSIsInByaW50Q2RuV2FybmluZyIsInByaW50Q2RuUHJldmlld0RyYWZ0c1dhcm5pbmciLCJwcmludEJyb3dzZXJUb2tlbldhcm5pbmciLCJwcmludE5vQXBpVmVyc2lvblNwZWNpZmllZFdhcm5pbmciLCJwcmludE5vRGVmYXVsdEV4cG9ydCIsImRlZmF1bHRDZG5Ib3N0IiwiZGVmYXVsdENvbmZpZyIsImFwaUhvc3QiLCJhcGlWZXJzaW9uIiwidXNlUHJvamVjdEhvc3RuYW1lIiwiTE9DQUxIT1NUUyIsImlzTG9jYWwiLCJob3N0IiwidmFsaWRhdGVBcGlWZXJzaW9uIiwidmFsaWRhdGVBcGlWZXJzaW9uMiIsImFwaURhdGUiLCJEYXRlIiwiYXBpVmVyc2lvblZhbGlkIiwiZ2V0VGltZSIsInZhbGlkYXRlQXBpUGVyc3BlY3RpdmUiLCJ2YWxpZGF0ZUFwaVBlcnNwZWN0aXZlMiIsInBlcnNwZWN0aXZlIiwiVHlwZUVycm9yIiwiaW5pdENvbmZpZyIsInByZXZDb25maWciLCJzcGVjaWZpZWRDb25maWciLCJuZXdDb25maWciLCJwcm9qZWN0QmFzZWQiLCJQcm9taXNlIiwiaGVscFVybCIsImlzQnJvd3NlciIsIndpbmRvdyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJpc0xvY2FsaG9zdCIsInRva2VuIiwiaWdub3JlQnJvd3NlclRva2VuV2FybmluZyIsInVzZUNkbiIsInJlcXVlc3RUYWdQcmVmaXgiLCJyZXBsYWNlIiwiaXNEZWZhdWx0QXBpIiwid2l0aENyZWRlbnRpYWxzIiwiaG9zdFBhcnRzIiwic3BsaXQiLCJwcm90b2NvbCIsImNkbkhvc3QiLCJjZG5VcmwiLCJwcm9qZWN0SGVhZGVyIiwicmVxdWVzdE9wdGlvbnMiLCJvdmVycmlkZXMiLCJBdXRob3JpemF0aW9uIiwidXNlR2xvYmFsQXBpIiwidGltZW91dCIsInByb3h5IiwianNvbiIsImZldGNoIiwiZ2V0U2VsZWN0aW9uIiwic2VsIiwicXVlcnkiLCJwYXJhbXMiLCJzZWxlY3Rpb25PcHRzIiwiZW5jb2RlUXVlcnlTdHJpbmciLCJfcmVmMiIsInNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsIm9wdHMiLCJhcHBlbmQiLCJrZXkiLCJ2YWx1ZSIsImVudHJpZXMiLCJfX2FjY2Vzc0NoZWNrJDYiLCJtZW1iZXIiLCJoYXMiLCJfX3ByaXZhdGVHZXQkNiIsImdldHRlciIsImNhbGwiLCJnZXQiLCJfX3ByaXZhdGVBZGQkNiIsIldlYWtTZXQiLCJhZGQiLCJzZXQiLCJfX3ByaXZhdGVTZXQkNiIsInNldHRlciIsIl9jbGllbnQkNSIsIl9jbGllbnQyJDUiLCJCYXNlUGF0Y2giLCJzZWxlY3Rpb24iLCJvcGVyYXRpb25zIiwiYXR0cnMiLCJfYXNzaWduIiwic2V0SWZNaXNzaW5nIiwiZGlmZk1hdGNoUGF0Y2giLCJ1bnNldCIsImluYyIsImRlYyIsImluc2VydCIsInByZXBlbmQiLCJzcGxpY2UiLCJzdGFydCIsImRlbGV0ZUNvdW50IiwiZGVsQWxsIiwic3RhcnRJbmRleCIsImRlbENvdW50IiwiTWF0aCIsIm1heCIsImRlbFJhbmdlIiwicmFuZ2VTZWxlY3RvciIsImlmUmV2aXNpb25JZCIsInJldiIsImlmUmV2aXNpb25JRCIsInNlcmlhbGl6ZSIsInRvSlNPTiIsInJlc2V0IiwibWVyZ2UiLCJfc2V0IiwiX09ic2VydmFibGVQYXRjaCIsImNsaWVudCIsImNsb25lIiwiY29tbWl0IiwicmV0dXJuRmlyc3QiLCJyZXR1cm5Eb2N1bWVudHMiLCJtdXRhdGUiLCJwYXRjaCIsIldlYWtNYXAiLCJPYnNlcnZhYmxlUGF0Y2giLCJfUGF0Y2giLCJQYXRjaCIsIl9fYWNjZXNzQ2hlY2skNSIsIl9fcHJpdmF0ZUdldCQ1IiwiX19wcml2YXRlQWRkJDUiLCJfX3ByaXZhdGVTZXQkNSIsIl9jbGllbnQkNCIsIl9jbGllbnQyJDQiLCJkZWZhdWx0TXV0YXRlT3B0aW9ucyIsIkJhc2VUcmFuc2FjdGlvbiIsInRyYW5zYWN0aW9uSWQiLCJ0cnhJZCIsImNyZWF0ZSIsIl9hZGQiLCJjcmVhdGVJZk5vdEV4aXN0cyIsImNyZWF0ZU9yUmVwbGFjZSIsImRlbGV0ZSIsImRvY3VtZW50SWQiLCJtdXQiLCJwdXNoIiwiX1RyYW5zYWN0aW9uIiwicGF0Y2hPckRvY3VtZW50SWQiLCJwYXRjaE9wcyIsImlzQnVpbGRlciIsImlzUGF0Y2giLCJUcmFuc2FjdGlvbiIsIl9PYnNlcnZhYmxlVHJhbnNhY3Rpb24iLCJPYnNlcnZhYmxlVHJhbnNhY3Rpb24iLCJleGNsdWRlRmFsc2V5IiwicGFyYW0iLCJkZWZWYWx1ZSIsImdldE11dGF0aW9uUXVlcnkiLCJkcnlSdW4iLCJyZXR1cm5JZHMiLCJ2aXNpYmlsaXR5IiwiYXV0b0dlbmVyYXRlQXJyYXlLZXlzIiwic2tpcENyb3NzRGF0YXNldFJlZmVyZW5jZVZhbGlkYXRpb24iLCJpc1Jlc3BvbnNlIiwiZXZlbnQiLCJnZXRCb2R5IiwiaW5kZXhCeSIsImRvY3MiLCJhdHRyIiwicmVkdWNlIiwiaW5kZXhlZCIsImdldFF1ZXJ5U2l6ZUxpbWl0IiwiX2ZldGNoIiwibWFwUmVzcG9uc2UiLCJmaWx0ZXJSZXNwb25zZSIsInJlc3VsdCIsImNhY2hlIiwibmV4dCIsInVzZUFib3J0U2lnbmFsIiwic2lnbmFsIiwicmVxT3B0cyIsIl9kYXRhUmVxdWVzdCIsInBpcGUiLCJfZ2V0RG9jdW1lbnQiLCJfZ2V0RGF0YVVybCIsIl9yZXF1ZXN0T2JzZXJ2YWJsZSIsImRvY3VtZW50cyIsIl9nZXREb2N1bWVudHMiLCJpZHMiLCJfY3JlYXRlSWZOb3RFeGlzdHMiLCJfY3JlYXRlIiwiX2NyZWF0ZU9yUmVwbGFjZSIsIl9kZWxldGUiLCJtdXRhdGlvbnMiLCJfbXV0YXRlIiwibXV0cyIsImVuZHBvaW50IiwiaXNNdXRhdGlvbiIsInN0clF1ZXJ5IiwidXNlR2V0Iiwic3RyaW5nUXVlcnkiLCJyZXFPcHRpb25zIiwicmVzdWx0U291cmNlTWFwIiwiY2FuVXNlQ2RuIiwicmVzdWx0cyIsImRvY3VtZW50IiwibXV0YXRpb24iLCJfZ2V0VXJsIiwic3Vic2NyaWJlciIsInN1YnNjcmliZSIsIl93aXRoQWJvcnRTaWduYWwiLCJfcmVxdWVzdCIsIm9wZXJhdGlvbiIsInBhdGgiLCJjYXRhbG9nIiwiYmFzZVVyaSIsImJhc2UiLCJpbnB1dCIsIm9ic2VydmVyIiwiYWJvcnQiLCJfY3JlYXRlQWJvcnRFcnJvciIsImFib3J0ZWQiLCJzdWJzY3JpcHRpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVuc3Vic2NyaWJlIiwiaXNEb21FeGNlcHRpb25TdXBwb3J0ZWQiLCJnbG9iYWxUaGlzIiwiRE9NRXhjZXB0aW9uIiwiX2IiLCJyZWFzb24iLCJfX2FjY2Vzc0NoZWNrJDQiLCJfX3ByaXZhdGVHZXQkNCIsIl9fcHJpdmF0ZUFkZCQ0IiwiX19wcml2YXRlU2V0JDQiLCJfY2xpZW50JDMiLCJfaHR0cFJlcXVlc3QkNCIsIl9jbGllbnQyJDMiLCJfaHR0cFJlcXVlc3QyJDQiLCJPYnNlcnZhYmxlQXNzZXRzQ2xpZW50IiwidXBsb2FkIiwiYXNzZXRUeXBlIiwiX3VwbG9hZCIsIkFzc2V0c0NsaWVudCIsIm1ldGEiLCJleHRyYWN0IiwiYXNzZXRFbmRwb2ludCIsIm9wdGlvbnNGcm9tRmlsZSIsImxhYmVsIiwidGl0bGUiLCJjcmVkaXRMaW5lIiwiZmlsZW5hbWUiLCJzb3VyY2UiLCJzb3VyY2VJZCIsInNvdXJjZU5hbWUiLCJzb3VyY2VVcmwiLCJmaWxlIiwiRmlsZSIsInByZXNlcnZlRmlsZW5hbWUiLCJkZWZhdWx0cyIsImtleXMiLCJ0YXJnZXQiLCJwcm9wIiwicGljayIsIk1BWF9VUkxfTEVOR1RIIiwicG9zc2libGVPcHRpb25zIiwiZGVmYXVsdE9wdGlvbnMiLCJpbmNsdWRlUmVzdWx0IiwiX2xpc3RlbiIsImxpc3Rlbk9wdHMiLCJxcyIsImxpc3RlbkZvciIsImV2ZW50cyIsInNob3VsZEVtaXRSZWNvbm5lY3QiLCJlc09wdGlvbnMiLCJlcyIsImdldEV2ZW50U291cmNlIiwidGhlbiIsImV2ZW50U291cmNlIiwiY2F0Y2giLCJzdG9wIiwicmVjb25uZWN0VGltZXIiLCJzdG9wcGVkIiwib25FcnJvciIsImVtaXRSZWNvbm5lY3QiLCJyZWFkeVN0YXRlIiwiQ0xPU0VEIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIm9wZW4iLCJvbkNoYW5uZWxFcnJvciIsImNvb2VyY2VFcnJvciIsIm9uTWVzc2FnZSIsImV2dCIsInBhcnNlRXZlbnQiLCJvbkRpc2Nvbm5lY3QiLCJjb21wbGV0ZSIsImNsb3NlIiwiZGVmYXVsdCIsIkV2ZW50U291cmNlIiwiZXZzIiwiZGF0YSIsInBhcnNlIiwiZXh0cmFjdEVycm9yTWVzc2FnZSIsIl9fYWNjZXNzQ2hlY2skMyIsIl9fcHJpdmF0ZUdldCQzIiwiX19wcml2YXRlQWRkJDMiLCJfX3ByaXZhdGVTZXQkMyIsIl9jbGllbnQkMiIsIl9odHRwUmVxdWVzdCQzIiwiX2NsaWVudDIkMiIsIl9odHRwUmVxdWVzdDIkMyIsIk9ic2VydmFibGVEYXRhc2V0c0NsaWVudCIsIl9tb2RpZnkiLCJlZGl0IiwibGlzdCIsIkRhdGFzZXRzQ2xpZW50IiwiX19hY2Nlc3NDaGVjayQyIiwiX19wcml2YXRlR2V0JDIiLCJfX3ByaXZhdGVBZGQkMiIsIl9fcHJpdmF0ZVNldCQyIiwiX2NsaWVudCQxIiwiX2h0dHBSZXF1ZXN0JDIiLCJfY2xpZW50MiQxIiwiX2h0dHBSZXF1ZXN0MiQyIiwiT2JzZXJ2YWJsZVByb2plY3RzQ2xpZW50IiwiaW5jbHVkZU1lbWJlcnMiLCJnZXRCeUlkIiwiUHJvamVjdHNDbGllbnQiLCJfX2FjY2Vzc0NoZWNrJDEiLCJfX3ByaXZhdGVHZXQkMSIsIl9fcHJpdmF0ZUFkZCQxIiwiX19wcml2YXRlU2V0JDEiLCJfY2xpZW50IiwiX2h0dHBSZXF1ZXN0JDEiLCJfY2xpZW50MiIsIl9odHRwUmVxdWVzdDIkMSIsIk9ic2VydmFibGVVc2Vyc0NsaWVudCIsIlVzZXJzQ2xpZW50IiwiX19hY2Nlc3NDaGVjayIsIl9fcHJpdmF0ZUdldCIsIl9fcHJpdmF0ZUFkZCIsIl9fcHJpdmF0ZVNldCIsIl9jbGllbnRDb25maWciLCJfaHR0cFJlcXVlc3QiLCJfY2xpZW50Q29uZmlnMiIsIl9odHRwUmVxdWVzdDIiLCJfT2JzZXJ2YWJsZVNhbml0eUNsaWVudCIsImxpc3RlbiIsImFzc2V0cyIsImRhdGFzZXRzIiwicHJvamVjdHMiLCJ1c2VycyIsImFsbG93UmVjb25maWd1cmUiLCJ3aXRoQ29uZmlnIiwiZ2V0RG9jdW1lbnQiLCJnZXREb2N1bWVudHMiLCJ0cmFuc2FjdGlvbiIsImdldFVybCIsImdldERhdGFVcmwiLCJPYnNlcnZhYmxlU2FuaXR5Q2xpZW50IiwiX1Nhbml0eUNsaWVudCIsImRhdGFSZXF1ZXN0IiwiU2FuaXR5Q2xpZW50IiwiY3JlYXRlQ2xpZW50IiwiZGVwcmVjYXRlZENyZWF0ZUNsaWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/client/dist/index.browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/preview-kit/dist/_chunks/sourcemap-r-TuProy.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@sanity/preview-kit/dist/_chunks/sourcemap-r-TuProy.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeIntoResult: () => (/* binding */ encodeIntoResult),\n/* harmony export */   parseNormalisedJsonPath: () => (/* binding */ parseNormalisedJsonPath),\n/* harmony export */   resolveMapping: () => (/* binding */ resolveMapping),\n/* harmony export */   walkMap: () => (/* binding */ walkMap)\n/* harmony export */ });\nconst ESCAPE = {\n    \"\\f\": \"\\\\f\",\n    \"\\n\": \"\\\\n\",\n    \"\\r\": \"\\\\r\",\n    \"\t\": \"\\\\t\",\n    \"'\": \"\\\\'\",\n    \"\\\\\": \"\\\\\\\\\"\n};\nconst UNESCAPE = {\n    \"\\\\f\": \"\\f\",\n    \"\\\\n\": \"\\n\",\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\t\",\n    \"\\\\'\": \"'\",\n    \"\\\\\\\\\": \"\\\\\"\n};\nfunction normalisedJsonPath(path) {\n    return \"$\".concat(path.map((key)=>{\n        if (typeof key === \"string\") {\n            const escapedKey = key.replace(/[\\f\\n\\r\\t'\\\\]/g, (match)=>{\n                return ESCAPE[match];\n            });\n            return \"['\".concat(escapedKey, \"']\");\n        }\n        return \"[\".concat(key, \"]\");\n    }).join(\"\"));\n}\nfunction parseNormalisedJsonPath(path) {\n    const parsed = [];\n    const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]/g;\n    let match;\n    while((match = parseRe.exec(path)) !== null){\n        if (match[1] !== void 0) {\n            const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m)=>{\n                return UNESCAPE[m];\n            });\n            parsed.push(key);\n            continue;\n        }\n        if (match[2] !== void 0) {\n            parsed.push(parseInt(match[2], 10));\n            continue;\n        }\n    }\n    return parsed;\n}\nfunction isRecord(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isArray(value) {\n    return value !== null && Array.isArray(value);\n}\nfunction encode(result, csm, encoder) {\n    return encodeIntoResult(result, csm, encoder);\n}\nfunction encodeIntoResult(result, csm, encoder) {\n    return walkMap(result, (value, path)=>{\n        if (typeof value !== \"string\") {\n            return value;\n        }\n        const resolveMappingResult = resolveMapping(path, csm);\n        if (!resolveMappingResult) {\n            return value;\n        }\n        const [mapping, , pathSuffix] = resolveMappingResult;\n        if (mapping.type !== \"value\") {\n            return value;\n        }\n        if (mapping.source.type !== \"documentValue\") {\n            return value;\n        }\n        const sourceDocument = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        csm.documents[mapping.source.document];\n        const sourcePath = csm.paths[mapping.source.path];\n        return encoder(value, sourceDocument, parseNormalisedJsonPath(sourcePath + pathSuffix));\n    });\n}\nfunction walkMap(value, mappingFn) {\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (isArray(value)) {\n        return value.map((v, idx)=>walkMap(v, mappingFn, path.concat(idx)));\n    }\n    if (isRecord(value)) {\n        return Object.fromEntries(Object.entries(value).map((_ref)=>{\n            let [k, v] = _ref;\n            return [\n                k,\n                walkMap(v, mappingFn, path.concat(k))\n            ];\n        }));\n    }\n    return mappingFn(value, path);\n}\nfunction resolveMapping(resultPath, csm, logger) {\n    var _a;\n    const resultJsonPath = normalisedJsonPath(resultPath);\n    if (!csm.mappings) {\n        (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, \"Missing mappings\", {\n            resultSourceMap: csm\n        });\n        return void 0;\n    }\n    if (csm.mappings[resultJsonPath] !== void 0) {\n        return [\n            csm.mappings[resultJsonPath],\n            resultJsonPath,\n            \"\"\n        ];\n    }\n    const mappings = Object.entries(csm.mappings).filter((_ref2)=>{\n        let [key] = _ref2;\n        return resultJsonPath.startsWith(key);\n    }).sort((_ref3, _ref4)=>{\n        let [key1] = _ref3;\n        let [key2] = _ref4;\n        return key2.length - key1.length;\n    });\n    if (mappings.length == 0) {\n        return void 0;\n    }\n    const [matchedPath, mapping] = mappings[0];\n    const pathSuffix = resultJsonPath.substring(matchedPath.length);\n    return [\n        mapping,\n        matchedPath,\n        pathSuffix\n    ];\n}\n //# sourceMappingURL=sourcemap-r-TuProy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9wcmV2aWV3LWtpdC9kaXN0L19jaHVua3Mvc291cmNlbWFwLXItVHVQcm95LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsTUFBTUEsU0FBUztJQUNiLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLEtBQUs7SUFDTCxLQUFLO0lBQ0wsTUFBTTtBQUNSO0FBQ0EsTUFBTUMsV0FBVztJQUNmLE9BQU87SUFDUCxPQUFPO0lBQ1AsT0FBTztJQUNQLE9BQU87SUFDUCxPQUFPO0lBQ1AsUUFBUTtBQUNWO0FBQ0EsU0FBU0MsbUJBQW1CQyxJQUFJO0lBQzlCLE9BQU8sSUFBSUMsTUFBTSxDQUFDRCxLQUFLRSxHQUFHLENBQUNDLENBQUFBO1FBQ3pCLElBQUksT0FBT0EsUUFBUSxVQUFVO1lBQzNCLE1BQU1DLGFBQWFELElBQUlFLE9BQU8sQ0FBQyxrQkFBa0JDLENBQUFBO2dCQUMvQyxPQUFPVCxNQUFNLENBQUNTLE1BQU07WUFDdEI7WUFDQSxPQUFPLEtBQUtMLE1BQU0sQ0FBQ0csWUFBWTtRQUNqQztRQUNBLE9BQU8sSUFBSUgsTUFBTSxDQUFDRSxLQUFLO0lBQ3pCLEdBQUdJLElBQUksQ0FBQztBQUNWO0FBQ0EsU0FBU0Msd0JBQXdCUixJQUFJO0lBQ25DLE1BQU1TLFNBQVMsRUFBRTtJQUNqQixNQUFNQyxVQUFVO0lBQ2hCLElBQUlKO0lBQ0osTUFBTyxDQUFDQSxRQUFRSSxRQUFRQyxJQUFJLENBQUNYLEtBQUksTUFBTyxLQUFNO1FBQzVDLElBQUlNLEtBQUssQ0FBQyxFQUFFLEtBQUssS0FBSyxHQUFHO1lBQ3ZCLE1BQU1ILE1BQU1HLEtBQUssQ0FBQyxFQUFFLENBQUNELE9BQU8sQ0FBQyxxQkFBcUJPLENBQUFBO2dCQUNoRCxPQUFPZCxRQUFRLENBQUNjLEVBQUU7WUFDcEI7WUFDQUgsT0FBT0ksSUFBSSxDQUFDVjtZQUNaO1FBQ0Y7UUFDQSxJQUFJRyxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUss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QUdxRDtRQUNaLE9BQU9OLGVBQWVPLFVBQVUsQ0FBQ3REO0lBQ25DLEdBQUd1RCxJQUFJLENBQUMsQ0FBQ0MsT0FBT0M7UUFDZCxJQUFJLENBQUNDLEtBQUssR0FBR0Y7UUFDYixJQUFJLENBQUNHLEtBQUssR0FBR0Y7UUFDYixPQUFPRSxLQUFLeEIsTUFBTSxHQUFHdUIsS0FBS3ZCLE1BQU07SUFDbEM7SUFDQSxJQUFJYSxTQUFTYixNQUFNLElBQUksR0FBRztRQUN4QixPQUFPLEtBQUs7SUFDZDtJQUNBLE1BQU0sQ0FBQ3lCLGFBQWFwQyxRQUFRLEdBQUd3QixRQUFRLENBQUMsRUFBRTtJQUMxQyxNQUFNdkIsYUFBYXNCLGVBQWVjLFNBQVMsQ0FBQ0QsWUFBWXpCLE1BQU07SUFDOUQsT0FBTztRQUFDWDtRQUFTb0M7UUFBYW5DO0tBQVc7QUFDM0M7QUFDc0YsQ0FDdEYsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWRhcHRhdGlvbi1pbnNpZ2h0cy8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L3ByZXZpZXcta2l0L2Rpc3QvX2NodW5rcy9zb3VyY2VtYXAtci1UdVByb3kuanM/YjYxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFU0NBUEUgPSB7XG4gIFwiXFxmXCI6IFwiXFxcXGZcIixcbiAgXCJcXG5cIjogXCJcXFxcblwiLFxuICBcIlxcclwiOiBcIlxcXFxyXCIsXG4gIFwiXHRcIjogXCJcXFxcdFwiLFxuICBcIidcIjogXCJcXFxcJ1wiLFxuICBcIlxcXFxcIjogXCJcXFxcXFxcXFwiXG59O1xuY29uc3QgVU5FU0NBUEUgPSB7XG4gIFwiXFxcXGZcIjogXCJcXGZcIixcbiAgXCJcXFxcblwiOiBcIlxcblwiLFxuICBcIlxcXFxyXCI6IFwiXFxyXCIsXG4gIFwiXFxcXHRcIjogXCJcdFwiLFxuICBcIlxcXFwnXCI6IFwiJ1wiLFxuICBcIlxcXFxcXFxcXCI6IFwiXFxcXFwiXG59O1xuZnVuY3Rpb24gbm9ybWFsaXNlZEpzb25QYXRoKHBhdGgpIHtcbiAgcmV0dXJuIFwiJFwiLmNvbmNhdChwYXRoLm1hcChrZXkgPT4ge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBlc2NhcGVkS2V5ID0ga2V5LnJlcGxhY2UoL1tcXGZcXG5cXHJcXHQnXFxcXF0vZywgbWF0Y2ggPT4ge1xuICAgICAgICByZXR1cm4gRVNDQVBFW21hdGNoXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFwiWydcIi5jb25jYXQoZXNjYXBlZEtleSwgXCInXVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiW1wiLmNvbmNhdChrZXksIFwiXVwiKTtcbiAgfSkuam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiBwYXJzZU5vcm1hbGlzZWRKc29uUGF0aChwYXRoKSB7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBjb25zdCBwYXJzZVJlID0gL1xcWycoLio/KSdcXF18XFxbKFxcZCspXFxdL2c7XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IHBhcnNlUmUuZXhlYyhwYXRoKSkgIT09IG51bGwpIHtcbiAgICBpZiAobWF0Y2hbMV0gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV0ucmVwbGFjZSgvXFxcXChcXFxcfGZ8bnxyfHR8JykvZywgbSA9PiB7XG4gICAgICAgIHJldHVybiBVTkVTQ0FQRVttXTtcbiAgICAgIH0pO1xuICAgICAgcGFyc2VkLnB1c2goa2V5KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0gIT09IHZvaWQgMCkge1xuICAgICAgcGFyc2VkLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0sIDEwKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbmZ1bmN0aW9uIGlzUmVjb3JkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGVuY29kZShyZXN1bHQsIGNzbSwgZW5jb2Rlcikge1xuICByZXR1cm4gZW5jb2RlSW50b1Jlc3VsdChyZXN1bHQsIGNzbSwgZW5jb2Rlcik7XG59XG5mdW5jdGlvbiBlbmNvZGVJbnRvUmVzdWx0KHJlc3VsdCwgY3NtLCBlbmNvZGVyKSB7XG4gIHJldHVybiB3YWxrTWFwKHJlc3VsdCwgKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlTWFwcGluZ1Jlc3VsdCA9IHJlc29sdmVNYXBwaW5nKHBhdGgsIGNzbSk7XG4gICAgaWYgKCFyZXNvbHZlTWFwcGluZ1Jlc3VsdCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBbbWFwcGluZywsIHBhdGhTdWZmaXhdID0gcmVzb2x2ZU1hcHBpbmdSZXN1bHQ7XG4gICAgaWYgKG1hcHBpbmcudHlwZSAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChtYXBwaW5nLnNvdXJjZS50eXBlICE9PSBcImRvY3VtZW50VmFsdWVcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VEb2N1bWVudCA9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBjc20uZG9jdW1lbnRzW21hcHBpbmcuc291cmNlLmRvY3VtZW50XTtcbiAgICBjb25zdCBzb3VyY2VQYXRoID0gY3NtLnBhdGhzW21hcHBpbmcuc291cmNlLnBhdGhdO1xuICAgIHJldHVybiBlbmNvZGVyKHZhbHVlLCBzb3VyY2VEb2N1bWVudCwgcGFyc2VOb3JtYWxpc2VkSnNvblBhdGgoc291cmNlUGF0aCArIHBhdGhTdWZmaXgpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB3YWxrTWFwKHZhbHVlLCBtYXBwaW5nRm4pIHtcbiAgbGV0IHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFtdO1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpZHgpID0+IHdhbGtNYXAodiwgbWFwcGluZ0ZuLCBwYXRoLmNvbmNhdChpZHgpKSk7XG4gIH1cbiAgaWYgKGlzUmVjb3JkKHZhbHVlKSkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcChfcmVmID0+IHtcbiAgICAgIGxldCBbaywgdl0gPSBfcmVmO1xuICAgICAgcmV0dXJuIFtrLCB3YWxrTWFwKHYsIG1hcHBpbmdGbiwgcGF0aC5jb25jYXQoaykpXTtcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIG1hcHBpbmdGbih2YWx1ZSwgcGF0aCk7XG59XG5mdW5jdGlvbiByZXNvbHZlTWFwcGluZyhyZXN1bHRQYXRoLCBjc20sIGxvZ2dlcikge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlc3VsdEpzb25QYXRoID0gbm9ybWFsaXNlZEpzb25QYXRoKHJlc3VsdFBhdGgpO1xuICBpZiAoIWNzbS5tYXBwaW5ncykge1xuICAgIChfYSA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChsb2dnZXIsIFwiTWlzc2luZyBtYXBwaW5nc1wiLCB7XG4gICAgICByZXN1bHRTb3VyY2VNYXA6IGNzbVxuICAgIH0pO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKGNzbS5tYXBwaW5nc1tyZXN1bHRKc29uUGF0aF0gIT09IHZvaWQgMCkge1xuICAgIHJldHVybiBbY3NtLm1hcHBpbmdzW3Jlc3VsdEpzb25QYXRoXSwgcmVzdWx0SnNvblBhdGgsIFwiXCJdO1xuICB9XG4gIGNvbnN0IG1hcHBpbmdzID0gT2JqZWN0LmVudHJpZXMoY3NtLm1hcHBpbmdzKS5maWx0ZXIoX3JlZjIgPT4ge1xuICAgIGxldCBba2V5XSA9IF9yZWYyO1xuICAgIHJldHVybiByZXN1bHRKc29uUGF0aC5zdGFydHNXaXRoKGtleSk7XG4gIH0pLnNvcnQoKF9yZWYzLCBfcmVmNCkgPT4ge1xuICAgIGxldCBba2V5MV0gPSBfcmVmMztcbiAgICBsZXQgW2tleTJdID0gX3JlZjQ7XG4gICAgcmV0dXJuIGtleTIubGVuZ3RoIC0ga2V5MS5sZW5ndGg7XG4gIH0pO1xuICBpZiAobWFwcGluZ3MubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IFttYXRjaGVkUGF0aCwgbWFwcGluZ10gPSBtYXBwaW5nc1swXTtcbiAgY29uc3QgcGF0aFN1ZmZpeCA9IHJlc3VsdEpzb25QYXRoLnN1YnN0cmluZyhtYXRjaGVkUGF0aC5sZW5ndGgpO1xuICByZXR1cm4gW21hcHBpbmcsIG1hdGNoZWRQYXRoLCBwYXRoU3VmZml4XTtcbn1cbmV4cG9ydCB7IGVuY29kZSwgZW5jb2RlSW50b1Jlc3VsdCwgcGFyc2VOb3JtYWxpc2VkSnNvblBhdGgsIHJlc29sdmVNYXBwaW5nLCB3YWxrTWFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3VyY2VtYXAtci1UdVByb3kuanMubWFwXG4iXSwibmFtZXMiOlsiRVNDQVBFIiwiVU5FU0NBUEUiLCJub3JtYWxpc2VkSnNvblBhdGgiLCJwYXRoIiwiY29uY2F0IiwibWFwIiwia2V5IiwiZXNjYXBlZEtleSIsInJlcGxhY2UiLCJtYXRjaCIsImpvaW4iLCJwYXJzZU5vcm1hbGlzZWRKc29uUGF0aCIsInBhcnNlZCIsInBhcnNlUmUiLCJleGVjIiwibSIsInB1c2giLCJwYXJzZUludCIsImlzUmVjb3JkIiwidmFsdWUiLCJpc0FycmF5IiwiQXJyYXkiLCJlbmNvZGUiLCJyZXN1bHQiLCJjc20iLCJlbmNvZGVyIiwiZW5jb2RlSW50b1Jlc3VsdCIsIndhbGtNYXAiLCJyZXNvbHZlTWFwcGluZ1Jlc3VsdCIsInJlc29sdmVNYXBwaW5nIiwibWFwcGluZyIsInBhdGhTdWZmaXgiLCJ0eXBlIiwic291cmNlIiwic291cmNlRG9jdW1lbnQiLCJkb2N1bWVudHMiLCJkb2N1bWVudCIsInNvdXJjZVBhdGgiLCJwYXRocyIsIm1hcHBpbmdGbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInYiLCJpZHgiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJfcmVmIiwiayIsInJlc3VsdFBhdGgiLCJsb2dnZXIiLCJfYSIsInJlc3VsdEpzb25QYXRoIiwibWFwcGluZ3MiLCJlcnJvciIsImNhbGwiLCJyZXN1bHRTb3VyY2VNYXAiLCJmaWx0ZXIiLCJfcmVmMiIsInN0YXJ0c1dpdGgiLCJzb3J0IiwiX3JlZjMiLCJfcmVmNCIsImtleTEiLCJrZXkyIiwibWF0Y2hlZFBhdGgiLCJzdWJzdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/preview-kit/dist/_chunks/sourcemap-r-TuProy.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/preview-kit/dist/client.js":
/*!*********************************************************!*\
  !*** ./node_modules/@sanity/preview-kit/dist/client.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   mapToEditLinks: () => (/* binding */ mapToEditLinks)\n/* harmony export */ });\n/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @sanity/client */ \"(rsc)/./node_modules/@sanity/client/dist/index.browser.js\");\n/* harmony import */ var lodash_isplainobject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash.isplainobject */ \"(rsc)/./node_modules/lodash.isplainobject/index.js\");\n/* harmony import */ var _csm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./csm.js */ \"(rsc)/./node_modules/@sanity/preview-kit/dist/csm.js\");\n\n\n\nfunction transcodeResponse(_ref) {\n    let { studioUrl, encodeSourceMapAtPath, logger } = _ref;\n    const transcoder = (0,_csm_js__WEBPACK_IMPORTED_MODULE_1__.createTranscoder)({\n        studioUrl,\n        encodeSourceMapAtPath,\n        logger\n    });\n    return {\n        onResponse: (response)=>{\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (!isBodyResponse(response)) {\n                return response;\n            }\n            if (Array.isArray(response.body) || typeof response.body === \"string\" || lodash_isplainobject__WEBPACK_IMPORTED_MODULE_0__(response.body)) {\n                if (!isContentSourceMapBody(response.body)) {\n                    if (logger && isResultBody(response.body)) {\n                        (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, \"[@sanity/preview-kit]: Missing Content Source Map from response body\", response.body);\n                    }\n                    return response;\n                }\n                const transcoderResult = transcoder(response.body.result, response.body.resultSourceMap);\n                if (logger) {\n                    const isSkipping = transcoderResult.report.skipped.length;\n                    const isEncoding = transcoderResult.report.encoded.length;\n                    if (isSkipping || isEncoding) {\n                        (_b = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null ? void 0 : _b(\"[@sanity/preview-kit]: Stega encoding source map into result\");\n                        (_c = logger.log) == null ? void 0 : _c.call(logger, \"[@sanity/preview-kit]: Paths encoded: \".concat(transcoderResult.report.encoded.length, \", skipped: \").concat(transcoderResult.report.skipped.length));\n                    }\n                    if (transcoderResult.report.encoded.length > 0) {\n                        (_d = logger == null ? void 0 : logger.log) == null ? void 0 : _d.call(logger, \"[@sanity/preview-kit]: Table of encoded paths\");\n                        (_e = (logger == null ? void 0 : logger.table) || logger.log) == null ? void 0 : _e(transcoderResult.report.encoded);\n                    }\n                    if (transcoderResult.report.skipped.length > 0) {\n                        const skipped = /* @__PURE__ */ new Set();\n                        for (const { path } of transcoderResult.report.skipped){\n                            skipped.add(path.replace(/\\[\\d+\\]/g, \"[]\"));\n                        }\n                        (_f = logger == null ? void 0 : logger.log) == null ? void 0 : _f.call(logger, \"[@sanity/preview-kit]: List of skipped paths\", [\n                            ...skipped.values()\n                        ]);\n                    }\n                    if (isSkipping || isEncoding) {\n                        (_g = logger == null ? void 0 : logger.groupEnd) == null ? void 0 : _g.call(logger);\n                    }\n                }\n                const body = {\n                    ...response.body,\n                    result: transcoderResult.result\n                };\n                return {\n                    ...response,\n                    body\n                };\n            }\n            return response;\n        }\n    };\n}\nfunction createHttpRequest(_ref2) {\n    let { studioUrl, encodeSourceMapAtPath, logger } = _ref2;\n    const superRequester = _sanity_client__WEBPACK_IMPORTED_MODULE_2__.requester.clone();\n    superRequester.use(// eslint-disable-next-line @typescript-eslint/no-explicit-any -- support the improved get-it typings\n    transcodeResponse({\n        studioUrl,\n        encodeSourceMapAtPath,\n        logger\n    }));\n    function httpRequest(options) {\n        let requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : superRequester;\n        return requester({\n            maxRedirects: 0,\n            ...options\n        });\n    }\n    httpRequest.defaultRequester = superRequester;\n    return httpRequest;\n}\nfunction isBodyResponse(response) {\n    return typeof response === \"object\" && response !== null;\n}\nfunction isResultBody(body) {\n    return typeof body === \"object\" && body !== null && \"result\" in body;\n}\nfunction isContentSourceMapBody(body) {\n    return typeof body === \"object\" && body !== null && \"resultSourceMap\" in body;\n}\nconst createClient = (config)=>{\n    var _a, _b;\n    const { encodeSourceMap = detectEnableSourceMap(), encodeSourceMapAtPath, studioUrl = detectStudioUrl(), logger, ...options } = config;\n    let shouldEncodeSourceMap = encodeSourceMap === true;\n    if (encodeSourceMap === \"auto\") {\n        shouldEncodeSourceMap = isVercelPreviewEnvironment();\n    }\n    if (typeof encodeSourceMap === \"string\" && encodeSourceMap !== \"auto\") {\n        throw new Error(\"Invalid value for encodeSourceMap: \".concat(encodeSourceMap, \". Did you mean 'auto'?\"));\n    }\n    try {\n        if (shouldEncodeSourceMap && config.resultSourceMap !== false) {\n            if (!studioUrl) {\n                (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, \"[@sanity/preview-kit]: Content source map enabled client is enabled, but no studioUrl is provided. Falling back to @sanity/client\");\n                return (0,_sanity_client__WEBPACK_IMPORTED_MODULE_2__.createClient)(options);\n            }\n            (_b = logger == null ? void 0 : logger.debug) == null ? void 0 : _b.call(logger, \"[@sanity/preview-kit]: Creating source map enabled client\");\n            const httpRequest = createHttpRequest({\n                encodeSourceMapAtPath,\n                studioUrl,\n                logger\n            });\n            return new _sanity_client__WEBPACK_IMPORTED_MODULE_2__.SanityClient(httpRequest, {\n                ...options,\n                // Source maps by Content Lake are required in order to know where to insert the encoded source maps into strings\n                resultSourceMap: true\n            });\n        }\n    } catch (err) {\n        console.error(\"[@sanity/preview-kit]: Error creating client\", err, \"falling back to non-embedded sourcemap mode\");\n    }\n    return (0,_sanity_client__WEBPACK_IMPORTED_MODULE_2__.createClient)(options);\n};\nfunction isVercelPreviewEnvironment() {\n    try {\n        return /* unsupported import.meta.env.VERCEL_ENV */ undefined.VERCEL_ENV === \"preview\";\n    } catch  {}\n    try {\n        return process.env.VERCEL_ENV === \"preview\";\n    } catch  {}\n    return false;\n}\nfunction detectEnableSourceMap() {\n    try {\n        return /* unsupported import.meta.env.SANITY_SOURCE_MAP */ undefined.SANITY_SOURCE_MAP === \"true\" || \"auto\";\n    } catch  {}\n    try {\n        return process.env.SANITY_SOURCE_MAP === \"true\" || \"auto\";\n    } catch  {}\n    return \"auto\";\n}\nfunction detectStudioUrl() {\n    try {\n        return /* unsupported import.meta.env.SANITY_STUDIO_URL */ undefined.SANITY_STUDIO_URL;\n    } catch  {}\n    try {\n        return process.env.SANITY_STUDIO_URL;\n    } catch  {}\n}\nfunction mapToEditLinks(response, studioUrl) {\n    return (0,_csm_js__WEBPACK_IMPORTED_MODULE_1__.mapToEditLinks)(response.result, response.resultSourceMap, studioUrl);\n}\n //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9wcmV2aWV3LWtpdC9kaXN0L2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5RjtBQUN4QztBQUMrQjtBQUNoRixTQUFTUSxrQkFBa0JDLElBQUk7SUFDN0IsSUFBSSxFQUNGQyxTQUFTLEVBQ1RDLHFCQUFxQixFQUNyQkMsTUFBTSxFQUNQLEdBQUdIO0lBQ0osTUFBTUksYUFBYVIseURBQWdCQSxDQUFDO1FBQ2xDSztRQUNBQztRQUNBQztJQUNGO0lBQ0EsT0FBTztRQUNMRSxZQUFZQyxDQUFBQTtZQUNWLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1lBQzVCLElBQUksQ0FBQ0MsZUFBZVIsV0FBVztnQkFDN0IsT0FBT0E7WUFDVDtZQUNBLElBQUlTLE1BQU1DLE9BQU8sQ0FBQ1YsU0FBU1csSUFBSSxLQUFLLE9BQU9YLFNBQVNXLElBQUksS0FBSyxZQUFZdEIsaURBQWFBLENBQUNXLFNBQVNXLElBQUksR0FBRztnQkFDckcsSUFBSSxDQUFDQyx1QkFBdUJaLFNBQVNXLElBQUksR0FBRztvQkFDMUMsSUFBSWQsVUFBVWdCLGFBQWFiLFNBQVNXLElBQUksR0FBRzt3QkFDeENWLENBQUFBLEtBQUtKLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU9pQixLQUFLLEtBQUssT0FBTyxLQUFLLElBQUliLEdBQUdjLElBQUksQ0FBQ2xCLFFBQVEsd0VBQXdFRyxTQUFTVyxJQUFJO29CQUN4SztvQkFDQSxPQUFPWDtnQkFDVDtnQkFDQSxNQUFNZ0IsbUJBQW1CbEIsV0FBV0UsU0FBU1csSUFBSSxDQUFDTSxNQUFNLEVBQUVqQixTQUFTVyxJQUFJLENBQUNPLGVBQWU7Z0JBQ3ZGLElBQUlyQixRQUFRO29CQUNWLE1BQU1zQixhQUFhSCxpQkFBaUJJLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDQyxNQUFNO29CQUN6RCxNQUFNQyxhQUFhUCxpQkFBaUJJLE1BQU0sQ0FBQ0ksT0FBTyxDQUFD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T0FBT25FLDREQUFjQSxDQUFDc0Q7QUFDeEI7QUFDQSxTQUFTVTtJQUNQLElBQUk7UUFDRixPQUFPLGlFQUEwQixLQUFLO0lBQ3hDLEVBQUUsT0FBTSxDQUFDO0lBQ1QsSUFBSTtRQUNGLE9BQU9PLFFBQVFGLEdBQUcsQ0FBQ0MsVUFBVSxLQUFLO0lBQ3BDLEVBQUUsT0FBTSxDQUFDO0lBQ1QsT0FBTztBQUNUO0FBQ0EsU0FBU1Q7SUFDUCxJQUFJO1FBQ0YsT0FBTywrRUFBaUMsS0FBSyxVQUFVO0lBQ3pELEVBQUUsT0FBTSxDQUFDO0lBQ1QsSUFBSTtRQUNGLE9BQU9VLFFBQVFGLEdBQUcsQ0FBQ0csaUJBQWlCLEtBQUssVUFBVTtJQUNyRCxFQUFFLE9BQU0sQ0FBQztJQUNULE9BQU87QUFDVDtBQUNBLFNBQVNWO0lBQ1AsSUFBSTtRQUNGLE9BQU8sK0VBQWlDO0lBQzFDLEVBQUUsT0FBTSxDQUFDO0lBQ1QsSUFBSTtRQUNGLE9BQU9TLFFBQVFGLEdBQUcsQ0FBQ0ksaUJBQWlCO0lBQ3RDLEVBQUUsT0FBTSxDQUFDO0FBQ1g7QUFDQSxTQUFTckUsZUFBZVMsUUFBUSxFQUFFTCxTQUFTO0lBQ3pDLE9BQU9ILHVEQUFnQkEsQ0FBQ1EsU0FBU2lCLE1BQU0sRUFBRWpCLFNBQVNrQixlQUFlLEVBQUV2QjtBQUNyRTtBQUN3QyxDQUN4QyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZGFwdGF0aW9uLWluc2lnaHRzLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvcHJldmlldy1raXQvZGlzdC9jbGllbnQuanM/ZGVjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXF1ZXN0ZXIsIGNyZWF0ZUNsaWVudCBhcyBjcmVhdGVDbGllbnQkMSwgU2FuaXR5Q2xpZW50IH0gZnJvbSAnQHNhbml0eS9jbGllbnQnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLmlzcGxhaW5vYmplY3QnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNjb2RlciwgbWFwVG9FZGl0TGlua3MgYXMgbWFwVG9FZGl0TGlua3MkMSB9IGZyb20gJy4vY3NtLmpzJztcbmZ1bmN0aW9uIHRyYW5zY29kZVJlc3BvbnNlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzdHVkaW9VcmwsXG4gICAgZW5jb2RlU291cmNlTWFwQXRQYXRoLFxuICAgIGxvZ2dlclxuICB9ID0gX3JlZjtcbiAgY29uc3QgdHJhbnNjb2RlciA9IGNyZWF0ZVRyYW5zY29kZXIoe1xuICAgIHN0dWRpb1VybCxcbiAgICBlbmNvZGVTb3VyY2VNYXBBdFBhdGgsXG4gICAgbG9nZ2VyXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IHJlc3BvbnNlID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgIGlmICghaXNCb2R5UmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlLmJvZHkpIHx8IHR5cGVvZiByZXNwb25zZS5ib2R5ID09PSBcInN0cmluZ1wiIHx8IGlzUGxhaW5PYmplY3QocmVzcG9uc2UuYm9keSkpIHtcbiAgICAgICAgaWYgKCFpc0NvbnRlbnRTb3VyY2VNYXBCb2R5KHJlc3BvbnNlLmJvZHkpKSB7XG4gICAgICAgICAgaWYgKGxvZ2dlciAmJiBpc1Jlc3VsdEJvZHkocmVzcG9uc2UuYm9keSkpIHtcbiAgICAgICAgICAgIChfYSA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChsb2dnZXIsIFwiW0BzYW5pdHkvcHJldmlldy1raXRdOiBNaXNzaW5nIENvbnRlbnQgU291cmNlIE1hcCBmcm9tIHJlc3BvbnNlIGJvZHlcIiwgcmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2NvZGVyUmVzdWx0ID0gdHJhbnNjb2RlcihyZXNwb25zZS5ib2R5LnJlc3VsdCwgcmVzcG9uc2UuYm9keS5yZXN1bHRTb3VyY2VNYXApO1xuICAgICAgICBpZiAobG9nZ2VyKSB7XG4gICAgICAgICAgY29uc3QgaXNTa2lwcGluZyA9IHRyYW5zY29kZXJSZXN1bHQucmVwb3J0LnNraXBwZWQubGVuZ3RoO1xuICAgICAgICAgIGNvbnN0IGlzRW5jb2RpbmcgPSB0cmFuc2NvZGVyUmVzdWx0LnJlcG9ydC5lbmNvZGVkLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaXNTa2lwcGluZyB8fCBpc0VuY29kaW5nKSB7XG4gICAgICAgICAgICAoX2IgPSAobG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQpIHx8IGxvZ2dlci5sb2cpID09IG51bGwgPyB2b2lkIDAgOiBfYihcIltAc2FuaXR5L3ByZXZpZXcta2l0XTogU3RlZ2EgZW5jb2Rpbmcgc291cmNlIG1hcCBpbnRvIHJlc3VsdFwiKTtcbiAgICAgICAgICAgIChfYyA9IGxvZ2dlci5sb2cpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKGxvZ2dlciwgXCJbQHNhbml0eS9wcmV2aWV3LWtpdF06IFBhdGhzIGVuY29kZWQ6IFwiLmNvbmNhdCh0cmFuc2NvZGVyUmVzdWx0LnJlcG9ydC5lbmNvZGVkLmxlbmd0aCwgXCIsIHNraXBwZWQ6IFwiKS5jb25jYXQodHJhbnNjb2RlclJlc3VsdC5yZXBvcnQuc2tpcHBlZC5sZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRyYW5zY29kZXJSZXN1bHQucmVwb3J0LmVuY29kZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgKF9kID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIubG9nKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY2FsbChsb2dnZXIsIFwiW0BzYW5pdHkvcHJldmlldy1raXRdOiBUYWJsZSBvZiBlbmNvZGVkIHBhdGhzXCIpO1xuICAgICAgICAgICAgKF9lID0gKGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLnRhYmxlKSB8fCBsb2dnZXIubG9nKSA9PSBudWxsID8gdm9pZCAwIDogX2UodHJhbnNjb2RlclJlc3VsdC5yZXBvcnQuZW5jb2RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0cmFuc2NvZGVyUmVzdWx0LnJlcG9ydC5za2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHNraXBwZWQgPSAvKiBAX19QVVJFX18gKi9uZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgICAgcGF0aFxuICAgICAgICAgICAgfSBvZiB0cmFuc2NvZGVyUmVzdWx0LnJlcG9ydC5za2lwcGVkKSB7XG4gICAgICAgICAgICAgIHNraXBwZWQuYWRkKHBhdGgucmVwbGFjZSgvXFxbXFxkK1xcXS9nLCBcIltdXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfZiA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmxvZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmNhbGwobG9nZ2VyLCBcIltAc2FuaXR5L3ByZXZpZXcta2l0XTogTGlzdCBvZiBza2lwcGVkIHBhdGhzXCIsIFsuLi5za2lwcGVkLnZhbHVlcygpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1NraXBwaW5nIHx8IGlzRW5jb2RpbmcpIHtcbiAgICAgICAgICAgIChfZyA9IGxvZ2dlciA9PSBudWxsID8gdm9pZCAwIDogbG9nZ2VyLmdyb3VwRW5kKSA9PSBudWxsID8gdm9pZCAwIDogX2cuY2FsbChsb2dnZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgIC4uLnJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgcmVzdWx0OiB0cmFuc2NvZGVyUmVzdWx0LnJlc3VsdFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIdHRwUmVxdWVzdChfcmVmMikge1xuICBsZXQge1xuICAgIHN0dWRpb1VybCxcbiAgICBlbmNvZGVTb3VyY2VNYXBBdFBhdGgsXG4gICAgbG9nZ2VyXG4gIH0gPSBfcmVmMjtcbiAgY29uc3Qgc3VwZXJSZXF1ZXN0ZXIgPSByZXF1ZXN0ZXIuY2xvbmUoKTtcbiAgc3VwZXJSZXF1ZXN0ZXIudXNlKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBzdXBwb3J0IHRoZSBpbXByb3ZlZCBnZXQtaXQgdHlwaW5nc1xuICB0cmFuc2NvZGVSZXNwb25zZSh7XG4gICAgc3R1ZGlvVXJsLFxuICAgIGVuY29kZVNvdXJjZU1hcEF0UGF0aCxcbiAgICBsb2dnZXJcbiAgfSkpO1xuICBmdW5jdGlvbiBodHRwUmVxdWVzdChvcHRpb25zKSB7XG4gICAgbGV0IHJlcXVlc3RlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogc3VwZXJSZXF1ZXN0ZXI7XG4gICAgcmV0dXJuIHJlcXVlc3Rlcih7XG4gICAgICBtYXhSZWRpcmVjdHM6IDAsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgaHR0cFJlcXVlc3QuZGVmYXVsdFJlcXVlc3RlciA9IHN1cGVyUmVxdWVzdGVyO1xuICByZXR1cm4gaHR0cFJlcXVlc3Q7XG59XG5mdW5jdGlvbiBpc0JvZHlSZXNwb25zZShyZXNwb25zZSkge1xuICByZXR1cm4gdHlwZW9mIHJlc3BvbnNlID09PSBcIm9iamVjdFwiICYmIHJlc3BvbnNlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNSZXN1bHRCb2R5KGJvZHkpIHtcbiAgcmV0dXJuIHR5cGVvZiBib2R5ID09PSBcIm9iamVjdFwiICYmIGJvZHkgIT09IG51bGwgJiYgXCJyZXN1bHRcIiBpbiBib2R5O1xufVxuZnVuY3Rpb24gaXNDb250ZW50U291cmNlTWFwQm9keShib2R5KSB7XG4gIHJldHVybiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBib2R5ICE9PSBudWxsICYmIFwicmVzdWx0U291cmNlTWFwXCIgaW4gYm9keTtcbn1cbmNvbnN0IGNyZWF0ZUNsaWVudCA9IGNvbmZpZyA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHtcbiAgICBlbmNvZGVTb3VyY2VNYXAgPSBkZXRlY3RFbmFibGVTb3VyY2VNYXAoKSxcbiAgICBlbmNvZGVTb3VyY2VNYXBBdFBhdGgsXG4gICAgc3R1ZGlvVXJsID0gZGV0ZWN0U3R1ZGlvVXJsKCksXG4gICAgbG9nZ2VyLFxuICAgIC4uLm9wdGlvbnNcbiAgfSA9IGNvbmZpZztcbiAgbGV0IHNob3VsZEVuY29kZVNvdXJjZU1hcCA9IGVuY29kZVNvdXJjZU1hcCA9PT0gdHJ1ZTtcbiAgaWYgKGVuY29kZVNvdXJjZU1hcCA9PT0gXCJhdXRvXCIpIHtcbiAgICBzaG91bGRFbmNvZGVTb3VyY2VNYXAgPSBpc1ZlcmNlbFByZXZpZXdFbnZpcm9ubWVudCgpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RlU291cmNlTWFwID09PSBcInN0cmluZ1wiICYmIGVuY29kZVNvdXJjZU1hcCAhPT0gXCJhdXRvXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBlbmNvZGVTb3VyY2VNYXA6IFwiLmNvbmNhdChlbmNvZGVTb3VyY2VNYXAsIFwiLiBEaWQgeW91IG1lYW4gJ2F1dG8nP1wiKSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAoc2hvdWxkRW5jb2RlU291cmNlTWFwICYmIGNvbmZpZy5yZXN1bHRTb3VyY2VNYXAgIT09IGZhbHNlKSB7XG4gICAgICBpZiAoIXN0dWRpb1VybCkge1xuICAgICAgICAoX2EgPSBsb2dnZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGxvZ2dlci5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwobG9nZ2VyLCBcIltAc2FuaXR5L3ByZXZpZXcta2l0XTogQ29udGVudCBzb3VyY2UgbWFwIGVuYWJsZWQgY2xpZW50IGlzIGVuYWJsZWQsIGJ1dCBubyBzdHVkaW9VcmwgaXMgcHJvdmlkZWQuIEZhbGxpbmcgYmFjayB0byBAc2FuaXR5L2NsaWVudFwiKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNsaWVudCQxKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgKF9iID0gbG9nZ2VyID09IG51bGwgPyB2b2lkIDAgOiBsb2dnZXIuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKGxvZ2dlciwgXCJbQHNhbml0eS9wcmV2aWV3LWtpdF06IENyZWF0aW5nIHNvdXJjZSBtYXAgZW5hYmxlZCBjbGllbnRcIik7XG4gICAgICBjb25zdCBodHRwUmVxdWVzdCA9IGNyZWF0ZUh0dHBSZXF1ZXN0KHtcbiAgICAgICAgZW5jb2RlU291cmNlTWFwQXRQYXRoLFxuICAgICAgICBzdHVkaW9VcmwsXG4gICAgICAgIGxvZ2dlclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFNhbml0eUNsaWVudChodHRwUmVxdWVzdCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAvLyBTb3VyY2UgbWFwcyBieSBDb250ZW50IExha2UgYXJlIHJlcXVpcmVkIGluIG9yZGVyIHRvIGtub3cgd2hlcmUgdG8gaW5zZXJ0IHRoZSBlbmNvZGVkIHNvdXJjZSBtYXBzIGludG8gc3RyaW5nc1xuICAgICAgICByZXN1bHRTb3VyY2VNYXA6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltAc2FuaXR5L3ByZXZpZXcta2l0XTogRXJyb3IgY3JlYXRpbmcgY2xpZW50XCIsIGVyciwgXCJmYWxsaW5nIGJhY2sgdG8gbm9uLWVtYmVkZGVkIHNvdXJjZW1hcCBtb2RlXCIpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDbGllbnQkMShvcHRpb25zKTtcbn07XG5mdW5jdGlvbiBpc1ZlcmNlbFByZXZpZXdFbnZpcm9ubWVudCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaW1wb3J0Lm1ldGEuZW52LlZFUkNFTF9FTlYgPT09IFwicHJldmlld1wiO1xuICB9IGNhdGNoIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LlZFUkNFTF9FTlYgPT09IFwicHJldmlld1wiO1xuICB9IGNhdGNoIHt9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRldGVjdEVuYWJsZVNvdXJjZU1hcCgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaW1wb3J0Lm1ldGEuZW52LlNBTklUWV9TT1VSQ0VfTUFQID09PSBcInRydWVcIiB8fCBcImF1dG9cIjtcbiAgfSBjYXRjaCB7fVxuICB0cnkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5TQU5JVFlfU09VUkNFX01BUCA9PT0gXCJ0cnVlXCIgfHwgXCJhdXRvXCI7XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuIFwiYXV0b1wiO1xufVxuZnVuY3Rpb24gZGV0ZWN0U3R1ZGlvVXJsKCkge1xuICB0cnkge1xuICAgIHJldHVybiBpbXBvcnQubWV0YS5lbnYuU0FOSVRZX1NUVURJT19VUkw7XG4gIH0gY2F0Y2gge31cbiAgdHJ5IHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuU0FOSVRZX1NUVURJT19VUkw7XG4gIH0gY2F0Y2gge31cbn1cbmZ1bmN0aW9uIG1hcFRvRWRpdExpbmtzKHJlc3BvbnNlLCBzdHVkaW9VcmwpIHtcbiAgcmV0dXJuIG1hcFRvRWRpdExpbmtzJDEocmVzcG9uc2UucmVzdWx0LCByZXNwb25zZS5yZXN1bHRTb3VyY2VNYXAsIHN0dWRpb1VybCk7XG59XG5leHBvcnQgeyBjcmVhdGVDbGllbnQsIG1hcFRvRWRpdExpbmtzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwXG4iXSwibmFtZXMiOlsicmVxdWVzdGVyIiwiY3JlYXRlQ2xpZW50IiwiY3JlYXRlQ2xpZW50JDEiLCJTYW5pdHlDbGllbnQiLCJpc1BsYWluT2JqZWN0IiwiY3JlYXRlVHJhbnNjb2RlciIsIm1hcFRvRWRpdExpbmtzIiwibWFwVG9FZGl0TGlua3MkMSIsInRyYW5zY29kZVJlc3BvbnNlIiwiX3JlZiIsInN0dWRpb1VybCIsImVuY29kZVNvdXJjZU1hcEF0UGF0aCIsImxvZ2dlciIsInRyYW5zY29kZXIiLCJvblJlc3BvbnNlIiwicmVzcG9uc2UiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsImlzQm9keVJlc3BvbnNlIiwiQXJyYXkiLCJpc0FycmF5IiwiYm9keSIsImlzQ29udGVudFNvdXJjZU1hcEJvZHkiLCJpc1Jlc3VsdEJvZHkiLCJlcnJvciIsImNhbGwiLCJ0cmFuc2NvZGVyUmVzdWx0IiwicmVzdWx0IiwicmVzdWx0U291cmNlTWFwIiwiaXNTa2lwcGluZyIsInJlcG9ydCIsInNraXBwZWQiLCJsZW5ndGgiLCJpc0VuY29kaW5nIiwiZW5jb2RlZCIsImdyb3VwQ29sbGFwc2VkIiwibG9nIiwiY29uY2F0IiwidGFibGUiLCJTZXQiLCJwYXRoIiwiYWRkIiwicmVwbGFjZSIsInZhbHVlcyIsImdyb3VwRW5kIiwiY3JlYXRlSHR0cFJlcXVlc3QiLCJfcmVmMiIsInN1cGVyUmVxdWVzdGVyIiwiY2xvbmUiLCJ1c2UiLCJodHRwUmVxdWVzdCIsIm9wdGlvbnMiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJtYXhSZWRpcmVjdHMiLCJkZWZhdWx0UmVxdWVzdGVyIiwiY29uZmlnIiwiZW5jb2RlU291cmNlTWFwIiwiZGV0ZWN0RW5hYmxlU291cmNlTWFwIiwiZGV0ZWN0U3R1ZGlvVXJsIiwic2hvdWxkRW5jb2RlU291cmNlTWFwIiwiaXNWZXJjZWxQcmV2aWV3RW52aXJvbm1lbnQiLCJFcnJvciIsImRlYnVnIiwiZXJyIiwiY29uc29sZSIsImVudiIsIlZFUkNFTF9FTlYiLCJwcm9jZXNzIiwiU0FOSVRZX1NPVVJDRV9NQVAiLCJTQU5JVFlfU1RVRElPX1VSTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/preview-kit/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@sanity/preview-kit/dist/csm.js":
/*!******************************************************!*\
  !*** ./node_modules/@sanity/preview-kit/dist/csm.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTranscoder: () => (/* binding */ createTranscoder),\n/* harmony export */   encodeJsonPathToUriComponent: () => (/* binding */ encodeJsonPathToUriComponent),\n/* harmony export */   mapToEditLinks: () => (/* binding */ mapToEditLinks),\n/* harmony export */   parseNormalisedJsonPath: () => (/* reexport safe */ _chunks_sourcemap_r_TuProy_js__WEBPACK_IMPORTED_MODULE_0__.parseNormalisedJsonPath),\n/* harmony export */   resolveMapping: () => (/* reexport safe */ _chunks_sourcemap_r_TuProy_js__WEBPACK_IMPORTED_MODULE_0__.resolveMapping),\n/* harmony export */   walkMap: () => (/* reexport safe */ _chunks_sourcemap_r_TuProy_js__WEBPACK_IMPORTED_MODULE_0__.walkMap)\n/* harmony export */ });\n/* harmony import */ var _chunks_sourcemap_r_TuProy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_chunks/sourcemap-r-TuProy.js */ \"(rsc)/./node_modules/@sanity/preview-kit/dist/_chunks/sourcemap-r-TuProy.js\");\n/* harmony import */ var _vercel_stega__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vercel/stega */ \"(rsc)/./node_modules/@vercel/stega/dist/index.mjs\");\n\n\n\nfunction defineEditLink(_studioUrl) {\n    const studioUrl = _studioUrl.replace(/\\/$/, \"\");\n    return (sourceDocument, path)=>\"\".concat(studioUrl, \"/intent/edit/id=\").concat(sourceDocument._id, \";\").concat(sourceDocument._type ? \"type=\".concat(sourceDocument._type, \";\") : \"\", \"path=\").concat(encodeJsonPathToUriComponent(path));\n}\nfunction encodeJsonPathToUriComponent(path) {\n    const sourcePath = Array.isArray(path) ? path : (0,_chunks_sourcemap_r_TuProy_js__WEBPACK_IMPORTED_MODULE_0__.parseNormalisedJsonPath)(path);\n    return encodeURIComponent(sourcePath.map((key, i)=>// eslint-disable-next-line no-nested-ternary\n        typeof key === \"number\" ? \"[\".concat(key, \"]\") : i > 0 ? \".\".concat(key) : key).join(\"\"));\n}\nconst filterDefault = (_ref)=>{\n    let { path } = _ref;\n    const endPath = path.at(-1);\n    if (path.at(-2) === \"slug\" && endPath === \"current\") {\n        return false;\n    }\n    if (typeof endPath === \"string\" && endPath.startsWith(\"_\")) {\n        return false;\n    }\n    if (typeof endPath === \"number\" && path.at(-2) === \"marks\" && typeof path.at(-3) === \"number\" && path.at(-4) === \"children\" && typeof path.at(-5) === \"number\") {\n        return false;\n    }\n    if (endPath === \"href\" && typeof path.at(-2) === \"number\" && path.at(-3) === \"markDefs\" && typeof path.at(-4) === \"number\") {\n        return false;\n    }\n    if (typeof endPath === \"string\" && typeof path.at(-2) === \"number\") {\n        if (endPath === \"style\" || endPath === \"listItem\") {\n            return false;\n        }\n    }\n    return true;\n};\nconst TRUNCATE_LENGTH = 20;\nfunction createTranscoder(config) {\n    const { studioUrl, encodeSourceMapAtPath, logger } = config;\n    const createEditLink = defineEditLink(studioUrl);\n    const report = {\n        encoded: [],\n        skipped: []\n    };\n    const transcode = (input, sourceDocument, sourcePath)=>{\n        if ((typeof encodeSourceMapAtPath === \"function\" ? encodeSourceMapAtPath({\n            path: sourcePath,\n            filterDefault\n        }) : filterDefault({\n            path: sourcePath,\n            filterDefault\n        })) === false) {\n            if (logger) {\n                report.skipped.push({\n                    path: prettyPathForLogging(sourcePath),\n                    value: \"\".concat(input.slice(0, TRUNCATE_LENGTH)).concat(input.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n                    length: input.length\n                });\n            }\n            return input;\n        }\n        if (logger) {\n            report.encoded.push({\n                path: prettyPathForLogging(sourcePath),\n                value: \"\".concat(input.slice(0, TRUNCATE_LENGTH)).concat(input.length > TRUNCATE_LENGTH ? \"...\" : \"\"),\n                length: input.length\n            });\n        }\n        return (0,_vercel_stega__WEBPACK_IMPORTED_MODULE_1__.vercelStegaCombine)(input, {\n            origin: \"sanity.io\",\n            href: createEditLink(sourceDocument, sourcePath)\n        }, \"auto\");\n    };\n    return (result, csm)=>{\n        report.encoded.length = 0;\n        report.skipped.length = 0;\n        return {\n            result: (0,_chunks_sourcemap_r_TuProy_js__WEBPACK_IMPORTED_MODULE_0__.encode)(result, csm, (value, sourceDocument, path)=>transcode(value, sourceDocument, path)),\n            report\n        };\n    };\n}\nfunction prettyPathForLogging(path) {\n    return path.map((segment, index)=>typeof segment === \"number\" ? \"[\".concat(segment, \"]\") : index > 0 ? \".\".concat(segment) : segment).join(\"\");\n}\nfunction mapToEditLinks(result, csm, studioUrl) {\n    const createEditLink = defineEditLink(studioUrl);\n    return (0,_chunks_sourcemap_r_TuProy_js__WEBPACK_IMPORTED_MODULE_0__.encodeIntoResult)(result, csm, (_, sourceDocument, path)=>{\n        return createEditLink(sourceDocument, path);\n    });\n}\n //# sourceMappingURL=csm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9wcmV2aWV3LWtpdC9kaXN0L2NzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFvRztBQUMxQjtBQUN2QjtBQUNuRCxTQUFTTSxlQUFlQyxVQUFVO0lBQ2hDLE1BQU1DLFlBQVlELFdBQVdFLE9BQU8sQ0FBQyxPQUFPO0lBQzVDLE9BQU8sQ0FBQ0MsZ0JBQWdCQyxPQUFTLEdBQUdDLE1BQU0sQ0FBQ0osV0FBVyxvQkFBb0JJLE1BQU0sQ0FBQ0YsZUFBZUcsR0FBRyxFQUFFLEtBQUtELE1BQU0sQ0FBQ0YsZUFBZUksS0FBSyxHQUFHLFFBQVFGLE1BQU0sQ0FBQ0YsZUFBZUksS0FBSyxFQUFFLE9BQU8sSUFBSSxTQUFTRixNQUFNLENBQUNHLDZCQUE2Qko7QUFDdk87QUFDQSxTQUFTSSw2QkFBNkJKLElBQUk7SUFDeEMsTUFBTUssYUFBYUMsTUFBTUMsT0FBTyxDQUFDUCxRQUFRQSxPQUFPWCxzRkFBdUJBLENBQUNXO0lBQ3hFLE9BQU9RLG1CQUFtQkgsV0FBV0ksR0FBRyxDQUFDLENBQUNDLEtBQUtDLElBQy9DLDZDQUE2QztRQUM3QyxPQUFPRCxRQUFRLFdBQVcsSUFBSVQsTUFBTSxDQUFDUyxLQUFLLE9BQU9DLElBQUksSUFBSSxJQUFJVixNQUFNLENBQUNTLE9BQU9BLEtBQUtFLElBQUksQ0FBQztBQUN2RjtBQUNBLE1BQU1DLGdCQUFnQkMsQ0FBQUE7SUFDcEIsSUFBSSxFQUNGZCxJQUFJLEVBQ0wsR0FBR2M7SUFDSixNQUFNQyxVQUFVZixLQUFLZ0IsRUFBRSxDQUFDLENBQUM7SUFDekIsSUFBSWhCLEtBQUtnQixFQUFFLENBQUMsQ0FBQyxPQUFPLFVBQVVELFlBQVksV0FBVztRQUNuRCxPQUFPO0lBQ1Q7SUFDQSxJQUFJLE9BQU9BLFlBQVksWUFBWUEsUUFBUUUsVUFBVSxDQUFDLE1BQU07UUFDMUQsT0FBTztJQUNUO0lBQ0EsSUFBSSxPQUFPRixZQUFZLFlBQVlmLEtBQUtnQixFQUFFLENBQUMs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SSxHQUFHMUMsZ0JBQWdCQztRQUN2RCxPQUFPdUIsZUFBZXhCLGdCQUFnQkM7SUFDeEM7QUFDRjtBQUNtRyxDQUNuRywrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hZGFwdGF0aW9uLWluc2lnaHRzLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvcHJldmlldy1raXQvZGlzdC9jc20uanM/OTRjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZU5vcm1hbGlzZWRKc29uUGF0aCwgZW5jb2RlLCBlbmNvZGVJbnRvUmVzdWx0IH0gZnJvbSAnLi9fY2h1bmtzL3NvdXJjZW1hcC1yLVR1UHJveS5qcyc7XG5leHBvcnQgeyByZXNvbHZlTWFwcGluZywgd2Fsa01hcCB9IGZyb20gJy4vX2NodW5rcy9zb3VyY2VtYXAtci1UdVByb3kuanMnO1xuaW1wb3J0IHsgdmVyY2VsU3RlZ2FDb21iaW5lIH0gZnJvbSAnQHZlcmNlbC9zdGVnYSc7XG5mdW5jdGlvbiBkZWZpbmVFZGl0TGluayhfc3R1ZGlvVXJsKSB7XG4gIGNvbnN0IHN0dWRpb1VybCA9IF9zdHVkaW9VcmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICByZXR1cm4gKHNvdXJjZURvY3VtZW50LCBwYXRoKSA9PiBcIlwiLmNvbmNhdChzdHVkaW9VcmwsIFwiL2ludGVudC9lZGl0L2lkPVwiKS5jb25jYXQoc291cmNlRG9jdW1lbnQuX2lkLCBcIjtcIikuY29uY2F0KHNvdXJjZURvY3VtZW50Ll90eXBlID8gXCJ0eXBlPVwiLmNvbmNhdChzb3VyY2VEb2N1bWVudC5fdHlwZSwgXCI7XCIpIDogXCJcIiwgXCJwYXRoPVwiKS5jb25jYXQoZW5jb2RlSnNvblBhdGhUb1VyaUNvbXBvbmVudChwYXRoKSk7XG59XG5mdW5jdGlvbiBlbmNvZGVKc29uUGF0aFRvVXJpQ29tcG9uZW50KHBhdGgpIHtcbiAgY29uc3Qgc291cmNlUGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGFyc2VOb3JtYWxpc2VkSnNvblBhdGgocGF0aCk7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc291cmNlUGF0aC5tYXAoKGtleSwgaSkgPT5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gIHR5cGVvZiBrZXkgPT09IFwibnVtYmVyXCIgPyBcIltcIi5jb25jYXQoa2V5LCBcIl1cIikgOiBpID4gMCA/IFwiLlwiLmNvbmNhdChrZXkpIDoga2V5KS5qb2luKFwiXCIpKTtcbn1cbmNvbnN0IGZpbHRlckRlZmF1bHQgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBwYXRoXG4gIH0gPSBfcmVmO1xuICBjb25zdCBlbmRQYXRoID0gcGF0aC5hdCgtMSk7XG4gIGlmIChwYXRoLmF0KC0yKSA9PT0gXCJzbHVnXCIgJiYgZW5kUGF0aCA9PT0gXCJjdXJyZW50XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmRQYXRoID09PSBcInN0cmluZ1wiICYmIGVuZFBhdGguc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmRQYXRoID09PSBcIm51bWJlclwiICYmIHBhdGguYXQoLTIpID09PSBcIm1hcmtzXCIgJiYgdHlwZW9mIHBhdGguYXQoLTMpID09PSBcIm51bWJlclwiICYmIHBhdGguYXQoLTQpID09PSBcImNoaWxkcmVuXCIgJiYgdHlwZW9mIHBhdGguYXQoLTUpID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbmRQYXRoID09PSBcImhyZWZcIiAmJiB0eXBlb2YgcGF0aC5hdCgtMikgPT09IFwibnVtYmVyXCIgJiYgcGF0aC5hdCgtMykgPT09IFwibWFya0RlZnNcIiAmJiB0eXBlb2YgcGF0aC5hdCgtNCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmRQYXRoID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwYXRoLmF0KC0yKSA9PT0gXCJudW1iZXJcIikge1xuICAgIGlmIChlbmRQYXRoID09PSBcInN0eWxlXCIgfHwgZW5kUGF0aCA9PT0gXCJsaXN0SXRlbVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IFRSVU5DQVRFX0xFTkdUSCA9IDIwO1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNjb2Rlcihjb25maWcpIHtcbiAgY29uc3Qge1xuICAgIHN0dWRpb1VybCxcbiAgICBlbmNvZGVTb3VyY2VNYXBBdFBhdGgsXG4gICAgbG9nZ2VyXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGNyZWF0ZUVkaXRMaW5rID0gZGVmaW5lRWRpdExpbmsoc3R1ZGlvVXJsKTtcbiAgY29uc3QgcmVwb3J0ID0ge1xuICAgIGVuY29kZWQ6IFtdLFxuICAgIHNraXBwZWQ6IFtdXG4gIH07XG4gIGNvbnN0IHRyYW5zY29kZSA9IChpbnB1dCwgc291cmNlRG9jdW1lbnQsIHNvdXJjZVBhdGgpID0+IHtcbiAgICBpZiAoKHR5cGVvZiBlbmNvZGVTb3VyY2VNYXBBdFBhdGggPT09IFwiZnVuY3Rpb25cIiA/IGVuY29kZVNvdXJjZU1hcEF0UGF0aCh7XG4gICAgICBwYXRoOiBzb3VyY2VQYXRoLFxuICAgICAgZmlsdGVyRGVmYXVsdFxuICAgIH0pIDogZmlsdGVyRGVmYXVsdCh7XG4gICAgICBwYXRoOiBzb3VyY2VQYXRoLFxuICAgICAgZmlsdGVyRGVmYXVsdFxuICAgIH0pKSA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChsb2dnZXIpIHtcbiAgICAgICAgcmVwb3J0LnNraXBwZWQucHVzaCh7XG4gICAgICAgICAgcGF0aDogcHJldHR5UGF0aEZvckxvZ2dpbmcoc291cmNlUGF0aCksXG4gICAgICAgICAgdmFsdWU6IFwiXCIuY29uY2F0KGlucHV0LnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCkpLmNvbmNhdChpbnB1dC5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIiksXG4gICAgICAgICAgbGVuZ3RoOiBpbnB1dC5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChsb2dnZXIpIHtcbiAgICAgIHJlcG9ydC5lbmNvZGVkLnB1c2goe1xuICAgICAgICBwYXRoOiBwcmV0dHlQYXRoRm9yTG9nZ2luZyhzb3VyY2VQYXRoKSxcbiAgICAgICAgdmFsdWU6IFwiXCIuY29uY2F0KGlucHV0LnNsaWNlKDAsIFRSVU5DQVRFX0xFTkdUSCkpLmNvbmNhdChpbnB1dC5sZW5ndGggPiBUUlVOQ0FURV9MRU5HVEggPyBcIi4uLlwiIDogXCJcIiksXG4gICAgICAgIGxlbmd0aDogaW5wdXQubGVuZ3RoXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcmNlbFN0ZWdhQ29tYmluZShpbnB1dCwge1xuICAgICAgb3JpZ2luOiBcInNhbml0eS5pb1wiLFxuICAgICAgaHJlZjogY3JlYXRlRWRpdExpbmsoc291cmNlRG9jdW1lbnQsIHNvdXJjZVBhdGgpXG4gICAgfSwgXCJhdXRvXCIpO1xuICB9O1xuICByZXR1cm4gKHJlc3VsdCwgY3NtKSA9PiB7XG4gICAgcmVwb3J0LmVuY29kZWQubGVuZ3RoID0gMDtcbiAgICByZXBvcnQuc2tpcHBlZC5sZW5ndGggPSAwO1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IGVuY29kZShyZXN1bHQsIGNzbSwgKHZhbHVlLCBzb3VyY2VEb2N1bWVudCwgcGF0aCkgPT4gdHJhbnNjb2RlKHZhbHVlLCBzb3VyY2VEb2N1bWVudCwgcGF0aCkpLFxuICAgICAgcmVwb3J0XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHByZXR0eVBhdGhGb3JMb2dnaW5nKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubWFwKChzZWdtZW50LCBpbmRleCkgPT4gdHlwZW9mIHNlZ21lbnQgPT09IFwibnVtYmVyXCIgPyBcIltcIi5jb25jYXQoc2VnbWVudCwgXCJdXCIpIDogaW5kZXggPiAwID8gXCIuXCIuY29uY2F0KHNlZ21lbnQpIDogc2VnbWVudCkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIG1hcFRvRWRpdExpbmtzKHJlc3VsdCwgY3NtLCBzdHVkaW9VcmwpIHtcbiAgY29uc3QgY3JlYXRlRWRpdExpbmsgPSBkZWZpbmVFZGl0TGluayhzdHVkaW9VcmwpO1xuICByZXR1cm4gZW5jb2RlSW50b1Jlc3VsdChyZXN1bHQsIGNzbSwgKF8sIHNvdXJjZURvY3VtZW50LCBwYXRoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUVkaXRMaW5rKHNvdXJjZURvY3VtZW50LCBwYXRoKTtcbiAgfSk7XG59XG5leHBvcnQgeyBjcmVhdGVUcmFuc2NvZGVyLCBlbmNvZGVKc29uUGF0aFRvVXJpQ29tcG9uZW50LCBtYXBUb0VkaXRMaW5rcywgcGFyc2VOb3JtYWxpc2VkSnNvblBhdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJwYXJzZU5vcm1hbGlzZWRKc29uUGF0aCIsImVuY29kZSIsImVuY29kZUludG9SZXN1bHQiLCJyZXNvbHZlTWFwcGluZyIsIndhbGtNYXAiLCJ2ZXJjZWxTdGVnYUNvbWJpbmUiLCJkZWZpbmVFZGl0TGluayIsIl9zdHVkaW9VcmwiLCJzdHVkaW9VcmwiLCJyZXBsYWNlIiwic291cmNlRG9jdW1lbnQiLCJwYXRoIiwiY29uY2F0IiwiX2lkIiwiX3R5cGUiLCJlbmNvZGVKc29uUGF0aFRvVXJpQ29tcG9uZW50Iiwic291cmNlUGF0aCIsIkFycmF5IiwiaXNBcnJheSIsImVuY29kZVVSSUNvbXBvbmVudCIsIm1hcCIsImtleSIsImkiLCJqb2luIiwiZmlsdGVyRGVmYXVsdCIsIl9yZWYiLCJlbmRQYXRoIiwiYXQiLCJzdGFydHNXaXRoIiwiVFJVTkNBVEVfTEVOR1RIIiwiY3JlYXRlVHJhbnNjb2RlciIsImNvbmZpZyIsImVuY29kZVNvdXJjZU1hcEF0UGF0aCIsImxvZ2dlciIsImNyZWF0ZUVkaXRMaW5rIiwicmVwb3J0IiwiZW5jb2RlZCIsInNraXBwZWQiLCJ0cmFuc2NvZGUiLCJpbnB1dCIsInB1c2giLCJwcmV0dHlQYXRoRm9yTG9nZ2luZyIsInZhbHVlIiwic2xpY2UiLCJsZW5ndGgiLCJvcmlnaW4iLCJocmVmIiwicmVzdWx0IiwiY3NtIiwic2VnbWVudCIsImluZGV4IiwibWFwVG9FZGl0TGlua3MiLCJfIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@sanity/preview-kit/dist/csm.js\n");

/***/ })

};
;