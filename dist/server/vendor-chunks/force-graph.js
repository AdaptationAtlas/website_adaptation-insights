"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/force-graph";
exports.ids = ["vendor-chunks/force-graph"];
exports.modules = {

/***/ "(ssr)/./node_modules/force-graph/dist/force-graph.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/force-graph/dist/force-graph.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ forceGraph)\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/min.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/max.js\");\n/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lodash-es */ \"(ssr)/./node_modules/lodash-es/throttle.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tweenjs/tween.js */ \"(ssr)/./node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n/* harmony import */ var kapsule__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! kapsule */ \"(ssr)/./node_modules/kapsule/dist/kapsule.mjs\");\n/* harmony import */ var accessor_fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/accessor-fn/dist/accessor-fn.mjs\");\n/* harmony import */ var canvas_color_tracker__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! canvas-color-tracker */ \"(ssr)/./node_modules/canvas-color-tracker/dist/canvas-color-tracker.mjs\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/simulation.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/link.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/manyBody.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/center.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/radial.js\");\n/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bezier-js */ \"(ssr)/./node_modules/bezier-js/src/bezier.js\");\n/* harmony import */ var index_array_by__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! index-array-by */ \"(ssr)/./node_modules/index-array-by/dist/index-array-by.mjs\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/ordinal.js\");\n/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale-chromatic */ \"(ssr)/./node_modules/d3-scale-chromatic/src/categorical/Paired.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n  if (!css || typeof document === 'undefined') {\n    return;\n  }\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".force-graph-container canvas {\\n  display: block;\\n  user-select: none;\\n  outline: none;\\n  -webkit-tap-highlight-color: transparent;\\n}\\n\\n.force-graph-container .graph-tooltip {\\n  position: absolute;\\n  top: 0;\\n  font-family: sans-serif;\\n  font-size: 16px;\\n  padding: 4px;\\n  border-radius: 3px;\\n  color: #eee;\\n  background: rgba(0,0,0,0.65);\\n  visibility: hidden; /* by default */\\n}\\n\\n.force-graph-container .clickable {\\n  cursor: pointer;\\n}\\n\\n.force-graph-container .grabbable {\\n  cursor: move;\\n  cursor: grab;\\n  cursor: -moz-grab;\\n  cursor: -webkit-grab;\\n}\\n\\n.force-graph-container .grabbable:active {\\n  cursor: grabbing;\\n  cursor: -moz-grabbing;\\n  cursor: -webkit-grabbing;\\n}\\n\";\nstyleInject(css_248z);\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar autoColorScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n\n// Autoset attribute colorField by colorByAccessor property\n// If an object has already a color, don't set it\n// Objects can be nodes or links\nfunction autoColorObjects(objects, colorByAccessor, colorField) {\n  if (!colorByAccessor || typeof colorField !== 'string') return;\n  objects.filter(function (obj) {\n    return !obj[colorField];\n  }).forEach(function (obj) {\n    obj[colorField] = autoColorScale(colorByAccessor(obj));\n  });\n}\n\nfunction getDagDepths (_ref, idAccessor) {\n  var nodes = _ref.nodes,\n    links = _ref.links;\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$nodeFilter = _ref2.nodeFilter,\n    nodeFilter = _ref2$nodeFilter === void 0 ? function () {\n      return true;\n    } : _ref2$nodeFilter,\n    _ref2$onLoopError = _ref2.onLoopError,\n    onLoopError = _ref2$onLoopError === void 0 ? function (loopIds) {\n      throw \"Invalid DAG structure! Found cycle in node path: \".concat(loopIds.join(' -> '), \".\");\n    } : _ref2$onLoopError;\n  // linked graph\n  var graph = {};\n  nodes.forEach(function (node) {\n    return graph[idAccessor(node)] = {\n      data: node,\n      out: [],\n      depth: -1,\n      skip: !nodeFilter(node)\n    };\n  });\n  links.forEach(function (_ref3) {\n    var source = _ref3.source,\n      target = _ref3.target;\n    var sourceId = getNodeId(source);\n    var targetId = getNodeId(target);\n    if (!graph.hasOwnProperty(sourceId)) throw \"Missing source node with id: \".concat(sourceId);\n    if (!graph.hasOwnProperty(targetId)) throw \"Missing target node with id: \".concat(targetId);\n    var sourceNode = graph[sourceId];\n    var targetNode = graph[targetId];\n    sourceNode.out.push(targetNode);\n    function getNodeId(node) {\n      return _typeof(node) === 'object' ? idAccessor(node) : node;\n    }\n  });\n  var foundLoops = [];\n  traverse(Object.values(graph));\n  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      node = _ref5[1];\n    return !node.skip;\n  }).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      id = _ref7[0],\n      node = _ref7[1];\n    return _defineProperty({}, id, node.depth);\n  }))));\n  return nodeDepths;\n  function traverse(nodes) {\n    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var _loop = function _loop() {\n      var node = nodes[i];\n      if (nodeStack.indexOf(node) !== -1) {\n        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {\n          return idAccessor(d.data);\n        });\n        if (!foundLoops.some(function (foundLoop) {\n          return foundLoop.length === loop.length && foundLoop.every(function (id, idx) {\n            return id === loop[idx];\n          });\n        })) {\n          foundLoops.push(loop);\n          onLoopError(loop);\n        }\n        return 1; // continue\n      }\n      if (currentDepth > node.depth) {\n        // Don't unnecessarily revisit chunks of the graph\n        node.depth = currentDepth;\n        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));\n      }\n    };\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      if (_loop()) continue;\n    }\n  }\n}\n\n//\n\nvar DAG_LEVEL_NODE_RATIO = 2;\n\n// whenever styling props are changed that require a canvas redraw\nvar notifyRedraw = function notifyRedraw(_, state) {\n  return state.onNeedsRedraw && state.onNeedsRedraw();\n};\nvar updDataPhotons = function updDataPhotons(_, state) {\n  if (!state.isShadow) {\n    // Add photon particles\n    var linkParticlesAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n    state.graphData.links.forEach(function (link) {\n      var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));\n      if (numPhotons) {\n        link.__photons = _toConsumableArray(Array(numPhotons)).map(function () {\n          return {};\n        });\n      } else {\n        delete link.__photons;\n      }\n    });\n  }\n};\nvar CanvasForceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n  props: {\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(_, state) {\n        state.engineRunning = false; // Pause simulation\n        updDataPhotons(_, state);\n      }\n    },\n    dagMode: {\n      onChange: function onChange(dagMode, state) {\n        // td, bu, lr, rl, radialin, radialout\n        !dagMode && (state.graphData.nodes || []).forEach(function (n) {\n          return n.fx = n.fy = undefined;\n        }); // unfix nodes when disabling dag mode\n      }\n    },\n\n    dagLevelDistance: {},\n    dagNodeFilter: {\n      \"default\": function _default(node) {\n        return true;\n      }\n    },\n    onDagError: {\n      triggerUpdate: false\n    },\n    nodeRelSize: {\n      \"default\": 4,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // area per val unit\n    nodeId: {\n      \"default\": 'id'\n    },\n    nodeVal: {\n      \"default\": 'val',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeAutoColorBy: {},\n    nodeCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkSource: {\n      \"default\": 'source'\n    },\n    linkTarget: {\n      \"default\": 'target'\n    },\n    linkVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkAutoColorBy: {},\n    linkLineDash: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkWidth: {\n      \"default\": 1,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCurvature: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowLength: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowColor: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowRelPos: {\n      \"default\": 0.5,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalParticles: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: updDataPhotons\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      \"default\": 0.01,\n      triggerUpdate: false\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleWidth: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    linkDirectionalParticleColor: {\n      triggerUpdate: false\n    },\n    globalScale: {\n      \"default\": 1,\n      triggerUpdate: false\n    },\n    d3AlphaMin: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    d3AlphaDecay: {\n      \"default\": 0.0228,\n      triggerUpdate: false,\n      onChange: function onChange(alphaDecay, state) {\n        state.forceLayout.alphaDecay(alphaDecay);\n      }\n    },\n    d3AlphaTarget: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: function onChange(alphaTarget, state) {\n        state.forceLayout.alphaTarget(alphaTarget);\n      }\n    },\n    d3VelocityDecay: {\n      \"default\": 0.4,\n      triggerUpdate: false,\n      onChange: function onChange(velocityDecay, state) {\n        state.forceLayout.velocityDecay(velocityDecay);\n      }\n    },\n    warmupTicks: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      \"default\": Infinity,\n      triggerUpdate: false\n    },\n    cooldownTime: {\n      \"default\": 15000,\n      triggerUpdate: false\n    },\n    // ms\n    onUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineTick: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineStop: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNeedsRedraw: {\n      triggerUpdate: false\n    },\n    isShadow: {\n      \"default\": false,\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    // Expose d3 forces for external manipulation\n    d3Force: function d3Force(state, forceName, forceFn) {\n      if (forceFn === undefined) {\n        return state.forceLayout.force(forceName); // Force getter\n      }\n\n      state.forceLayout.force(forceName, forceFn); // Force setter\n      return this;\n    },\n    d3ReheatSimulation: function d3ReheatSimulation(state) {\n      state.forceLayout.alpha(1);\n      this.resetCountdown();\n      return this;\n    },\n    // reset cooldown state\n    resetCountdown: function resetCountdown(state) {\n      state.cntTicks = 0;\n      state.startTickTime = new Date();\n      state.engineRunning = true;\n      return this;\n    },\n    isEngineRunning: function isEngineRunning(state) {\n      return !!state.engineRunning;\n    },\n    tickFrame: function tickFrame(state) {\n      !state.isShadow && layoutTick();\n      paintLinks();\n      !state.isShadow && paintArrows();\n      !state.isShadow && paintPhotons();\n      paintNodes();\n      return this;\n\n      //\n\n      function layoutTick() {\n        if (state.engineRunning) {\n          if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime || state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin) {\n            state.engineRunning = false; // Stop ticking graph\n            state.onEngineStop();\n          } else {\n            state.forceLayout.tick(); // Tick it\n            state.onEngineTick();\n          }\n        }\n      }\n      function paintNodes() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVisibility);\n        var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeColor);\n        var getNodeCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow / state.globalScale;\n        var visibleNodes = state.graphData.nodes.filter(getVisibility);\n        ctx.save();\n        visibleNodes.forEach(function (node) {\n          var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);\n          if (state.nodeCanvasObject && (nodeCanvasObjectMode === 'before' || nodeCanvasObjectMode === 'replace')) {\n            // Custom node before/replace paint\n            state.nodeCanvasObject(node, ctx, state.globalScale);\n            if (nodeCanvasObjectMode === 'replace') {\n              ctx.restore();\n              return;\n            }\n          }\n\n          // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n          var r = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;\n          ctx.beginPath();\n          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);\n          ctx.fillStyle = getColor(node) || 'rgba(31, 120, 180, 0.92)';\n          ctx.fill();\n          if (state.nodeCanvasObject && nodeCanvasObjectMode === 'after') {\n            // Custom node after paint\n            state.nodeCanvasObject(node, state.ctx, state.globalScale);\n          }\n        });\n        ctx.restore();\n      }\n      function paintLinks() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkColor);\n        var getWidth = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth);\n        var getLineDash = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkLineDash);\n        var getCurvature = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCurvature);\n        var getLinkCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider lines by 2px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow * 2;\n        var visibleLinks = state.graphData.links.filter(getVisibility);\n        visibleLinks.forEach(calcLinkControlPoints); // calculate curvature control points for all visible links\n\n        var beforeCustomLinks = [],\n          afterCustomLinks = [],\n          defaultPaintLinks = visibleLinks;\n        if (state.linkCanvasObject) {\n          var replaceCustomLinks = [],\n            otherCustomLinks = [];\n          visibleLinks.forEach(function (d) {\n            return ({\n              before: beforeCustomLinks,\n              after: afterCustomLinks,\n              replace: replaceCustomLinks\n            }[getLinkCanvasObjectMode(d)] || otherCustomLinks).push(d);\n          });\n          defaultPaintLinks = [].concat(_toConsumableArray(beforeCustomLinks), afterCustomLinks, otherCustomLinks);\n          beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);\n        }\n\n        // Custom link before paints\n        ctx.save();\n        beforeCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        // Bundle strokes per unique color/width/dash for performance optimization\n        var linksPerColor = (0,index_array_by__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(defaultPaintLinks, [getColor, getWidth, getLineDash]);\n        ctx.save();\n        Object.entries(linksPerColor).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            color = _ref2[0],\n            linksPerWidth = _ref2[1];\n          var lineColor = !color || color === 'undefined' ? 'rgba(0,0,0,0.15)' : color;\n          Object.entries(linksPerWidth).forEach(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n              width = _ref4[0],\n              linesPerLineDash = _ref4[1];\n            var lineWidth = (width || 1) / state.globalScale + padAmount;\n            Object.entries(linesPerLineDash).forEach(function (_ref5) {\n              var _ref6 = _slicedToArray(_ref5, 2);\n                _ref6[0];\n                var links = _ref6[1];\n              var lineDashSegments = getLineDash(links[0]);\n              ctx.beginPath();\n              links.forEach(function (link) {\n                var start = link.source;\n                var end = link.target;\n                if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n                ctx.moveTo(start.x, start.y);\n                var controlPoints = link.__controlPoints;\n                if (!controlPoints) {\n                  // Straight line\n                  ctx.lineTo(end.x, end.y);\n                } else {\n                  // Use quadratic curves for regular lines and bezier for loops\n                  ctx[controlPoints.length === 2 ? 'quadraticCurveTo' : 'bezierCurveTo'].apply(ctx, _toConsumableArray(controlPoints).concat([end.x, end.y]));\n                }\n              });\n              ctx.strokeStyle = lineColor;\n              ctx.lineWidth = lineWidth;\n              ctx.setLineDash(lineDashSegments || []);\n              ctx.stroke();\n            });\n          });\n        });\n        ctx.restore();\n\n        // Custom link after paints\n        ctx.save();\n        afterCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        //\n\n        function calcLinkControlPoints(link) {\n          var curvature = getCurvature(link);\n          if (!curvature) {\n            // straight line\n            link.__controlPoints = null;\n            return;\n          }\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var l = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)); // line length\n\n          if (l > 0) {\n            var a = Math.atan2(end.y - start.y, end.x - start.x); // line angle\n            var d = l * curvature; // control point distance\n\n            var cp = {\n              // control point\n              x: (start.x + end.x) / 2 + d * Math.cos(a - Math.PI / 2),\n              y: (start.y + end.y) / 2 + d * Math.sin(a - Math.PI / 2)\n            };\n            link.__controlPoints = [cp.x, cp.y];\n          } else {\n            // Same point, draw a loop\n            var _d = curvature * 70;\n            link.__controlPoints = [end.x, end.y - _d, end.x + _d, end.y];\n          }\n        }\n      }\n      function paintArrows() {\n        var ARROW_WH_RATIO = 1.6;\n        var ARROW_VLEN_RATIO = 0.2;\n        var getLength = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowLength);\n        var getRelPos = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowRelPos);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowColor || state.linkColor);\n        var getNodeVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var arrowLength = getLength(link);\n          if (!arrowLength || arrowLength < 0) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var startR = Math.sqrt(Math.max(0, getNodeVal(start) || 1)) * state.nodeRelSize;\n          var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;\n          var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link)));\n          var arrowColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints && _construct(bezier_js__WEBPACK_IMPORTED_MODULE_3__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y]));\n          var getCoordsAlongLine = bzLine ? function (t) {\n            return bzLine.get(t);\n          } // get position along bezier line\n          : function (t) {\n            return {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * t || 0,\n              y: start.y + (end.y - start.y) * t || 0\n            };\n          };\n          var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;\n          var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);\n          var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);\n          var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);\n          var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;\n          ctx.beginPath();\n          ctx.moveTo(arrowHead.x, arrowHead.y);\n          ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);\n          ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.fillStyle = arrowColor;\n          ctx.fill();\n        });\n        ctx.restore();\n      }\n      function paintPhotons() {\n        var getNumPhotons = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n        var getSpeed = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleSpeed);\n        var getDiameter = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleWidth);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleColor || state.linkColor);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var numCyclePhotons = getNumPhotons(link);\n          if (!link.hasOwnProperty('__photons') || !link.__photons.length) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var particleSpeed = getSpeed(link);\n          var photons = link.__photons || [];\n          var photonR = Math.max(0, getDiameter(link) / 2) / Math.sqrt(state.globalScale);\n          var photonColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          ctx.fillStyle = photonColor;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints ? _construct(bezier_js__WEBPACK_IMPORTED_MODULE_3__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y])) : null;\n          var cyclePhotonIdx = 0;\n          var needsCleanup = false; // whether some photons need to be removed from list\n          photons.forEach(function (photon) {\n            var singleHop = !!photon.__singleHop;\n            if (!photon.hasOwnProperty('__progressRatio')) {\n              photon.__progressRatio = singleHop ? 0 : cyclePhotonIdx / numCyclePhotons;\n            }\n            !singleHop && cyclePhotonIdx++; // increase regular photon index\n\n            photon.__progressRatio += particleSpeed;\n            if (photon.__progressRatio >= 1) {\n              if (!singleHop) {\n                photon.__progressRatio = photon.__progressRatio % 1;\n              } else {\n                needsCleanup = true;\n                return;\n              }\n            }\n            var photonPosRatio = photon.__progressRatio;\n            var coords = bzLine ? bzLine.get(photonPosRatio) // get position along bezier line\n            : {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * photonPosRatio || 0,\n              y: start.y + (end.y - start.y) * photonPosRatio || 0\n            };\n            ctx.beginPath();\n            ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);\n            ctx.fill();\n          });\n          if (needsCleanup) {\n            // remove expired single hop photons\n            link.__photons = link.__photons.filter(function (photon) {\n              return !photon.__singleHop || photon.__progressRatio <= 1;\n            });\n          }\n        });\n        ctx.restore();\n      }\n    },\n    emitParticle: function emitParticle(state, link) {\n      if (link) {\n        !link.__photons && (link.__photons = []);\n        link.__photons.push({\n          __singleHop: true\n        }); // add a single hop particle\n      }\n\n      return this;\n    }\n  },\n  stateInit: function stateInit() {\n    return {\n      forceLayout: (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_8__[\"default\"])().force('link', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_9__[\"default\"])()).force('charge', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_10__[\"default\"])()).force('center', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_11__[\"default\"])()).force('dagRadial', null).stop(),\n      engineRunning: false\n    };\n  },\n  init: function init(canvasCtx, state) {\n    // Main canvas object to manipulate\n    state.ctx = canvasCtx;\n  },\n  update: function update(state) {\n    state.engineRunning = false; // Pause simulation\n    state.onUpdate();\n    if (state.nodeAutoColorBy !== null) {\n      // Auto add color to uncolored nodes\n      autoColorObjects(state.graphData.nodes, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeAutoColorBy), state.nodeColor);\n    }\n    if (state.linkAutoColorBy !== null) {\n      // Auto add color to uncolored links\n      autoColorObjects(state.graphData.links, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkAutoColorBy), state.linkColor);\n    }\n\n    // parse links\n    state.graphData.links.forEach(function (link) {\n      link.source = link[state.linkSource];\n      link.target = link[state.linkTarget];\n    });\n\n    // Feed data to force-directed layout\n    state.forceLayout.stop().alpha(1) // re-heat the simulation\n    .nodes(state.graphData.nodes);\n\n    // add links (if link force is still active)\n    var linkForce = state.forceLayout.force('link');\n    if (linkForce) {\n      linkForce.id(function (d) {\n        return d[state.nodeId];\n      }).links(state.graphData.links);\n    }\n\n    // setup dag force constraints\n    var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {\n      return node[state.nodeId];\n    }, {\n      nodeFilter: state.dagNodeFilter,\n      onLoopError: state.onDagError || undefined\n    });\n    var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));\n    var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1);\n\n    // Fix nodes to x,y for dag mode\n    if (state.dagMode) {\n      var getFFn = function getFFn(fix, invert) {\n        return function (node) {\n          return !fix ? undefined : (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);\n        };\n      };\n      var fxFn = getFFn(['lr', 'rl'].indexOf(state.dagMode) !== -1, state.dagMode === 'rl');\n      var fyFn = getFFn(['td', 'bu'].indexOf(state.dagMode) !== -1, state.dagMode === 'bu');\n      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n        node.fx = fxFn(node);\n        node.fy = fyFn(node);\n      });\n    }\n\n    // Use radial force for radial dags\n    state.forceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(function (node) {\n      var nodeDepth = nodeDepths[node[state.nodeId]] || -1;\n      return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;\n    }).strength(function (node) {\n      return state.dagNodeFilter(node) ? 1 : 0;\n    }) : null);\n    for (var i = 0; i < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin); i++) {\n      state.forceLayout.tick();\n    } // Initial ticks before starting to render\n\n    this.resetCountdown();\n    state.onFinishUpdate();\n  }\n});\n\nfunction linkKapsule (kapsulePropNames, kapsuleType) {\n  var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];\n  var dummyK = new kapsuleType(); // To extract defaults\n  dummyK._destructor && dummyK._destructor();\n  return {\n    linkProp: function linkProp(prop) {\n      // link property config\n      return {\n        \"default\": dummyK[prop](),\n        onChange: function onChange(v, state) {\n          propNames.forEach(function (propName) {\n            return state[propName][prop](v);\n          });\n        },\n        triggerUpdate: false\n      };\n    },\n    linkMethod: function linkMethod(method) {\n      // link method pass-through\n      return function (state) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        var returnVals = [];\n        propNames.forEach(function (propName) {\n          var kapsuleInstance = state[propName];\n          var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);\n          if (returnVal !== kapsuleInstance) {\n            returnVals.push(returnVal);\n          }\n        });\n        return returnVals.length ? returnVals[0] : this; // chain based on the parent object, not the inner kapsule\n      };\n    }\n  };\n}\n\nvar HOVER_CANVAS_THROTTLE_DELAY = 800; // ms to throttle shadow canvas updates for perf improvement\nvar ZOOM2NODES_FACTOR = 4;\n\n// Expose config from forceGraph\nvar bindFG = linkKapsule('forceGraph', CanvasForceGraph);\nvar bindBoth = linkKapsule(['forceGraph', 'shadowGraph'], CanvasForceGraph);\nvar linkedProps = Object.assign.apply(Object, _toConsumableArray(['nodeColor', 'nodeAutoColorBy', 'nodeCanvasObject', 'nodeCanvasObjectMode', 'linkColor', 'linkAutoColorBy', 'linkLineDash', 'linkWidth', 'linkCanvasObject', 'linkCanvasObjectMode', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'dagMode', 'dagLevelDistance', 'dagNodeFilter', 'onDagError', 'd3AlphaMin', 'd3AlphaDecay', 'd3VelocityDecay', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkProp(p));\n})).concat(_toConsumableArray(['nodeRelSize', 'nodeId', 'nodeVal', 'nodeVisibility', 'linkSource', 'linkTarget', 'linkVisibility', 'linkCurvature'].map(function (p) {\n  return _defineProperty({}, p, bindBoth.linkProp(p));\n}))));\nvar linkedMethods = Object.assign.apply(Object, _toConsumableArray(['d3Force', 'd3ReheatSimulation', 'emitParticle'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkMethod(p));\n})));\nfunction adjustCanvasSize(state) {\n  if (state.canvas) {\n    var curWidth = state.canvas.width;\n    var curHeight = state.canvas.height;\n    if (curWidth === 300 && curHeight === 150) {\n      // Default canvas dimensions\n      curWidth = curHeight = 0;\n    }\n    var pxScale = window.devicePixelRatio; // 2 on retina displays\n    curWidth /= pxScale;\n    curHeight /= pxScale;\n\n    // Resize canvases\n    [state.canvas, state.shadowCanvas].forEach(function (canvas) {\n      // Element size\n      canvas.style.width = \"\".concat(state.width, \"px\");\n      canvas.style.height = \"\".concat(state.height, \"px\");\n\n      // Memory size (scaled to avoid blurriness)\n      canvas.width = state.width * pxScale;\n      canvas.height = state.height * pxScale;\n\n      // Normalize coordinate system to use css pixels (on init only)\n      if (!curWidth && !curHeight) {\n        canvas.getContext('2d').scale(pxScale, pxScale);\n      }\n    });\n\n    // Relative center panning based on 0,0\n    var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n    state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k, (state.height - curHeight) / 2 / k);\n    state.needsRedraw = true;\n  }\n}\nfunction resetTransform(ctx) {\n  var pxRatio = window.devicePixelRatio;\n  ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);\n}\nfunction clearCanvas(ctx, width, height) {\n  ctx.save();\n  resetTransform(ctx); // reset transform\n  ctx.clearRect(0, 0, width, height);\n  ctx.restore(); //restore transforms\n}\n\n//\n\nvar forceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_6__[\"default\"])({\n  props: _objectSpread2({\n    width: {\n      \"default\": window.innerWidth,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    height: {\n      \"default\": window.innerHeight,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(d, state) {\n        [{\n          type: 'Node',\n          objs: d.nodes\n        }, {\n          type: 'Link',\n          objs: d.links\n        }].forEach(hexIndex);\n        state.forceGraph.graphData(d);\n        state.shadowGraph.graphData(d);\n        function hexIndex(_ref4) {\n          var type = _ref4.type,\n            objs = _ref4.objs;\n          objs.filter(function (d) {\n            if (!d.hasOwnProperty('__indexColor')) return true;\n            var cur = state.colorTracker.lookup(d.__indexColor);\n            return !cur || !cur.hasOwnProperty('d') || cur.d !== d;\n          }).forEach(function (d) {\n            // store object lookup color\n            d.__indexColor = state.colorTracker.register({\n              type: type,\n              d: d\n            });\n          });\n        }\n      },\n      triggerUpdate: false\n    },\n    backgroundColor: {\n      onChange: function onChange(color, state) {\n        state.canvas && color && (state.canvas.style.background = color);\n      },\n      triggerUpdate: false\n    },\n    nodeLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    nodePointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.nodeCanvasObject(!paintFn ? null : function (node, ctx, globalScale) {\n          return paintFn(node, node.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkPointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.linkCanvasObject(!paintFn ? null : function (link, ctx, globalScale) {\n          return paintFn(link, link.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    linkHoverPrecision: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    minZoom: {\n      \"default\": 0.01,\n      onChange: function onChange(minZoom, state) {\n        state.zoom.scaleExtent([minZoom, state.zoom.scaleExtent()[1]]);\n      },\n      triggerUpdate: false\n    },\n    maxZoom: {\n      \"default\": 1000,\n      onChange: function onChange(maxZoom, state) {\n        state.zoom.scaleExtent([state.zoom.scaleExtent()[0], maxZoom]);\n      },\n      triggerUpdate: false\n    },\n    enableNodeDrag: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enablePanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomPanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    // to be deprecated\n    enablePointerInteraction: {\n      \"default\": true,\n      onChange: function onChange(_, state) {\n        state.hoverObj = null;\n      },\n      triggerUpdate: false\n    },\n    autoPauseRedraw: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    onNodeDrag: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeDragEnd: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeClick: {\n      triggerUpdate: false\n    },\n    onNodeRightClick: {\n      triggerUpdate: false\n    },\n    onNodeHover: {\n      triggerUpdate: false\n    },\n    onLinkClick: {\n      triggerUpdate: false\n    },\n    onLinkRightClick: {\n      triggerUpdate: false\n    },\n    onLinkHover: {\n      triggerUpdate: false\n    },\n    onBackgroundClick: {\n      triggerUpdate: false\n    },\n    onBackgroundRightClick: {\n      triggerUpdate: false\n    },\n    onZoom: {\n      triggerUpdate: false\n    },\n    onZoomEnd: {\n      triggerUpdate: false\n    },\n    onRenderFramePre: {\n      triggerUpdate: false\n    },\n    onRenderFramePost: {\n      triggerUpdate: false\n    }\n  }, linkedProps),\n  aliases: {\n    // Prop names supported for backwards compatibility\n    stopAnimation: 'pauseAnimation'\n  },\n  methods: _objectSpread2({\n    graph2ScreenCoords: function graph2ScreenCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: x * t.k + t.x,\n        y: y * t.k + t.y\n      };\n    },\n    screen2GraphCoords: function screen2GraphCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: (x - t.x) / t.k,\n        y: (y - t.y) / t.k\n      };\n    },\n    centerAt: function centerAt(state, x, y, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (x !== undefined || y !== undefined) {\n        var finalPos = Object.assign({}, x !== undefined ? {\n          x: x\n        } : {}, y !== undefined ? {\n          y: y\n        } : {});\n        if (!transitionDuration) {\n          // no animation\n          setCenter(finalPos);\n        } else {\n          new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween(getCenter()).to(finalPos, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(setCenter).start();\n        }\n        return this;\n      }\n\n      // getter\n      return getCenter();\n\n      //\n\n      function getCenter() {\n        var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n        return {\n          x: (state.width / 2 - t.x) / t.k,\n          y: (state.height / 2 - t.y) / t.k\n        };\n      }\n      function setCenter(_ref5) {\n        var x = _ref5.x,\n          y = _ref5.y;\n        state.zoom.translateTo(state.zoom.__baseElem, x === undefined ? getCenter().x : x, y === undefined ? getCenter().y : y);\n        state.needsRedraw = true;\n      }\n    },\n    zoom: function zoom(state, k, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (k !== undefined) {\n        if (!transitionDuration) {\n          // no animation\n          setZoom(k);\n        } else {\n          new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween({\n            k: getZoom()\n          }).to({\n            k: k\n          }, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(function (_ref6) {\n            var k = _ref6.k;\n            return setZoom(k);\n          }).start();\n        }\n        return this;\n      }\n\n      // getter\n      return getZoom();\n\n      //\n\n      function getZoom() {\n        return (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      }\n      function setZoom(k) {\n        state.zoom.scaleTo(state.zoom.__baseElem, k);\n        state.needsRedraw = true;\n      }\n    },\n    zoomToFit: function zoomToFit(state) {\n      var transitionDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        bboxArgs[_key - 3] = arguments[_key];\n      }\n      var bbox = this.getGraphBbox.apply(this, bboxArgs);\n      if (bbox) {\n        var center = {\n          x: (bbox.x[0] + bbox.x[1]) / 2,\n          y: (bbox.y[0] + bbox.y[1]) / 2\n        };\n        var zoomK = Math.max(1e-12, Math.min(1e12, (state.width - padding * 2) / (bbox.x[1] - bbox.x[0]), (state.height - padding * 2) / (bbox.y[1] - bbox.y[0])));\n        this.centerAt(center.x, center.y, transitionDuration);\n        this.zoom(zoomK, transitionDuration);\n      }\n      return this;\n    },\n    getGraphBbox: function getGraphBbox(state) {\n      var nodeFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n      var getR = function getR(node) {\n        return Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize;\n      };\n      var nodesPos = state.graphData.nodes.filter(nodeFilter).map(function (node) {\n        return {\n          x: node.x,\n          y: node.y,\n          r: getR(node)\n        };\n      });\n      return !nodesPos.length ? null : {\n        x: [(0,d3_array__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(nodesPos, function (node) {\n          return node.x - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.x + node.r;\n        })],\n        y: [(0,d3_array__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(nodesPos, function (node) {\n          return node.y - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.y + node.r;\n        })]\n      };\n    },\n    pauseAnimation: function pauseAnimation(state) {\n      if (state.animationFrameRequestId) {\n        cancelAnimationFrame(state.animationFrameRequestId);\n        state.animationFrameRequestId = null;\n      }\n      return this;\n    },\n    resumeAnimation: function resumeAnimation(state) {\n      if (!state.animationFrameRequestId) {\n        this._animationCycle();\n      }\n      return this;\n    },\n    _destructor: function _destructor() {\n      this.pauseAnimation();\n      this.graphData({\n        nodes: [],\n        links: []\n      });\n    }\n  }, linkedMethods),\n  stateInit: function stateInit() {\n    return {\n      lastSetZoom: 1,\n      zoom: (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)(),\n      forceGraph: new CanvasForceGraph(),\n      shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor('__indexColor').linkColor('__indexColor').isShadow(true),\n      colorTracker: new canvas_color_tracker__WEBPACK_IMPORTED_MODULE_15__[\"default\"]() // indexed objects for rgb lookup\n    };\n  },\n\n  init: function init(domNode, state) {\n    var _this = this;\n    // Wipe DOM\n    domNode.innerHTML = '';\n\n    // Container anchor for canvas and tooltip\n    var container = document.createElement('div');\n    container.classList.add('force-graph-container');\n    container.style.position = 'relative';\n    domNode.appendChild(container);\n    state.canvas = document.createElement('canvas');\n    if (state.backgroundColor) state.canvas.style.background = state.backgroundColor;\n    container.appendChild(state.canvas);\n    state.shadowCanvas = document.createElement('canvas');\n\n    // Show shadow canvas\n    //state.shadowCanvas.style.position = 'absolute';\n    //state.shadowCanvas.style.top = '0';\n    //state.shadowCanvas.style.left = '0';\n    //container.appendChild(state.shadowCanvas);\n\n    var ctx = state.canvas.getContext('2d');\n    var shadowCtx = state.shadowCanvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    var pointerPos = {\n      x: -1e12,\n      y: -1e12\n    };\n    var getObjUnderPointer = function getObjUnderPointer() {\n      var obj = null;\n      var pxScale = window.devicePixelRatio;\n      var px = pointerPos.x > 0 && pointerPos.y > 0 ? shadowCtx.getImageData(pointerPos.x * pxScale, pointerPos.y * pxScale, 1, 1) : null;\n      // Lookup object per pixel color\n      px && (obj = state.colorTracker.lookup(px.data));\n      return obj;\n    };\n\n    // Setup node drag interaction\n    (0,d3_selection__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(state.canvas).call((0,d3_drag__WEBPACK_IMPORTED_MODULE_17__[\"default\"])().subject(function () {\n      if (!state.enableNodeDrag) {\n        return null;\n      }\n      var obj = getObjUnderPointer();\n      return obj && obj.type === 'Node' ? obj.d : null; // Only drag nodes\n    }).on('start', function (ev) {\n      var obj = ev.subject;\n      obj.__initialDragPos = {\n        x: obj.x,\n        y: obj.y,\n        fx: obj.fx,\n        fy: obj.fy\n      };\n\n      // keep engine running at low intensity throughout drag\n      if (!ev.active) {\n        obj.fx = obj.x;\n        obj.fy = obj.y; // Fix points\n      }\n\n      // drag cursor\n      state.canvas.classList.add('grabbable');\n    }).on('drag', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var dragPos = ev;\n      var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      var translate = {\n        x: initPos.x + (dragPos.x - initPos.x) / k - obj.x,\n        y: initPos.y + (dragPos.y - initPos.y) / k - obj.y\n      };\n\n      // Move fx/fy (and x/y) of nodes based on the scaled drag distance since the drag start\n      ['x', 'y'].forEach(function (c) {\n        return obj[\"f\".concat(c)] = obj[c] = initPos[c] + (dragPos[c] - initPos[c]) / k;\n      });\n\n      // prevent freeze while dragging\n      state.forceGraph.d3AlphaTarget(0.3) // keep engine running at low intensity throughout drag\n      .resetCountdown(); // prevent freeze while dragging\n\n      state.isPointerDragging = true;\n      obj.__dragged = true;\n      state.onNodeDrag(obj, translate);\n    }).on('end', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var translate = {\n        x: obj.x - initPos.x,\n        y: obj.y - initPos.y\n      };\n      if (initPos.fx === undefined) {\n        obj.fx = undefined;\n      }\n      if (initPos.fy === undefined) {\n        obj.fy = undefined;\n      }\n      delete obj.__initialDragPos;\n      if (state.forceGraph.d3AlphaTarget()) {\n        state.forceGraph.d3AlphaTarget(0) // release engine low intensity\n        .resetCountdown(); // let the engine readjust after releasing fixed nodes\n      }\n\n      // drag cursor\n      state.canvas.classList.remove('grabbable');\n      state.isPointerDragging = false;\n      if (obj.__dragged) {\n        delete obj.__dragged;\n        state.onNodeDragEnd(obj, translate);\n      }\n    }));\n\n    // Setup zoom / pan interaction\n    state.zoom(state.zoom.__baseElem = (0,d3_selection__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(state.canvas)); // Attach controlling elem for easy access\n\n    state.zoom.__baseElem.on('dblclick.zoom', null); // Disable double-click to zoom\n\n    state.zoom.filter(function (ev) {\n      return (\n        // disable zoom interaction\n        !ev.button && state.enableZoomPanInteraction && (state.enableZoomInteraction || ev.type !== 'wheel') && (state.enablePanInteraction || ev.type === 'wheel')\n      );\n    }).on('zoom', function (ev) {\n      var t = ev.transform;\n      [ctx, shadowCtx].forEach(function (c) {\n        resetTransform(c);\n        c.translate(t.x, t.y);\n        c.scale(t.k, t.k);\n      });\n      state.onZoom && state.onZoom(_objectSpread2(_objectSpread2({}, t), _this.centerAt())); // report x,y coordinates relative to canvas center\n      state.needsRedraw = true;\n    }).on('end', function (ev) {\n      return state.onZoomEnd && state.onZoomEnd(_objectSpread2(_objectSpread2({}, ev.transform), _this.centerAt()));\n    });\n    adjustCanvasSize(state);\n    state.forceGraph.onNeedsRedraw(function () {\n      return state.needsRedraw = true;\n    }).onFinishUpdate(function () {\n      // re-zoom, if still in default position (not user modified)\n      if ((0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {\n        state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));\n        state.needsRedraw = true;\n      }\n    });\n\n    // Setup tooltip\n    var toolTipElem = document.createElement('div');\n    toolTipElem.classList.add('graph-tooltip');\n    container.appendChild(toolTipElem);\n\n    // Capture pointer coords on move or touchstart\n    ['pointermove', 'pointerdown'].forEach(function (evType) {\n      return container.addEventListener(evType, function (ev) {\n        if (evType === 'pointerdown') {\n          state.isPointerPressed = true; // track click state\n          state.pointerDownEvent = ev;\n        }\n\n        // detect pointer drag on canvas pan\n        !state.isPointerDragging && ev.type === 'pointermove' && state.onBackgroundClick // only bother detecting drags this way if background clicks are enabled (so they don't trigger accidentally on canvas panning)\n        && (ev.pressure > 0 || state.isPointerPressed) // ev.pressure always 0 on Safari, so we use the isPointerPressed tracker\n        && (ev.pointerType !== 'touch' || ev.movementX === undefined || [ev.movementX, ev.movementY].some(function (m) {\n          return Math.abs(m) > 1;\n        })) // relax drag trigger sensitivity on touch events\n        && (state.isPointerDragging = true);\n\n        // update the pointer pos\n        var offset = getOffset(container);\n        pointerPos.x = ev.pageX - offset.left;\n        pointerPos.y = ev.pageY - offset.top;\n\n        // Move tooltip\n        toolTipElem.style.top = \"\".concat(pointerPos.y, \"px\");\n        toolTipElem.style.left = \"\".concat(pointerPos.x, \"px\");\n\n        // adjust horizontal position to not exceed canvas boundaries\n        toolTipElem.style.transform = \"translate(-\".concat(pointerPos.x / state.width * 100, \"%, \").concat(\n        // flip to above if near bottom\n        state.height - pointerPos.y < 100 ? 'calc(-100% - 8px)' : '21px', \")\");\n\n        //\n\n        function getOffset(el) {\n          var rect = el.getBoundingClientRect(),\n            scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\n            scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n          return {\n            top: rect.top + scrollTop,\n            left: rect.left + scrollLeft\n          };\n        }\n      }, {\n        passive: true\n      });\n    });\n\n    // Handle click/touch events on nodes/links\n    container.addEventListener('pointerup', function (ev) {\n      state.isPointerPressed = false;\n      if (state.isPointerDragging) {\n        state.isPointerDragging = false;\n        return; // don't trigger click events after pointer drag (pan / node drag functionality)\n      }\n\n      var cbEvents = [ev, state.pointerDownEvent];\n      requestAnimationFrame(function () {\n        // trigger click events asynchronously, to allow hoverObj to be set (on frame)\n        if (ev.button === 0) {\n          // mouse left-click or touch\n          if (state.hoverObj) {\n            var fn = state[\"on\".concat(state.hoverObj.type, \"Click\")];\n            fn && fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundClick && state.onBackgroundClick.apply(state, cbEvents);\n          }\n        }\n        if (ev.button === 2) {\n          // mouse right-click\n          if (state.hoverObj) {\n            var _fn = state[\"on\".concat(state.hoverObj.type, \"RightClick\")];\n            _fn && _fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundRightClick && state.onBackgroundRightClick.apply(state, cbEvents);\n          }\n        }\n      });\n    }, {\n      passive: true\n    });\n    container.addEventListener('contextmenu', function (ev) {\n      if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick) return true; // default contextmenu behavior\n      ev.preventDefault();\n      return false;\n    });\n    state.forceGraph(ctx);\n    state.shadowGraph(shadowCtx);\n\n    //\n\n    var refreshShadowCanvas = (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(function () {\n      // wipe canvas\n      clearCanvas(shadowCtx, state.width, state.height);\n\n      // Adjust link hover area\n      state.shadowGraph.linkWidth(function (l) {\n        return (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth)(l) + state.linkHoverPrecision;\n      });\n\n      // redraw\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      state.shadowGraph.globalScale(t.k).tickFrame();\n    }, HOVER_CANVAS_THROTTLE_DELAY);\n    state.flushShadowCanvas = refreshShadowCanvas.flush; // hook to immediately invoke shadow canvas paint\n\n    // Kick-off renderer\n    (this._animationCycle = function animate() {\n      // IIFE\n      var doRedraw = !state.autoPauseRedraw || !!state.needsRedraw || state.forceGraph.isEngineRunning() || state.graphData.links.some(function (d) {\n        return d.__photons && d.__photons.length;\n      });\n      state.needsRedraw = false;\n      if (state.enablePointerInteraction) {\n        // Update tooltip and trigger onHover events\n        var obj = !state.isPointerDragging ? getObjUnderPointer() : null; // don't hover during drag\n        if (obj !== state.hoverObj) {\n          var prevObj = state.hoverObj;\n          var prevObjType = prevObj ? prevObj.type : null;\n          var objType = obj ? obj.type : null;\n          if (prevObjType && prevObjType !== objType) {\n            // Hover out\n            var fn = state[\"on\".concat(prevObjType, \"Hover\")];\n            fn && fn(null, prevObj.d);\n          }\n          if (objType) {\n            // Hover in\n            var _fn2 = state[\"on\".concat(objType, \"Hover\")];\n            _fn2 && _fn2(obj.d, prevObjType === objType ? prevObj.d : null);\n          }\n          var tooltipContent = obj ? (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state[\"\".concat(obj.type.toLowerCase(), \"Label\")])(obj.d) || '' : '';\n          toolTipElem.style.visibility = tooltipContent ? 'visible' : 'hidden';\n          toolTipElem.innerHTML = tooltipContent;\n\n          // set pointer if hovered object is clickable\n          state.canvas.classList[obj && state[\"on\".concat(objType, \"Click\")] || !obj && state.onBackgroundClick ? 'add' : 'remove']('clickable');\n          state.hoverObj = obj;\n        }\n        doRedraw && refreshShadowCanvas();\n      }\n      if (doRedraw) {\n        // Wipe canvas\n        clearCanvas(ctx, state.width, state.height);\n\n        // Frame cycle\n        var globalScale = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n        state.onRenderFramePre && state.onRenderFramePre(ctx, globalScale);\n        state.forceGraph.globalScale(globalScale).tickFrame();\n        state.onRenderFramePost && state.onRenderFramePost(ctx, globalScale);\n      }\n      _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.update(); // update canvas animation tweens\n\n      state.animationFrameRequestId = requestAnimationFrame(animate);\n    })();\n  },\n  update: function updateFn(state) {}\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9yY2UtZ3JhcGgvZGlzdC9mb3JjZS1ncmFwaC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDUTtBQUNmO0FBQ0s7QUFDQztBQUNNO0FBQ2I7QUFDTztBQUNXO0FBQ2tEO0FBQy9EO0FBQ0U7QUFDRztBQUNVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLG1CQUFtQixzQkFBc0Isa0JBQWtCLDZDQUE2QyxHQUFHLDJDQUEyQyx1QkFBdUIsV0FBVyw0QkFBNEIsb0JBQW9CLGlCQUFpQix1QkFBdUIsZ0JBQWdCLGlDQUFpQyx3QkFBd0IsbUJBQW1CLHVDQUF1QyxvQkFBb0IsR0FBRyx1Q0FBdUMsaUJBQWlCLGlCQUFpQixzQkFBc0IseUJBQXlCLEdBQUcsOENBQThDLHFCQUFxQiwwQkFBMEIsNkJBQTZCLEdBQUc7QUFDanRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVksNkVBQTZFO0FBQ2pHLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNB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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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QVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxzREFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsc0RBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7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SDtBQUNBLENBQUM7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWRhcHRhdGlvbi1pbnNpZ2h0cy8uL25vZGVfbW9kdWxlcy9mb3JjZS1ncmFwaC9kaXN0L2ZvcmNlLWdyYXBoLm1qcz9kNzZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XG5pbXBvcnQgeyB6b29tLCB6b29tVHJhbnNmb3JtIH0gZnJvbSAnZDMtem9vbSc7XG5pbXBvcnQgeyBkcmFnIH0gZnJvbSAnZDMtZHJhZyc7XG5pbXBvcnQgeyBtaW4sIG1heCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCAqIGFzIFRXRUVOIGZyb20gJ0B0d2VlbmpzL3R3ZWVuLmpzJztcbmltcG9ydCBLYXBzdWxlIGZyb20gJ2thcHN1bGUnO1xuaW1wb3J0IGFjY2Vzc29yRm4gZnJvbSAnYWNjZXNzb3ItZm4nO1xuaW1wb3J0IENvbG9yVHJhY2tlciBmcm9tICdjYW52YXMtY29sb3ItdHJhY2tlcic7XG5pbXBvcnQgeyBmb3JjZVNpbXVsYXRpb24sIGZvcmNlTGluaywgZm9yY2VNYW55Qm9keSwgZm9yY2VDZW50ZXIsIGZvcmNlUmFkaWFsIH0gZnJvbSAnZDMtZm9yY2UtM2QnO1xuaW1wb3J0IHsgQmV6aWVyIH0gZnJvbSAnYmV6aWVyLWpzJztcbmltcG9ydCBpbmRleEJ5IGZyb20gJ2luZGV4LWFycmF5LWJ5JztcbmltcG9ydCB7IHNjYWxlT3JkaW5hbCB9IGZyb20gJ2QzLXNjYWxlJztcbmltcG9ydCB7IHNjaGVtZVBhaXJlZCB9IGZyb20gJ2QzLXNjYWxlLWNocm9tYXRpYyc7XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmIChyZWYgPT09IHZvaWQgMCkgcmVmID0ge307XG4gIHZhciBpbnNlcnRBdCA9IHJlZi5pbnNlcnRBdDtcbiAgaWYgKCFjc3MgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbnZhciBjc3NfMjQ4eiA9IFwiLmZvcmNlLWdyYXBoLWNvbnRhaW5lciBjYW52YXMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcbn1cXG5cXG4uZm9yY2UtZ3JhcGgtY29udGFpbmVyIC5ncmFwaC10b29sdGlwIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgcGFkZGluZzogNHB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgY29sb3I6ICNlZWU7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuNjUpO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuOyAvKiBieSBkZWZhdWx0ICovXFxufVxcblxcbi5mb3JjZS1ncmFwaC1jb250YWluZXIgLmNsaWNrYWJsZSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5mb3JjZS1ncmFwaC1jb250YWluZXIgLmdyYWJiYWJsZSB7XFxuICBjdXJzb3I6IG1vdmU7XFxuICBjdXJzb3I6IGdyYWI7XFxuICBjdXJzb3I6IC1tb3otZ3JhYjtcXG4gIGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcbn1cXG5cXG4uZm9yY2UtZ3JhcGgtY29udGFpbmVyIC5ncmFiYmFibGU6YWN0aXZlIHtcXG4gIGN1cnNvcjogZ3JhYmJpbmc7XFxuICBjdXJzb3I6IC1tb3otZ3JhYmJpbmc7XFxuICBjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XFxufVxcblwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHopO1xuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IG51bGwgPT0gYXJyID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSBfaSkge1xuICAgIHZhciBfcyxcbiAgICAgIF9lLFxuICAgICAgX3gsXG4gICAgICBfcixcbiAgICAgIF9hcnIgPSBbXSxcbiAgICAgIF9uID0gITAsXG4gICAgICBfZCA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoX3ggPSAoX2kgPSBfaS5jYWxsKGFycikpLm5leHQsIDAgPT09IGkpIHtcbiAgICAgICAgaWYgKE9iamVjdChfaSkgIT09IF9pKSByZXR1cm47XG4gICAgICAgIF9uID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoX24gPSAoX3MgPSBfeC5jYWxsKF9pKSkuZG9uZSkgJiYgKF9hcnIucHVzaChfcy52YWx1ZSksIF9hcnIubGVuZ3RoICE9PSBpKTsgX24gPSAhMCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9ICEwLCBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBudWxsICE9IF9pLnJldHVybiAmJiAoX3IgPSBfaS5yZXR1cm4oKSwgT2JqZWN0KF9yKSAhPT0gX3IpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2FycjtcbiAgfVxufVxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKSA6IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG4gIHRyeSB7XG4gICAgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG52YXIgYXV0b0NvbG9yU2NhbGUgPSBzY2FsZU9yZGluYWwoc2NoZW1lUGFpcmVkKTtcblxuLy8gQXV0b3NldCBhdHRyaWJ1dGUgY29sb3JGaWVsZCBieSBjb2xvckJ5QWNjZXNzb3IgcHJvcGVydHlcbi8vIElmIGFuIG9iamVjdCBoYXMgYWxyZWFkeSBhIGNvbG9yLCBkb24ndCBzZXQgaXRcbi8vIE9iamVjdHMgY2FuIGJlIG5vZGVzIG9yIGxpbmtzXG5mdW5jdGlvbiBhdXRvQ29sb3JPYmplY3RzKG9iamVjdHMsIGNvbG9yQnlBY2Nlc3NvciwgY29sb3JGaWVsZCkge1xuICBpZiAoIWNvbG9yQnlBY2Nlc3NvciB8fCB0eXBlb2YgY29sb3JGaWVsZCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgb2JqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiAhb2JqW2NvbG9yRmllbGRdO1xuICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBvYmpbY29sb3JGaWVsZF0gPSBhdXRvQ29sb3JTY2FsZShjb2xvckJ5QWNjZXNzb3Iob2JqKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXREYWdEZXB0aHMgKF9yZWYsIGlkQWNjZXNzb3IpIHtcbiAgdmFyIG5vZGVzID0gX3JlZi5ub2RlcyxcbiAgICBsaW5rcyA9IF9yZWYubGlua3M7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgX3JlZjIkbm9kZUZpbHRlciA9IF9yZWYyLm5vZGVGaWx0ZXIsXG4gICAgbm9kZUZpbHRlciA9IF9yZWYyJG5vZGVGaWx0ZXIgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gOiBfcmVmMiRub2RlRmlsdGVyLFxuICAgIF9yZWYyJG9uTG9vcEVycm9yID0gX3JlZjIub25Mb29wRXJyb3IsXG4gICAgb25Mb29wRXJyb3IgPSBfcmVmMiRvbkxvb3BFcnJvciA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKGxvb3BJZHMpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBEQUcgc3RydWN0dXJlISBGb3VuZCBjeWNsZSBpbiBub2RlIHBhdGg6IFwiLmNvbmNhdChsb29wSWRzLmpvaW4oJyAtPiAnKSwgXCIuXCIpO1xuICAgIH0gOiBfcmVmMiRvbkxvb3BFcnJvcjtcbiAgLy8gbGlua2VkIGdyYXBoXG4gIHZhciBncmFwaCA9IHt9O1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIGdyYXBoW2lkQWNjZXNzb3Iobm9kZSldID0ge1xuICAgICAgZGF0YTogbm9kZSxcbiAgICAgIG91dDogW10sXG4gICAgICBkZXB0aDogLTEsXG4gICAgICBza2lwOiAhbm9kZUZpbHRlcihub2RlKVxuICAgIH07XG4gIH0pO1xuICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgIHZhciBzb3VyY2UgPSBfcmVmMy5zb3VyY2UsXG4gICAgICB0YXJnZXQgPSBfcmVmMy50YXJnZXQ7XG4gICAgdmFyIHNvdXJjZUlkID0gZ2V0Tm9kZUlkKHNvdXJjZSk7XG4gICAgdmFyIHRhcmdldElkID0gZ2V0Tm9kZUlkKHRhcmdldCk7XG4gICAgaWYgKCFncmFwaC5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHRocm93IFwiTWlzc2luZyBzb3VyY2Ugbm9kZSB3aXRoIGlkOiBcIi5jb25jYXQoc291cmNlSWQpO1xuICAgIGlmICghZ3JhcGguaGFzT3duUHJvcGVydHkodGFyZ2V0SWQpKSB0aHJvdyBcIk1pc3NpbmcgdGFyZ2V0IG5vZGUgd2l0aCBpZDogXCIuY29uY2F0KHRhcmdldElkKTtcbiAgICB2YXIgc291cmNlTm9kZSA9IGdyYXBoW3NvdXJjZUlkXTtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IGdyYXBoW3RhcmdldElkXTtcbiAgICBzb3VyY2VOb2RlLm91dC5wdXNoKHRhcmdldE5vZGUpO1xuICAgIGZ1bmN0aW9uIGdldE5vZGVJZChub2RlKSB7XG4gICAgICByZXR1cm4gX3R5cGVvZihub2RlKSA9PT0gJ29iamVjdCcgPyBpZEFjY2Vzc29yKG5vZGUpIDogbm9kZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgZm91bmRMb29wcyA9IFtdO1xuICB0cmF2ZXJzZShPYmplY3QudmFsdWVzKGdyYXBoKSk7XG4gIHZhciBub2RlRGVwdGhzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFt7fV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShPYmplY3QuZW50cmllcyhncmFwaCkuZmlsdGVyKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgIHZhciBfcmVmNSA9IF9zbGljZWRUb0FycmF5KF9yZWY0LCAyKSxcbiAgICAgIG5vZGUgPSBfcmVmNVsxXTtcbiAgICByZXR1cm4gIW5vZGUuc2tpcDtcbiAgfSkubWFwKGZ1bmN0aW9uIChfcmVmNikge1xuICAgIHZhciBfcmVmNyA9IF9zbGljZWRUb0FycmF5KF9yZWY2LCAyKSxcbiAgICAgIGlkID0gX3JlZjdbMF0sXG4gICAgICBub2RlID0gX3JlZjdbMV07XG4gICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgaWQsIG5vZGUuZGVwdGgpO1xuICB9KSkpKTtcbiAgcmV0dXJuIG5vZGVEZXB0aHM7XG4gIGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGVzKSB7XG4gICAgdmFyIG5vZGVTdGFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgdmFyIGN1cnJlbnREZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZVN0YWNrLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgIHZhciBsb29wID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlU3RhY2suc2xpY2Uobm9kZVN0YWNrLmluZGV4T2Yobm9kZSkpKSwgW25vZGVdKS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gaWRBY2Nlc3NvcihkLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmb3VuZExvb3BzLnNvbWUoZnVuY3Rpb24gKGZvdW5kTG9vcCkge1xuICAgICAgICAgIHJldHVybiBmb3VuZExvb3AubGVuZ3RoID09PSBsb29wLmxlbmd0aCAmJiBmb3VuZExvb3AuZXZlcnkoZnVuY3Rpb24gKGlkLCBpZHgpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCA9PT0gbG9vcFtpZHhdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIGZvdW5kTG9vcHMucHVzaChsb29wKTtcbiAgICAgICAgICBvbkxvb3BFcnJvcihsb29wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTsgLy8gY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50RGVwdGggPiBub2RlLmRlcHRoKSB7XG4gICAgICAgIC8vIERvbid0IHVubmVjZXNzYXJpbHkgcmV2aXNpdCBjaHVua3Mgb2YgdGhlIGdyYXBoXG4gICAgICAgIG5vZGUuZGVwdGggPSBjdXJyZW50RGVwdGg7XG4gICAgICAgIHRyYXZlcnNlKG5vZGUub3V0LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGVTdGFjayksIFtub2RlXSksIGN1cnJlbnREZXB0aCArIChub2RlLnNraXAgPyAwIDogMSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChfbG9vcCgpKSBjb250aW51ZTtcbiAgICB9XG4gIH1cbn1cblxuLy9cblxudmFyIERBR19MRVZFTF9OT0RFX1JBVElPID0gMjtcblxuLy8gd2hlbmV2ZXIgc3R5bGluZyBwcm9wcyBhcmUgY2hhbmdlZCB0aGF0IHJlcXVpcmUgYSBjYW52YXMgcmVkcmF3XG52YXIgbm90aWZ5UmVkcmF3ID0gZnVuY3Rpb24gbm90aWZ5UmVkcmF3KF8sIHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5vbk5lZWRzUmVkcmF3ICYmIHN0YXRlLm9uTmVlZHNSZWRyYXcoKTtcbn07XG52YXIgdXBkRGF0YVBob3RvbnMgPSBmdW5jdGlvbiB1cGREYXRhUGhvdG9ucyhfLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmlzU2hhZG93KSB7XG4gICAgLy8gQWRkIHBob3RvbiBwYXJ0aWNsZXNcbiAgICB2YXIgbGlua1BhcnRpY2xlc0FjY2Vzc29yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMpO1xuICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICB2YXIgbnVtUGhvdG9ucyA9IE1hdGgucm91bmQoTWF0aC5hYnMobGlua1BhcnRpY2xlc0FjY2Vzc29yKGxpbmspKSk7XG4gICAgICBpZiAobnVtUGhvdG9ucykge1xuICAgICAgICBsaW5rLl9fcGhvdG9ucyA9IF90b0NvbnN1bWFibGVBcnJheShBcnJheShudW1QaG90b25zKSkubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGxpbmsuX19waG90b25zO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIENhbnZhc0ZvcmNlR3JhcGggPSBLYXBzdWxlKHtcbiAgcHJvcHM6IHtcbiAgICBncmFwaERhdGE6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgbGlua3M6IFtdXG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKF8sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSBmYWxzZTsgLy8gUGF1c2Ugc2ltdWxhdGlvblxuICAgICAgICB1cGREYXRhUGhvdG9ucyhfLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkYWdNb2RlOiB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZGFnTW9kZSwgc3RhdGUpIHtcbiAgICAgICAgLy8gdGQsIGJ1LCBsciwgcmwsIHJhZGlhbGluLCByYWRpYWxvdXRcbiAgICAgICAgIWRhZ01vZGUgJiYgKHN0YXRlLmdyYXBoRGF0YS5ub2RlcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiBuLmZ4ID0gbi5meSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7IC8vIHVuZml4IG5vZGVzIHdoZW4gZGlzYWJsaW5nIGRhZyBtb2RlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGRhZ0xldmVsRGlzdGFuY2U6IHt9LFxuICAgIGRhZ05vZGVGaWx0ZXI6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdChub2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25EYWdFcnJvcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG5vZGVSZWxTaXplOiB7XG4gICAgICBcImRlZmF1bHRcIjogNCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgLy8gYXJlYSBwZXIgdmFsIHVuaXRcbiAgICBub2RlSWQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnaWQnXG4gICAgfSxcbiAgICBub2RlVmFsOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ3ZhbCcsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIG5vZGVDb2xvcjoge1xuICAgICAgXCJkZWZhdWx0XCI6ICdjb2xvcicsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIG5vZGVBdXRvQ29sb3JCeToge30sXG4gICAgbm9kZUNhbnZhc09iamVjdDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBub2RlQ2FudmFzT2JqZWN0TW9kZToge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ3JlcGxhY2UnO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbm9kZVZpc2liaWxpdHk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rU291cmNlOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ3NvdXJjZSdcbiAgICB9LFxuICAgIGxpbmtUYXJnZXQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAndGFyZ2V0J1xuICAgIH0sXG4gICAgbGlua1Zpc2liaWxpdHk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rQ29sb3I6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnY29sb3InLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rQXV0b0NvbG9yQnk6IHt9LFxuICAgIGxpbmtMaW5lRGFzaDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rV2lkdGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rQ3VydmF0dXJlOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0NhbnZhc09iamVjdDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rQ2FudmFzT2JqZWN0TW9kZToge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ3JlcGxhY2UnO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd0NvbG9yOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93UmVsUG9zOiB7XG4gICAgICBcImRlZmF1bHRcIjogMC41LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICAvLyB2YWx1ZSBiZXR3ZWVuIDA8PjEgaW5kaWNhdGluZyB0aGUgcmVsYXRpdmUgcG9zIGFsb25nIHRoZSAoZXhwb3NlZCkgbGluZVxuICAgIGxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlczoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiB1cGREYXRhUGhvdG9uc1xuICAgIH0sXG4gICAgLy8gYW5pbWF0ZSBwaG90b25zIHRyYXZlbGxpbmcgaW4gdGhlIGxpbmsgZGlyZWN0aW9uXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuMDEsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gaW4gbGluayBsZW5ndGggcmF0aW8gcGVyIGZyYW1lXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDQsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGdsb2JhbFNjYWxlOiB7XG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBkM0FscGhhTWluOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBkM0FscGhhRGVjYXk6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjAyMjgsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShhbHBoYURlY2F5LCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5mb3JjZUxheW91dC5hbHBoYURlY2F5KGFscGhhRGVjYXkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZDNBbHBoYVRhcmdldDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShhbHBoYVRhcmdldCwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGFUYXJnZXQoYWxwaGFUYXJnZXQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZDNWZWxvY2l0eURlY2F5OiB7XG4gICAgICBcImRlZmF1bHRcIjogMC40LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UodmVsb2NpdHlEZWNheSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZm9yY2VMYXlvdXQudmVsb2NpdHlEZWNheSh2ZWxvY2l0eURlY2F5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhcm11cFRpY2tzOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBob3cgbWFueSB0aW1lcyB0byB0aWNrIHRoZSBmb3JjZSBlbmdpbmUgYXQgaW5pdCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVuZGVyXG4gICAgY29vbGRvd25UaWNrczoge1xuICAgICAgXCJkZWZhdWx0XCI6IEluZmluaXR5LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGNvb2xkb3duVGltZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDE1MDAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIG1zXG4gICAgb25VcGRhdGU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uRmluaXNoVXBkYXRlOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkVuZ2luZVRpY2s6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uRW5naW5lU3RvcDoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25OZWVkc1JlZHJhdzoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGlzU2hhZG93OiB7XG4gICAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIC8vIEV4cG9zZSBkMyBmb3JjZXMgZm9yIGV4dGVybmFsIG1hbmlwdWxhdGlvblxuICAgIGQzRm9yY2U6IGZ1bmN0aW9uIGQzRm9yY2Uoc3RhdGUsIGZvcmNlTmFtZSwgZm9yY2VGbikge1xuICAgICAgaWYgKGZvcmNlRm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoZm9yY2VOYW1lKTsgLy8gRm9yY2UgZ2V0dGVyXG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LmZvcmNlKGZvcmNlTmFtZSwgZm9yY2VGbik7IC8vIEZvcmNlIHNldHRlclxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkM1JlaGVhdFNpbXVsYXRpb246IGZ1bmN0aW9uIGQzUmVoZWF0U2ltdWxhdGlvbihzdGF0ZSkge1xuICAgICAgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGEoMSk7XG4gICAgICB0aGlzLnJlc2V0Q291bnRkb3duKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIHJlc2V0IGNvb2xkb3duIHN0YXRlXG4gICAgcmVzZXRDb3VudGRvd246IGZ1bmN0aW9uIHJlc2V0Q291bnRkb3duKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5jbnRUaWNrcyA9IDA7XG4gICAgICBzdGF0ZS5zdGFydFRpY2tUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpc0VuZ2luZVJ1bm5pbmc6IGZ1bmN0aW9uIGlzRW5naW5lUnVubmluZyhzdGF0ZSkge1xuICAgICAgcmV0dXJuICEhc3RhdGUuZW5naW5lUnVubmluZztcbiAgICB9LFxuICAgIHRpY2tGcmFtZTogZnVuY3Rpb24gdGlja0ZyYW1lKHN0YXRlKSB7XG4gICAgICAhc3RhdGUuaXNTaGFkb3cgJiYgbGF5b3V0VGljaygpO1xuICAgICAgcGFpbnRMaW5rcygpO1xuICAgICAgIXN0YXRlLmlzU2hhZG93ICYmIHBhaW50QXJyb3dzKCk7XG4gICAgICAhc3RhdGUuaXNTaGFkb3cgJiYgcGFpbnRQaG90b25zKCk7XG4gICAgICBwYWludE5vZGVzKCk7XG4gICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy9cblxuICAgICAgZnVuY3Rpb24gbGF5b3V0VGljaygpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZ2luZVJ1bm5pbmcpIHtcbiAgICAgICAgICBpZiAoKytzdGF0ZS5jbnRUaWNrcyA+IHN0YXRlLmNvb2xkb3duVGlja3MgfHwgbmV3IERhdGUoKSAtIHN0YXRlLnN0YXJ0VGlja1RpbWUgPiBzdGF0ZS5jb29sZG93blRpbWUgfHwgc3RhdGUuZDNBbHBoYU1pbiA+IDAgJiYgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGEoKSA8IHN0YXRlLmQzQWxwaGFNaW4pIHtcbiAgICAgICAgICAgIHN0YXRlLmVuZ2luZVJ1bm5pbmcgPSBmYWxzZTsgLy8gU3RvcCB0aWNraW5nIGdyYXBoXG4gICAgICAgICAgICBzdGF0ZS5vbkVuZ2luZVN0b3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuZm9yY2VMYXlvdXQudGljaygpOyAvLyBUaWNrIGl0XG4gICAgICAgICAgICBzdGF0ZS5vbkVuZ2luZVRpY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhaW50Tm9kZXMoKSB7XG4gICAgICAgIHZhciBnZXRWaXNpYmlsaXR5ID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlVmlzaWJpbGl0eSk7XG4gICAgICAgIHZhciBnZXRWYWwgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVWYWwpO1xuICAgICAgICB2YXIgZ2V0Q29sb3IgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVDb2xvcik7XG4gICAgICAgIHZhciBnZXROb2RlQ2FudmFzT2JqZWN0TW9kZSA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZUNhbnZhc09iamVjdE1vZGUpO1xuICAgICAgICB2YXIgY3R4ID0gc3RhdGUuY3R4O1xuXG4gICAgICAgIC8vIERyYXcgd2lkZXIgbm9kZXMgYnkgMXB4IG9uIHNoYWRvdyBjYW52YXMgZm9yIG1vcmUgcHJlY2lzZSBob3ZlcmluZyAoZHVlIHRvIGJvdW5kYXJ5IGFudGktYWxpYXNpbmcpXG4gICAgICAgIHZhciBwYWRBbW91bnQgPSBzdGF0ZS5pc1NoYWRvdyAvIHN0YXRlLmdsb2JhbFNjYWxlO1xuICAgICAgICB2YXIgdmlzaWJsZU5vZGVzID0gc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmZpbHRlcihnZXRWaXNpYmlsaXR5KTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgdmlzaWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgbm9kZUNhbnZhc09iamVjdE1vZGUgPSBnZXROb2RlQ2FudmFzT2JqZWN0TW9kZShub2RlKTtcbiAgICAgICAgICBpZiAoc3RhdGUubm9kZUNhbnZhc09iamVjdCAmJiAobm9kZUNhbnZhc09iamVjdE1vZGUgPT09ICdiZWZvcmUnIHx8IG5vZGVDYW52YXNPYmplY3RNb2RlID09PSAncmVwbGFjZScpKSB7XG4gICAgICAgICAgICAvLyBDdXN0b20gbm9kZSBiZWZvcmUvcmVwbGFjZSBwYWludFxuICAgICAgICAgICAgc3RhdGUubm9kZUNhbnZhc09iamVjdChub2RlLCBjdHgsIHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgICAgIGlmIChub2RlQ2FudmFzT2JqZWN0TW9kZSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEcmF3IHdpZGVyIG5vZGVzIGJ5IDFweCBvbiBzaGFkb3cgY2FudmFzIGZvciBtb3JlIHByZWNpc2UgaG92ZXJpbmcgKGR1ZSB0byBib3VuZGFyeSBhbnRpLWFsaWFzaW5nKVxuICAgICAgICAgIHZhciByID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldFZhbChub2RlKSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZSArIHBhZEFtb3VudDtcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4LmFyYyhub2RlLngsIG5vZGUueSwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ2V0Q29sb3Iobm9kZSkgfHwgJ3JnYmEoMzEsIDEyMCwgMTgwLCAwLjkyKSc7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICBpZiAoc3RhdGUubm9kZUNhbnZhc09iamVjdCAmJiBub2RlQ2FudmFzT2JqZWN0TW9kZSA9PT0gJ2FmdGVyJykge1xuICAgICAgICAgICAgLy8gQ3VzdG9tIG5vZGUgYWZ0ZXIgcGFpbnRcbiAgICAgICAgICAgIHN0YXRlLm5vZGVDYW52YXNPYmplY3Qobm9kZSwgc3RhdGUuY3R4LCBzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhaW50TGlua3MoKSB7XG4gICAgICAgIHZhciBnZXRWaXNpYmlsaXR5ID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rVmlzaWJpbGl0eSk7XG4gICAgICAgIHZhciBnZXRDb2xvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0NvbG9yKTtcbiAgICAgICAgdmFyIGdldFdpZHRoID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rV2lkdGgpO1xuICAgICAgICB2YXIgZ2V0TGluZURhc2ggPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtMaW5lRGFzaCk7XG4gICAgICAgIHZhciBnZXRDdXJ2YXR1cmUgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtDdXJ2YXR1cmUpO1xuICAgICAgICB2YXIgZ2V0TGlua0NhbnZhc09iamVjdE1vZGUgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtDYW52YXNPYmplY3RNb2RlKTtcbiAgICAgICAgdmFyIGN0eCA9IHN0YXRlLmN0eDtcblxuICAgICAgICAvLyBEcmF3IHdpZGVyIGxpbmVzIGJ5IDJweCBvbiBzaGFkb3cgY2FudmFzIGZvciBtb3JlIHByZWNpc2UgaG92ZXJpbmcgKGR1ZSB0byBib3VuZGFyeSBhbnRpLWFsaWFzaW5nKVxuICAgICAgICB2YXIgcGFkQW1vdW50ID0gc3RhdGUuaXNTaGFkb3cgKiAyO1xuICAgICAgICB2YXIgdmlzaWJsZUxpbmtzID0gc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmZpbHRlcihnZXRWaXNpYmlsaXR5KTtcbiAgICAgICAgdmlzaWJsZUxpbmtzLmZvckVhY2goY2FsY0xpbmtDb250cm9sUG9pbnRzKTsgLy8gY2FsY3VsYXRlIGN1cnZhdHVyZSBjb250cm9sIHBvaW50cyBmb3IgYWxsIHZpc2libGUgbGlua3NcblxuICAgICAgICB2YXIgYmVmb3JlQ3VzdG9tTGlua3MgPSBbXSxcbiAgICAgICAgICBhZnRlckN1c3RvbUxpbmtzID0gW10sXG4gICAgICAgICAgZGVmYXVsdFBhaW50TGlua3MgPSB2aXNpYmxlTGlua3M7XG4gICAgICAgIGlmIChzdGF0ZS5saW5rQ2FudmFzT2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VDdXN0b21MaW5rcyA9IFtdLFxuICAgICAgICAgICAgb3RoZXJDdXN0b21MaW5rcyA9IFtdO1xuICAgICAgICAgIHZpc2libGVMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmVDdXN0b21MaW5rcyxcbiAgICAgICAgICAgICAgYWZ0ZXI6IGFmdGVyQ3VzdG9tTGlua3MsXG4gICAgICAgICAgICAgIHJlcGxhY2U6IHJlcGxhY2VDdXN0b21MaW5rc1xuICAgICAgICAgICAgfVtnZXRMaW5rQ2FudmFzT2JqZWN0TW9kZShkKV0gfHwgb3RoZXJDdXN0b21MaW5rcykucHVzaChkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWZhdWx0UGFpbnRMaW5rcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYmVmb3JlQ3VzdG9tTGlua3MpLCBhZnRlckN1c3RvbUxpbmtzLCBvdGhlckN1c3RvbUxpbmtzKTtcbiAgICAgICAgICBiZWZvcmVDdXN0b21MaW5rcyA9IGJlZm9yZUN1c3RvbUxpbmtzLmNvbmNhdChyZXBsYWNlQ3VzdG9tTGlua3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3VzdG9tIGxpbmsgYmVmb3JlIHBhaW50c1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBiZWZvcmVDdXN0b21MaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmxpbmtDYW52YXNPYmplY3QobGluaywgY3R4LCBzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vIEJ1bmRsZSBzdHJva2VzIHBlciB1bmlxdWUgY29sb3Ivd2lkdGgvZGFzaCBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uXG4gICAgICAgIHZhciBsaW5rc1BlckNvbG9yID0gaW5kZXhCeShkZWZhdWx0UGFpbnRMaW5rcywgW2dldENvbG9yLCBnZXRXaWR0aCwgZ2V0TGluZURhc2hdKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMobGlua3NQZXJDb2xvcikuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgICAgY29sb3IgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIGxpbmtzUGVyV2lkdGggPSBfcmVmMlsxXTtcbiAgICAgICAgICB2YXIgbGluZUNvbG9yID0gIWNvbG9yIHx8IGNvbG9yID09PSAndW5kZWZpbmVkJyA/ICdyZ2JhKDAsMCwwLDAuMTUpJyA6IGNvbG9yO1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGxpbmtzUGVyV2lkdGgpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgICAgICAgIHdpZHRoID0gX3JlZjRbMF0sXG4gICAgICAgICAgICAgIGxpbmVzUGVyTGluZURhc2ggPSBfcmVmNFsxXTtcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSAod2lkdGggfHwgMSkgLyBzdGF0ZS5nbG9iYWxTY2FsZSArIHBhZEFtb3VudDtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGxpbmVzUGVyTGluZURhc2gpLmZvckVhY2goZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKTtcbiAgICAgICAgICAgICAgICBfcmVmNlswXTtcbiAgICAgICAgICAgICAgICB2YXIgbGlua3MgPSBfcmVmNlsxXTtcbiAgICAgICAgICAgICAgdmFyIGxpbmVEYXNoU2VnbWVudHMgPSBnZXRMaW5lRGFzaChsaW5rc1swXSk7XG4gICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlO1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHN0YXJ0LngsIHN0YXJ0LnkpO1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gbGluay5fX2NvbnRyb2xQb2ludHM7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250cm9sUG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTdHJhaWdodCBsaW5lXG4gICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGVuZC54LCBlbmQueSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFVzZSBxdWFkcmF0aWMgY3VydmVzIGZvciByZWd1bGFyIGxpbmVzIGFuZCBiZXppZXIgZm9yIGxvb3BzXG4gICAgICAgICAgICAgICAgICBjdHhbY29udHJvbFBvaW50cy5sZW5ndGggPT09IDIgPyAncXVhZHJhdGljQ3VydmVUbycgOiAnYmV6aWVyQ3VydmVUbyddLmFwcGx5KGN0eCwgX3RvQ29uc3VtYWJsZUFycmF5KGNvbnRyb2xQb2ludHMpLmNvbmNhdChbZW5kLngsIGVuZC55XSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxpbmVDb2xvcjtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoU2VnbWVudHMgfHwgW10pO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy8gQ3VzdG9tIGxpbmsgYWZ0ZXIgcGFpbnRzXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGFmdGVyQ3VzdG9tTGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5saW5rQ2FudmFzT2JqZWN0KGxpbmssIGN0eCwgc3RhdGUuZ2xvYmFsU2NhbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAvL1xuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGNMaW5rQ29udHJvbFBvaW50cyhsaW5rKSB7XG4gICAgICAgICAgdmFyIGN1cnZhdHVyZSA9IGdldEN1cnZhdHVyZShsaW5rKTtcbiAgICAgICAgICBpZiAoIWN1cnZhdHVyZSkge1xuICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZVxuICAgICAgICAgICAgbGluay5fX2NvbnRyb2xQb2ludHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RhcnQgPSBsaW5rLnNvdXJjZTtcbiAgICAgICAgICB2YXIgZW5kID0gbGluay50YXJnZXQ7XG4gICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kIHx8ICFzdGFydC5oYXNPd25Qcm9wZXJ0eSgneCcpIHx8ICFlbmQuaGFzT3duUHJvcGVydHkoJ3gnKSkgcmV0dXJuOyAvLyBza2lwIGludmFsaWQgbGlua1xuXG4gICAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoTWF0aC5wb3coZW5kLnggLSBzdGFydC54LCAyKSArIE1hdGgucG93KGVuZC55IC0gc3RhcnQueSwgMikpOyAvLyBsaW5lIGxlbmd0aFxuXG4gICAgICAgICAgaWYgKGwgPiAwKSB7XG4gICAgICAgICAgICB2YXIgYSA9IE1hdGguYXRhbjIoZW5kLnkgLSBzdGFydC55LCBlbmQueCAtIHN0YXJ0LngpOyAvLyBsaW5lIGFuZ2xlXG4gICAgICAgICAgICB2YXIgZCA9IGwgKiBjdXJ2YXR1cmU7IC8vIGNvbnRyb2wgcG9pbnQgZGlzdGFuY2VcblxuICAgICAgICAgICAgdmFyIGNwID0ge1xuICAgICAgICAgICAgICAvLyBjb250cm9sIHBvaW50XG4gICAgICAgICAgICAgIHg6IChzdGFydC54ICsgZW5kLngpIC8gMiArIGQgKiBNYXRoLmNvcyhhIC0gTWF0aC5QSSAvIDIpLFxuICAgICAgICAgICAgICB5OiAoc3RhcnQueSArIGVuZC55KSAvIDIgKyBkICogTWF0aC5zaW4oYSAtIE1hdGguUEkgLyAyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxpbmsuX19jb250cm9sUG9pbnRzID0gW2NwLngsIGNwLnldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTYW1lIHBvaW50LCBkcmF3IGEgbG9vcFxuICAgICAgICAgICAgdmFyIF9kID0gY3VydmF0dXJlICogNzA7XG4gICAgICAgICAgICBsaW5rLl9fY29udHJvbFBvaW50cyA9IFtlbmQueCwgZW5kLnkgLSBfZCwgZW5kLnggKyBfZCwgZW5kLnldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFpbnRBcnJvd3MoKSB7XG4gICAgICAgIHZhciBBUlJPV19XSF9SQVRJTyA9IDEuNjtcbiAgICAgICAgdmFyIEFSUk9XX1ZMRU5fUkFUSU8gPSAwLjI7XG4gICAgICAgIHZhciBnZXRMZW5ndGggPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoKTtcbiAgICAgICAgdmFyIGdldFJlbFBvcyA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3MpO1xuICAgICAgICB2YXIgZ2V0VmlzaWJpbGl0eSA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1Zpc2liaWxpdHkpO1xuICAgICAgICB2YXIgZ2V0Q29sb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbEFycm93Q29sb3IgfHwgc3RhdGUubGlua0NvbG9yKTtcbiAgICAgICAgdmFyIGdldE5vZGVWYWwgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVWYWwpO1xuICAgICAgICB2YXIgY3R4ID0gc3RhdGUuY3R4O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZmlsdGVyKGdldFZpc2liaWxpdHkpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICB2YXIgYXJyb3dMZW5ndGggPSBnZXRMZW5ndGgobGluayk7XG4gICAgICAgICAgaWYgKCFhcnJvd0xlbmd0aCB8fCBhcnJvd0xlbmd0aCA8IDApIHJldHVybjtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBsaW5rLnNvdXJjZTtcbiAgICAgICAgICB2YXIgZW5kID0gbGluay50YXJnZXQ7XG4gICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kIHx8ICFzdGFydC5oYXNPd25Qcm9wZXJ0eSgneCcpIHx8ICFlbmQuaGFzT3duUHJvcGVydHkoJ3gnKSkgcmV0dXJuOyAvLyBza2lwIGludmFsaWQgbGlua1xuXG4gICAgICAgICAgdmFyIHN0YXJ0UiA9IE1hdGguc3FydChNYXRoLm1heCgwLCBnZXROb2RlVmFsKHN0YXJ0KSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgICAgICB2YXIgZW5kUiA9IE1hdGguc3FydChNYXRoLm1heCgwLCBnZXROb2RlVmFsKGVuZCkgfHwgMSkpICogc3RhdGUubm9kZVJlbFNpemU7XG4gICAgICAgICAgdmFyIGFycm93UmVsUG9zID0gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgZ2V0UmVsUG9zKGxpbmspKSk7XG4gICAgICAgICAgdmFyIGFycm93Q29sb3IgPSBnZXRDb2xvcihsaW5rKSB8fCAncmdiYSgwLDAsMCwwLjI4KSc7XG4gICAgICAgICAgdmFyIGFycm93SGFsZldpZHRoID0gYXJyb3dMZW5ndGggLyBBUlJPV19XSF9SQVRJTyAvIDI7XG5cbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgYmV6aWVyIGZvciBjdXJ2ZWQgbGluZXNcbiAgICAgICAgICB2YXIgYnpMaW5lID0gbGluay5fX2NvbnRyb2xQb2ludHMgJiYgX2NvbnN0cnVjdChCZXppZXIsIFtzdGFydC54LCBzdGFydC55XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxpbmsuX19jb250cm9sUG9pbnRzKSwgW2VuZC54LCBlbmQueV0pKTtcbiAgICAgICAgICB2YXIgZ2V0Q29vcmRzQWxvbmdMaW5lID0gYnpMaW5lID8gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBiekxpbmUuZ2V0KHQpO1xuICAgICAgICAgIH0gLy8gZ2V0IHBvc2l0aW9uIGFsb25nIGJlemllciBsaW5lXG4gICAgICAgICAgOiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLy8gc3RyYWlnaHQgbGluZTogaW50ZXJwb2xhdGUgbGluZWFybHlcbiAgICAgICAgICAgICAgeDogc3RhcnQueCArIChlbmQueCAtIHN0YXJ0LngpICogdCB8fCAwLFxuICAgICAgICAgICAgICB5OiBzdGFydC55ICsgKGVuZC55IC0gc3RhcnQueSkgKiB0IHx8IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgbGluZUxlbiA9IGJ6TGluZSA/IGJ6TGluZS5sZW5ndGgoKSA6IE1hdGguc3FydChNYXRoLnBvdyhlbmQueCAtIHN0YXJ0LngsIDIpICsgTWF0aC5wb3coZW5kLnkgLSBzdGFydC55LCAyKSk7XG4gICAgICAgICAgdmFyIHBvc0Fsb25nTGluZSA9IHN0YXJ0UiArIGFycm93TGVuZ3RoICsgKGxpbmVMZW4gLSBzdGFydFIgLSBlbmRSIC0gYXJyb3dMZW5ndGgpICogYXJyb3dSZWxQb3M7XG4gICAgICAgICAgdmFyIGFycm93SGVhZCA9IGdldENvb3Jkc0Fsb25nTGluZShwb3NBbG9uZ0xpbmUgLyBsaW5lTGVuKTtcbiAgICAgICAgICB2YXIgYXJyb3dUYWlsID0gZ2V0Q29vcmRzQWxvbmdMaW5lKChwb3NBbG9uZ0xpbmUgLSBhcnJvd0xlbmd0aCkgLyBsaW5lTGVuKTtcbiAgICAgICAgICB2YXIgYXJyb3dUYWlsVmVydGV4ID0gZ2V0Q29vcmRzQWxvbmdMaW5lKChwb3NBbG9uZ0xpbmUgLSBhcnJvd0xlbmd0aCAqICgxIC0gQVJST1dfVkxFTl9SQVRJTykpIC8gbGluZUxlbik7XG4gICAgICAgICAgdmFyIGFycm93VGFpbEFuZ2xlID0gTWF0aC5hdGFuMihhcnJvd0hlYWQueSAtIGFycm93VGFpbC55LCBhcnJvd0hlYWQueCAtIGFycm93VGFpbC54KSAtIE1hdGguUEkgLyAyO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKGFycm93SGVhZC54LCBhcnJvd0hlYWQueSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhhcnJvd1RhaWwueCArIGFycm93SGFsZldpZHRoICogTWF0aC5jb3MoYXJyb3dUYWlsQW5nbGUpLCBhcnJvd1RhaWwueSArIGFycm93SGFsZldpZHRoICogTWF0aC5zaW4oYXJyb3dUYWlsQW5nbGUpKTtcbiAgICAgICAgICBjdHgubGluZVRvKGFycm93VGFpbFZlcnRleC54LCBhcnJvd1RhaWxWZXJ0ZXgueSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhhcnJvd1RhaWwueCAtIGFycm93SGFsZldpZHRoICogTWF0aC5jb3MoYXJyb3dUYWlsQW5nbGUpLCBhcnJvd1RhaWwueSAtIGFycm93SGFsZldpZHRoICogTWF0aC5zaW4oYXJyb3dUYWlsQW5nbGUpKTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYXJyb3dDb2xvcjtcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBhaW50UGhvdG9ucygpIHtcbiAgICAgICAgdmFyIGdldE51bVBob3RvbnMgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlcyk7XG4gICAgICAgIHZhciBnZXRTcGVlZCA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZCk7XG4gICAgICAgIHZhciBnZXREaWFtZXRlciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aCk7XG4gICAgICAgIHZhciBnZXRWaXNpYmlsaXR5ID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rVmlzaWJpbGl0eSk7XG4gICAgICAgIHZhciBnZXRDb2xvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVDb2xvciB8fCBzdGF0ZS5saW5rQ29sb3IpO1xuICAgICAgICB2YXIgY3R4ID0gc3RhdGUuY3R4O1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZmlsdGVyKGdldFZpc2liaWxpdHkpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICB2YXIgbnVtQ3ljbGVQaG90b25zID0gZ2V0TnVtUGhvdG9ucyhsaW5rKTtcbiAgICAgICAgICBpZiAoIWxpbmsuaGFzT3duUHJvcGVydHkoJ19fcGhvdG9ucycpIHx8ICFsaW5rLl9fcGhvdG9ucy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBsaW5rLnNvdXJjZTtcbiAgICAgICAgICB2YXIgZW5kID0gbGluay50YXJnZXQ7XG4gICAgICAgICAgaWYgKCFzdGFydCB8fCAhZW5kIHx8ICFzdGFydC5oYXNPd25Qcm9wZXJ0eSgneCcpIHx8ICFlbmQuaGFzT3duUHJvcGVydHkoJ3gnKSkgcmV0dXJuOyAvLyBza2lwIGludmFsaWQgbGlua1xuXG4gICAgICAgICAgdmFyIHBhcnRpY2xlU3BlZWQgPSBnZXRTcGVlZChsaW5rKTtcbiAgICAgICAgICB2YXIgcGhvdG9ucyA9IGxpbmsuX19waG90b25zIHx8IFtdO1xuICAgICAgICAgIHZhciBwaG90b25SID0gTWF0aC5tYXgoMCwgZ2V0RGlhbWV0ZXIobGluaykgLyAyKSAvIE1hdGguc3FydChzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgICAgdmFyIHBob3RvbkNvbG9yID0gZ2V0Q29sb3IobGluaykgfHwgJ3JnYmEoMCwwLDAsMC4yOCknO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBwaG90b25Db2xvcjtcblxuICAgICAgICAgIC8vIENvbnN0cnVjdCBiZXppZXIgZm9yIGN1cnZlZCBsaW5lc1xuICAgICAgICAgIHZhciBiekxpbmUgPSBsaW5rLl9fY29udHJvbFBvaW50cyA/IF9jb25zdHJ1Y3QoQmV6aWVyLCBbc3RhcnQueCwgc3RhcnQueV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsaW5rLl9fY29udHJvbFBvaW50cyksIFtlbmQueCwgZW5kLnldKSkgOiBudWxsO1xuICAgICAgICAgIHZhciBjeWNsZVBob3RvbklkeCA9IDA7XG4gICAgICAgICAgdmFyIG5lZWRzQ2xlYW51cCA9IGZhbHNlOyAvLyB3aGV0aGVyIHNvbWUgcGhvdG9ucyBuZWVkIHRvIGJlIHJlbW92ZWQgZnJvbSBsaXN0XG4gICAgICAgICAgcGhvdG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwaG90b24pIHtcbiAgICAgICAgICAgIHZhciBzaW5nbGVIb3AgPSAhIXBob3Rvbi5fX3NpbmdsZUhvcDtcbiAgICAgICAgICAgIGlmICghcGhvdG9uLmhhc093blByb3BlcnR5KCdfX3Byb2dyZXNzUmF0aW8nKSkge1xuICAgICAgICAgICAgICBwaG90b24uX19wcm9ncmVzc1JhdGlvID0gc2luZ2xlSG9wID8gMCA6IGN5Y2xlUGhvdG9uSWR4IC8gbnVtQ3ljbGVQaG90b25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIXNpbmdsZUhvcCAmJiBjeWNsZVBob3RvbklkeCsrOyAvLyBpbmNyZWFzZSByZWd1bGFyIHBob3RvbiBpbmRleFxuXG4gICAgICAgICAgICBwaG90b24uX19wcm9ncmVzc1JhdGlvICs9IHBhcnRpY2xlU3BlZWQ7XG4gICAgICAgICAgICBpZiAocGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA+PSAxKSB7XG4gICAgICAgICAgICAgIGlmICghc2luZ2xlSG9wKSB7XG4gICAgICAgICAgICAgICAgcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyA9IHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gJSAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5lZWRzQ2xlYW51cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGhvdG9uUG9zUmF0aW8gPSBwaG90b24uX19wcm9ncmVzc1JhdGlvO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGJ6TGluZSA/IGJ6TGluZS5nZXQocGhvdG9uUG9zUmF0aW8pIC8vIGdldCBwb3NpdGlvbiBhbG9uZyBiZXppZXIgbGluZVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIC8vIHN0cmFpZ2h0IGxpbmU6IGludGVycG9sYXRlIGxpbmVhcmx5XG4gICAgICAgICAgICAgIHg6IHN0YXJ0LnggKyAoZW5kLnggLSBzdGFydC54KSAqIHBob3RvblBvc1JhdGlvIHx8IDAsXG4gICAgICAgICAgICAgIHk6IHN0YXJ0LnkgKyAoZW5kLnkgLSBzdGFydC55KSAqIHBob3RvblBvc1JhdGlvIHx8IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKGNvb3Jkcy54LCBjb29yZHMueSwgcGhvdG9uUiwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG5lZWRzQ2xlYW51cCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGV4cGlyZWQgc2luZ2xlIGhvcCBwaG90b25zXG4gICAgICAgICAgICBsaW5rLl9fcGhvdG9ucyA9IGxpbmsuX19waG90b25zLmZpbHRlcihmdW5jdGlvbiAocGhvdG9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhcGhvdG9uLl9fc2luZ2xlSG9wIHx8IHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gPD0gMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0UGFydGljbGU6IGZ1bmN0aW9uIGVtaXRQYXJ0aWNsZShzdGF0ZSwgbGluaykge1xuICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgIWxpbmsuX19waG90b25zICYmIChsaW5rLl9fcGhvdG9ucyA9IFtdKTtcbiAgICAgICAgbGluay5fX3Bob3RvbnMucHVzaCh7XG4gICAgICAgICAgX19zaW5nbGVIb3A6IHRydWVcbiAgICAgICAgfSk7IC8vIGFkZCBhIHNpbmdsZSBob3AgcGFydGljbGVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LFxuICBzdGF0ZUluaXQ6IGZ1bmN0aW9uIHN0YXRlSW5pdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9yY2VMYXlvdXQ6IGZvcmNlU2ltdWxhdGlvbigpLmZvcmNlKCdsaW5rJywgZm9yY2VMaW5rKCkpLmZvcmNlKCdjaGFyZ2UnLCBmb3JjZU1hbnlCb2R5KCkpLmZvcmNlKCdjZW50ZXInLCBmb3JjZUNlbnRlcigpKS5mb3JjZSgnZGFnUmFkaWFsJywgbnVsbCkuc3RvcCgpLFxuICAgICAgZW5naW5lUnVubmluZzogZmFsc2VcbiAgICB9O1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KGNhbnZhc0N0eCwgc3RhdGUpIHtcbiAgICAvLyBNYWluIGNhbnZhcyBvYmplY3QgdG8gbWFuaXB1bGF0ZVxuICAgIHN0YXRlLmN0eCA9IGNhbnZhc0N0eDtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoc3RhdGUpIHtcbiAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gZmFsc2U7IC8vIFBhdXNlIHNpbXVsYXRpb25cbiAgICBzdGF0ZS5vblVwZGF0ZSgpO1xuICAgIGlmIChzdGF0ZS5ub2RlQXV0b0NvbG9yQnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEF1dG8gYWRkIGNvbG9yIHRvIHVuY29sb3JlZCBub2Rlc1xuICAgICAgYXV0b0NvbG9yT2JqZWN0cyhzdGF0ZS5ncmFwaERhdGEubm9kZXMsIGFjY2Vzc29yRm4oc3RhdGUubm9kZUF1dG9Db2xvckJ5KSwgc3RhdGUubm9kZUNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmxpbmtBdXRvQ29sb3JCeSAhPT0gbnVsbCkge1xuICAgICAgLy8gQXV0byBhZGQgY29sb3IgdG8gdW5jb2xvcmVkIGxpbmtzXG4gICAgICBhdXRvQ29sb3JPYmplY3RzKHN0YXRlLmdyYXBoRGF0YS5saW5rcywgYWNjZXNzb3JGbihzdGF0ZS5saW5rQXV0b0NvbG9yQnkpLCBzdGF0ZS5saW5rQ29sb3IpO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGxpbmtzXG4gICAgc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgIGxpbmsuc291cmNlID0gbGlua1tzdGF0ZS5saW5rU291cmNlXTtcbiAgICAgIGxpbmsudGFyZ2V0ID0gbGlua1tzdGF0ZS5saW5rVGFyZ2V0XTtcbiAgICB9KTtcblxuICAgIC8vIEZlZWQgZGF0YSB0byBmb3JjZS1kaXJlY3RlZCBsYXlvdXRcbiAgICBzdGF0ZS5mb3JjZUxheW91dC5zdG9wKCkuYWxwaGEoMSkgLy8gcmUtaGVhdCB0aGUgc2ltdWxhdGlvblxuICAgIC5ub2RlcyhzdGF0ZS5ncmFwaERhdGEubm9kZXMpO1xuXG4gICAgLy8gYWRkIGxpbmtzIChpZiBsaW5rIGZvcmNlIGlzIHN0aWxsIGFjdGl2ZSlcbiAgICB2YXIgbGlua0ZvcmNlID0gc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoJ2xpbmsnKTtcbiAgICBpZiAobGlua0ZvcmNlKSB7XG4gICAgICBsaW5rRm9yY2UuaWQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbc3RhdGUubm9kZUlkXTtcbiAgICAgIH0pLmxpbmtzKHN0YXRlLmdyYXBoRGF0YS5saW5rcyk7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgZGFnIGZvcmNlIGNvbnN0cmFpbnRzXG4gICAgdmFyIG5vZGVEZXB0aHMgPSBzdGF0ZS5kYWdNb2RlICYmIGdldERhZ0RlcHRocyhzdGF0ZS5ncmFwaERhdGEsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZVtzdGF0ZS5ub2RlSWRdO1xuICAgIH0sIHtcbiAgICAgIG5vZGVGaWx0ZXI6IHN0YXRlLmRhZ05vZGVGaWx0ZXIsXG4gICAgICBvbkxvb3BFcnJvcjogc3RhdGUub25EYWdFcnJvciB8fCB1bmRlZmluZWRcbiAgICB9KTtcbiAgICB2YXIgbWF4RGVwdGggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LnZhbHVlcyhub2RlRGVwdGhzIHx8IFtdKSkpO1xuICAgIHZhciBkYWdMZXZlbERpc3RhbmNlID0gc3RhdGUuZGFnTGV2ZWxEaXN0YW5jZSB8fCBzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoIC8gKG1heERlcHRoIHx8IDEpICogREFHX0xFVkVMX05PREVfUkFUSU8gKiAoWydyYWRpYWxpbicsICdyYWRpYWxvdXQnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSA/IDAuNyA6IDEpO1xuXG4gICAgLy8gRml4IG5vZGVzIHRvIHgseSBmb3IgZGFnIG1vZGVcbiAgICBpZiAoc3RhdGUuZGFnTW9kZSkge1xuICAgICAgdmFyIGdldEZGbiA9IGZ1bmN0aW9uIGdldEZGbihmaXgsIGludmVydCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gIWZpeCA/IHVuZGVmaW5lZCA6IChub2RlRGVwdGhzW25vZGVbc3RhdGUubm9kZUlkXV0gLSBtYXhEZXB0aCAvIDIpICogZGFnTGV2ZWxEaXN0YW5jZSAqIChpbnZlcnQgPyAtMSA6IDEpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBmeEZuID0gZ2V0RkZuKFsnbHInLCAncmwnXS5pbmRleE9mKHN0YXRlLmRhZ01vZGUpICE9PSAtMSwgc3RhdGUuZGFnTW9kZSA9PT0gJ3JsJyk7XG4gICAgICB2YXIgZnlGbiA9IGdldEZGbihbJ3RkJywgJ2J1J10uaW5kZXhPZihzdGF0ZS5kYWdNb2RlKSAhPT0gLTEsIHN0YXRlLmRhZ01vZGUgPT09ICdidScpO1xuICAgICAgc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmZpbHRlcihzdGF0ZS5kYWdOb2RlRmlsdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUuZnggPSBmeEZuKG5vZGUpO1xuICAgICAgICBub2RlLmZ5ID0gZnlGbihub2RlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFVzZSByYWRpYWwgZm9yY2UgZm9yIHJhZGlhbCBkYWdzXG4gICAgc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoJ2RhZ1JhZGlhbCcsIFsncmFkaWFsaW4nLCAncmFkaWFsb3V0J10uaW5kZXhPZihzdGF0ZS5kYWdNb2RlKSAhPT0gLTEgPyBmb3JjZVJhZGlhbChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIG5vZGVEZXB0aCA9IG5vZGVEZXB0aHNbbm9kZVtzdGF0ZS5ub2RlSWRdXSB8fCAtMTtcbiAgICAgIHJldHVybiAoc3RhdGUuZGFnTW9kZSA9PT0gJ3JhZGlhbGluJyA/IG1heERlcHRoIC0gbm9kZURlcHRoIDogbm9kZURlcHRoKSAqIGRhZ0xldmVsRGlzdGFuY2U7XG4gICAgfSkuc3RyZW5ndGgoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5kYWdOb2RlRmlsdGVyKG5vZGUpID8gMSA6IDA7XG4gICAgfSkgOiBudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLndhcm11cFRpY2tzICYmICEoc3RhdGUuZDNBbHBoYU1pbiA+IDAgJiYgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGEoKSA8IHN0YXRlLmQzQWxwaGFNaW4pOyBpKyspIHtcbiAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LnRpY2soKTtcbiAgICB9IC8vIEluaXRpYWwgdGlja3MgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlbmRlclxuXG4gICAgdGhpcy5yZXNldENvdW50ZG93bigpO1xuICAgIHN0YXRlLm9uRmluaXNoVXBkYXRlKCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBsaW5rS2Fwc3VsZSAoa2Fwc3VsZVByb3BOYW1lcywga2Fwc3VsZVR5cGUpIHtcbiAgdmFyIHByb3BOYW1lcyA9IGthcHN1bGVQcm9wTmFtZXMgaW5zdGFuY2VvZiBBcnJheSA/IGthcHN1bGVQcm9wTmFtZXMgOiBba2Fwc3VsZVByb3BOYW1lc107XG4gIHZhciBkdW1teUsgPSBuZXcga2Fwc3VsZVR5cGUoKTsgLy8gVG8gZXh0cmFjdCBkZWZhdWx0c1xuICBkdW1teUsuX2Rlc3RydWN0b3IgJiYgZHVtbXlLLl9kZXN0cnVjdG9yKCk7XG4gIHJldHVybiB7XG4gICAgbGlua1Byb3A6IGZ1bmN0aW9uIGxpbmtQcm9wKHByb3ApIHtcbiAgICAgIC8vIGxpbmsgcHJvcGVydHkgY29uZmlnXG4gICAgICByZXR1cm4ge1xuICAgICAgICBcImRlZmF1bHRcIjogZHVtbXlLW3Byb3BdKCksXG4gICAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZSh2LCBzdGF0ZSkge1xuICAgICAgICAgIHByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlW3Byb3BOYW1lXVtwcm9wXSh2KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBsaW5rTWV0aG9kOiBmdW5jdGlvbiBsaW5rTWV0aG9kKG1ldGhvZCkge1xuICAgICAgLy8gbGluayBtZXRob2QgcGFzcy10aHJvdWdoXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmV0dXJuVmFscyA9IFtdO1xuICAgICAgICBwcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICB2YXIga2Fwc3VsZUluc3RhbmNlID0gc3RhdGVbcHJvcE5hbWVdO1xuICAgICAgICAgIHZhciByZXR1cm5WYWwgPSBrYXBzdWxlSW5zdGFuY2VbbWV0aG9kXS5hcHBseShrYXBzdWxlSW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICAgIGlmIChyZXR1cm5WYWwgIT09IGthcHN1bGVJbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuVmFscy5wdXNoKHJldHVyblZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHMubGVuZ3RoID8gcmV0dXJuVmFsc1swXSA6IHRoaXM7IC8vIGNoYWluIGJhc2VkIG9uIHRoZSBwYXJlbnQgb2JqZWN0LCBub3QgdGhlIGlubmVyIGthcHN1bGVcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG52YXIgSE9WRVJfQ0FOVkFTX1RIUk9UVExFX0RFTEFZID0gODAwOyAvLyBtcyB0byB0aHJvdHRsZSBzaGFkb3cgY2FudmFzIHVwZGF0ZXMgZm9yIHBlcmYgaW1wcm92ZW1lbnRcbnZhciBaT09NMk5PREVTX0ZBQ1RPUiA9IDQ7XG5cbi8vIEV4cG9zZSBjb25maWcgZnJvbSBmb3JjZUdyYXBoXG52YXIgYmluZEZHID0gbGlua0thcHN1bGUoJ2ZvcmNlR3JhcGgnLCBDYW52YXNGb3JjZUdyYXBoKTtcbnZhciBiaW5kQm90aCA9IGxpbmtLYXBzdWxlKFsnZm9yY2VHcmFwaCcsICdzaGFkb3dHcmFwaCddLCBDYW52YXNGb3JjZUdyYXBoKTtcbnZhciBsaW5rZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBfdG9Db25zdW1hYmxlQXJyYXkoWydub2RlQ29sb3InLCAnbm9kZUF1dG9Db2xvckJ5JywgJ25vZGVDYW52YXNPYmplY3QnLCAnbm9kZUNhbnZhc09iamVjdE1vZGUnLCAnbGlua0NvbG9yJywgJ2xpbmtBdXRvQ29sb3JCeScsICdsaW5rTGluZURhc2gnLCAnbGlua1dpZHRoJywgJ2xpbmtDYW52YXNPYmplY3QnLCAnbGlua0NhbnZhc09iamVjdE1vZGUnLCAnbGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgnLCAnbGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvcicsICdsaW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvcycsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZXMnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVTcGVlZCcsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3InLCAnZGFnTW9kZScsICdkYWdMZXZlbERpc3RhbmNlJywgJ2RhZ05vZGVGaWx0ZXInLCAnb25EYWdFcnJvcicsICdkM0FscGhhTWluJywgJ2QzQWxwaGFEZWNheScsICdkM1ZlbG9jaXR5RGVjYXknLCAnd2FybXVwVGlja3MnLCAnY29vbGRvd25UaWNrcycsICdjb29sZG93blRpbWUnLCAnb25FbmdpbmVUaWNrJywgJ29uRW5naW5lU3RvcCddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kRkcubGlua1Byb3AocCkpO1xufSkpLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoWydub2RlUmVsU2l6ZScsICdub2RlSWQnLCAnbm9kZVZhbCcsICdub2RlVmlzaWJpbGl0eScsICdsaW5rU291cmNlJywgJ2xpbmtUYXJnZXQnLCAnbGlua1Zpc2liaWxpdHknLCAnbGlua0N1cnZhdHVyZSddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kQm90aC5saW5rUHJvcChwKSk7XG59KSkpKTtcbnZhciBsaW5rZWRNZXRob2RzID0gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIF90b0NvbnN1bWFibGVBcnJheShbJ2QzRm9yY2UnLCAnZDNSZWhlYXRTaW11bGF0aW9uJywgJ2VtaXRQYXJ0aWNsZSddLm1hcChmdW5jdGlvbiAocCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnR5KHt9LCBwLCBiaW5kRkcubGlua01ldGhvZChwKSk7XG59KSkpO1xuZnVuY3Rpb24gYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSkge1xuICBpZiAoc3RhdGUuY2FudmFzKSB7XG4gICAgdmFyIGN1cldpZHRoID0gc3RhdGUuY2FudmFzLndpZHRoO1xuICAgIHZhciBjdXJIZWlnaHQgPSBzdGF0ZS5jYW52YXMuaGVpZ2h0O1xuICAgIGlmIChjdXJXaWR0aCA9PT0gMzAwICYmIGN1ckhlaWdodCA9PT0gMTUwKSB7XG4gICAgICAvLyBEZWZhdWx0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICBjdXJXaWR0aCA9IGN1ckhlaWdodCA9IDA7XG4gICAgfVxuICAgIHZhciBweFNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87IC8vIDIgb24gcmV0aW5hIGRpc3BsYXlzXG4gICAgY3VyV2lkdGggLz0gcHhTY2FsZTtcbiAgICBjdXJIZWlnaHQgLz0gcHhTY2FsZTtcblxuICAgIC8vIFJlc2l6ZSBjYW52YXNlc1xuICAgIFtzdGF0ZS5jYW52YXMsIHN0YXRlLnNoYWRvd0NhbnZhc10uZm9yRWFjaChmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICAvLyBFbGVtZW50IHNpemVcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHN0YXRlLndpZHRoLCBcInB4XCIpO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KHN0YXRlLmhlaWdodCwgXCJweFwiKTtcblxuICAgICAgLy8gTWVtb3J5IHNpemUgKHNjYWxlZCB0byBhdm9pZCBibHVycmluZXNzKVxuICAgICAgY2FudmFzLndpZHRoID0gc3RhdGUud2lkdGggKiBweFNjYWxlO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHN0YXRlLmhlaWdodCAqIHB4U2NhbGU7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSBjb29yZGluYXRlIHN5c3RlbSB0byB1c2UgY3NzIHBpeGVscyAob24gaW5pdCBvbmx5KVxuICAgICAgaWYgKCFjdXJXaWR0aCAmJiAhY3VySGVpZ2h0KSB7XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnNjYWxlKHB4U2NhbGUsIHB4U2NhbGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gUmVsYXRpdmUgY2VudGVyIHBhbm5pbmcgYmFzZWQgb24gMCwwXG4gICAgdmFyIGsgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICBzdGF0ZS56b29tLnRyYW5zbGF0ZUJ5KHN0YXRlLnpvb20uX19iYXNlRWxlbSwgKHN0YXRlLndpZHRoIC0gY3VyV2lkdGgpIC8gMiAvIGssIChzdGF0ZS5oZWlnaHQgLSBjdXJIZWlnaHQpIC8gMiAvIGspO1xuICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm0oY3R4KSB7XG4gIHZhciBweFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGN0eC5zZXRUcmFuc2Zvcm0ocHhSYXRpbywgMCwgMCwgcHhSYXRpbywgMCwgMCk7XG59XG5mdW5jdGlvbiBjbGVhckNhbnZhcyhjdHgsIHdpZHRoLCBoZWlnaHQpIHtcbiAgY3R4LnNhdmUoKTtcbiAgcmVzZXRUcmFuc2Zvcm0oY3R4KTsgLy8gcmVzZXQgdHJhbnNmb3JtXG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7IC8vcmVzdG9yZSB0cmFuc2Zvcm1zXG59XG5cbi8vXG5cbnZhciBmb3JjZUdyYXBoID0gS2Fwc3VsZSh7XG4gIHByb3BzOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgd2lkdGg6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShfLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgXCJkZWZhdWx0XCI6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShfLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGdyYXBoRGF0YToge1xuICAgICAgXCJkZWZhdWx0XCI6IHtcbiAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICBsaW5rczogW11cbiAgICAgIH0sXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoZCwgc3RhdGUpIHtcbiAgICAgICAgW3tcbiAgICAgICAgICB0eXBlOiAnTm9kZScsXG4gICAgICAgICAgb2JqczogZC5ub2Rlc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgdHlwZTogJ0xpbmsnLFxuICAgICAgICAgIG9ianM6IGQubGlua3NcbiAgICAgICAgfV0uZm9yRWFjaChoZXhJbmRleCk7XG4gICAgICAgIHN0YXRlLmZvcmNlR3JhcGguZ3JhcGhEYXRhKGQpO1xuICAgICAgICBzdGF0ZS5zaGFkb3dHcmFwaC5ncmFwaERhdGEoZCk7XG4gICAgICAgIGZ1bmN0aW9uIGhleEluZGV4KF9yZWY0KSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBfcmVmNC50eXBlLFxuICAgICAgICAgICAgb2JqcyA9IF9yZWY0Lm9ianM7XG4gICAgICAgICAgb2Jqcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmICghZC5oYXNPd25Qcm9wZXJ0eSgnX19pbmRleENvbG9yJykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgdmFyIGN1ciA9IHN0YXRlLmNvbG9yVHJhY2tlci5sb29rdXAoZC5fX2luZGV4Q29sb3IpO1xuICAgICAgICAgICAgcmV0dXJuICFjdXIgfHwgIWN1ci5oYXNPd25Qcm9wZXJ0eSgnZCcpIHx8IGN1ci5kICE9PSBkO1xuICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIG9iamVjdCBsb29rdXAgY29sb3JcbiAgICAgICAgICAgIGQuX19pbmRleENvbG9yID0gc3RhdGUuY29sb3JUcmFja2VyLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgZDogZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoY29sb3IsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmNhbnZhcyAmJiBjb2xvciAmJiAoc3RhdGUuY2FudmFzLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvcik7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG5vZGVMYWJlbDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICduYW1lJyxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBub2RlUG9pbnRlckFyZWFQYWludDoge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHBhaW50Rm4sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLm5vZGVDYW52YXNPYmplY3QoIXBhaW50Rm4gPyBudWxsIDogZnVuY3Rpb24gKG5vZGUsIGN0eCwgZ2xvYmFsU2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gcGFpbnRGbihub2RlLCBub2RlLl9faW5kZXhDb2xvciwgY3R4LCBnbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcyAmJiBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcygpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rUG9pbnRlckFyZWFQYWludDoge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHBhaW50Rm4sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLmxpbmtDYW52YXNPYmplY3QoIXBhaW50Rm4gPyBudWxsIDogZnVuY3Rpb24gKGxpbmssIGN0eCwgZ2xvYmFsU2NhbGUpIHtcbiAgICAgICAgICByZXR1cm4gcGFpbnRGbihsaW5rLCBsaW5rLl9faW5kZXhDb2xvciwgY3R4LCBnbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcyAmJiBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcygpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rTGFiZWw6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnbmFtZScsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua0hvdmVyUHJlY2lzaW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogNCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBtaW5ab29tOiB7XG4gICAgICBcImRlZmF1bHRcIjogMC4wMSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShtaW5ab29tLCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS56b29tLnNjYWxlRXh0ZW50KFttaW5ab29tLCBzdGF0ZS56b29tLnNjYWxlRXh0ZW50KClbMV1dKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbWF4Wm9vbToge1xuICAgICAgXCJkZWZhdWx0XCI6IDEwMDAsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UobWF4Wm9vbSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuem9vbS5zY2FsZUV4dGVudChbc3RhdGUuem9vbS5zY2FsZUV4dGVudCgpWzBdLCBtYXhab29tXSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGVuYWJsZU5vZGVEcmFnOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmFibGVab29tSW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGVuYWJsZVBhbkludGVyYWN0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmFibGVab29tUGFuSW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIC8vIHRvIGJlIGRlcHJlY2F0ZWRcbiAgICBlbmFibGVQb2ludGVySW50ZXJhY3Rpb246IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKF8sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmhvdmVyT2JqID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgYXV0b1BhdXNlUmVkcmF3OiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVEcmFnOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVEcmFnRW5kOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTm9kZVJpZ2h0Q2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVIb3Zlcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTGlua0NsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25MaW5rUmlnaHRDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTGlua0hvdmVyOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25CYWNrZ3JvdW5kQ2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkJhY2tncm91bmRSaWdodENsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25ab29tOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25ab29tRW5kOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25SZW5kZXJGcmFtZVByZToge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uUmVuZGVyRnJhbWVQb3N0OiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH1cbiAgfSwgbGlua2VkUHJvcHMpLFxuICBhbGlhc2VzOiB7XG4gICAgLy8gUHJvcCBuYW1lcyBzdXBwb3J0ZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgc3RvcEFuaW1hdGlvbjogJ3BhdXNlQW5pbWF0aW9uJ1xuICB9LFxuICBtZXRob2RzOiBfb2JqZWN0U3ByZWFkMih7XG4gICAgZ3JhcGgyU2NyZWVuQ29vcmRzOiBmdW5jdGlvbiBncmFwaDJTY3JlZW5Db29yZHMoc3RhdGUsIHgsIHkpIHtcbiAgICAgIHZhciB0ID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHQuayArIHQueCxcbiAgICAgICAgeTogeSAqIHQuayArIHQueVxuICAgICAgfTtcbiAgICB9LFxuICAgIHNjcmVlbjJHcmFwaENvb3JkczogZnVuY3Rpb24gc2NyZWVuMkdyYXBoQ29vcmRzKHN0YXRlLCB4LCB5KSB7XG4gICAgICB2YXIgdCA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6ICh4IC0gdC54KSAvIHQuayxcbiAgICAgICAgeTogKHkgLSB0LnkpIC8gdC5rXG4gICAgICB9O1xuICAgIH0sXG4gICAgY2VudGVyQXQ6IGZ1bmN0aW9uIGNlbnRlckF0KHN0YXRlLCB4LCB5LCB0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgIGlmICghc3RhdGUuY2FudmFzKSByZXR1cm4gbnVsbDsgLy8gbm8gY2FudmFzIHlldFxuXG4gICAgICAvLyBzZXR0ZXJcbiAgICAgIGlmICh4ICE9PSB1bmRlZmluZWQgfHwgeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmaW5hbFBvcyA9IE9iamVjdC5hc3NpZ24oe30sIHggIT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgICB4OiB4XG4gICAgICAgIH0gOiB7fSwgeSAhPT0gdW5kZWZpbmVkID8ge1xuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSA6IHt9KTtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBubyBhbmltYXRpb25cbiAgICAgICAgICBzZXRDZW50ZXIoZmluYWxQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ldyBUV0VFTi5Ud2VlbihnZXRDZW50ZXIoKSkudG8oZmluYWxQb3MsIHRyYW5zaXRpb25EdXJhdGlvbikuZWFzaW5nKFRXRUVOLkVhc2luZy5RdWFkcmF0aWMuT3V0KS5vblVwZGF0ZShzZXRDZW50ZXIpLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldHRlclxuICAgICAgcmV0dXJuIGdldENlbnRlcigpO1xuXG4gICAgICAvL1xuXG4gICAgICBmdW5jdGlvbiBnZXRDZW50ZXIoKSB7XG4gICAgICAgIHZhciB0ID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IChzdGF0ZS53aWR0aCAvIDIgLSB0LngpIC8gdC5rLFxuICAgICAgICAgIHk6IChzdGF0ZS5oZWlnaHQgLyAyIC0gdC55KSAvIHQua1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2V0Q2VudGVyKF9yZWY1KSB7XG4gICAgICAgIHZhciB4ID0gX3JlZjUueCxcbiAgICAgICAgICB5ID0gX3JlZjUueTtcbiAgICAgICAgc3RhdGUuem9vbS50cmFuc2xhdGVUbyhzdGF0ZS56b29tLl9fYmFzZUVsZW0sIHggPT09IHVuZGVmaW5lZCA/IGdldENlbnRlcigpLnggOiB4LCB5ID09PSB1bmRlZmluZWQgPyBnZXRDZW50ZXIoKS55IDogeSk7XG4gICAgICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uIHpvb20oc3RhdGUsIGssIHRyYW5zaXRpb25EdXJhdGlvbikge1xuICAgICAgaWYgKCFzdGF0ZS5jYW52YXMpIHJldHVybiBudWxsOyAvLyBubyBjYW52YXMgeWV0XG5cbiAgICAgIC8vIHNldHRlclxuICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIXRyYW5zaXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIC8vIG5vIGFuaW1hdGlvblxuICAgICAgICAgIHNldFpvb20oayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3IFRXRUVOLlR3ZWVuKHtcbiAgICAgICAgICAgIGs6IGdldFpvb20oKVxuICAgICAgICAgIH0pLnRvKHtcbiAgICAgICAgICAgIGs6IGtcbiAgICAgICAgICB9LCB0cmFuc2l0aW9uRHVyYXRpb24pLmVhc2luZyhUV0VFTi5FYXNpbmcuUXVhZHJhdGljLk91dCkub25VcGRhdGUoZnVuY3Rpb24gKF9yZWY2KSB7XG4gICAgICAgICAgICB2YXIgayA9IF9yZWY2Lms7XG4gICAgICAgICAgICByZXR1cm4gc2V0Wm9vbShrKTtcbiAgICAgICAgICB9KS5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXR0ZXJcbiAgICAgIHJldHVybiBnZXRab29tKCk7XG5cbiAgICAgIC8vXG5cbiAgICAgIGZ1bmN0aW9uIGdldFpvb20oKSB7XG4gICAgICAgIHJldHVybiB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNldFpvb20oaykge1xuICAgICAgICBzdGF0ZS56b29tLnNjYWxlVG8oc3RhdGUuem9vbS5fX2Jhc2VFbGVtLCBrKTtcbiAgICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgem9vbVRvRml0OiBmdW5jdGlvbiB6b29tVG9GaXQoc3RhdGUpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTA7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYmJveEFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBiYm94QXJnc1tfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0R3JhcGhCYm94LmFwcGx5KHRoaXMsIGJib3hBcmdzKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgICAgeDogKGJib3gueFswXSArIGJib3gueFsxXSkgLyAyLFxuICAgICAgICAgIHk6IChiYm94LnlbMF0gKyBiYm94LnlbMV0pIC8gMlxuICAgICAgICB9O1xuICAgICAgICB2YXIgem9vbUsgPSBNYXRoLm1heCgxZS0xMiwgTWF0aC5taW4oMWUxMiwgKHN0YXRlLndpZHRoIC0gcGFkZGluZyAqIDIpIC8gKGJib3gueFsxXSAtIGJib3gueFswXSksIChzdGF0ZS5oZWlnaHQgLSBwYWRkaW5nICogMikgLyAoYmJveC55WzFdIC0gYmJveC55WzBdKSkpO1xuICAgICAgICB0aGlzLmNlbnRlckF0KGNlbnRlci54LCBjZW50ZXIueSwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy56b29tKHpvb21LLCB0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRHcmFwaEJib3g6IGZ1bmN0aW9uIGdldEdyYXBoQmJveChzdGF0ZSkge1xuICAgICAgdmFyIG5vZGVGaWx0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgdmFyIGdldFZhbCA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZhbCk7XG4gICAgICB2YXIgZ2V0UiA9IGZ1bmN0aW9uIGdldFIobm9kZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldFZhbChub2RlKSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgIH07XG4gICAgICB2YXIgbm9kZXNQb3MgPSBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmlsdGVyKG5vZGVGaWx0ZXIpLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IG5vZGUueCxcbiAgICAgICAgICB5OiBub2RlLnksXG4gICAgICAgICAgcjogZ2V0Uihub2RlKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gIW5vZGVzUG9zLmxlbmd0aCA/IG51bGwgOiB7XG4gICAgICAgIHg6IFttaW4obm9kZXNQb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueCAtIG5vZGUucjtcbiAgICAgICAgfSksIG1heChub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS54ICsgbm9kZS5yO1xuICAgICAgICB9KV0sXG4gICAgICAgIHk6IFttaW4obm9kZXNQb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueSAtIG5vZGUucjtcbiAgICAgICAgfSksIG1heChub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS55ICsgbm9kZS5yO1xuICAgICAgICB9KV1cbiAgICAgIH07XG4gICAgfSxcbiAgICBwYXVzZUFuaW1hdGlvbjogZnVuY3Rpb24gcGF1c2VBbmltYXRpb24oc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCk7XG4gICAgICAgIHN0YXRlLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVzdW1lQW5pbWF0aW9uOiBmdW5jdGlvbiByZXN1bWVBbmltYXRpb24oc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ3ljbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX2Rlc3RydWN0b3I6IGZ1bmN0aW9uIF9kZXN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5wYXVzZUFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5ncmFwaERhdGEoe1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGxpbmtzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBsaW5rZWRNZXRob2RzKSxcbiAgc3RhdGVJbml0OiBmdW5jdGlvbiBzdGF0ZUluaXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RTZXRab29tOiAxLFxuICAgICAgem9vbTogem9vbSgpLFxuICAgICAgZm9yY2VHcmFwaDogbmV3IENhbnZhc0ZvcmNlR3JhcGgoKSxcbiAgICAgIHNoYWRvd0dyYXBoOiBuZXcgQ2FudmFzRm9yY2VHcmFwaCgpLmNvb2xkb3duVGlja3MoMCkubm9kZUNvbG9yKCdfX2luZGV4Q29sb3InKS5saW5rQ29sb3IoJ19faW5kZXhDb2xvcicpLmlzU2hhZG93KHRydWUpLFxuICAgICAgY29sb3JUcmFja2VyOiBuZXcgQ29sb3JUcmFja2VyKCkgLy8gaW5kZXhlZCBvYmplY3RzIGZvciByZ2IgbG9va3VwXG4gICAgfTtcbiAgfSxcblxuICBpbml0OiBmdW5jdGlvbiBpbml0KGRvbU5vZGUsIHN0YXRlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBXaXBlIERPTVxuICAgIGRvbU5vZGUuaW5uZXJIVE1MID0gJyc7XG5cbiAgICAvLyBDb250YWluZXIgYW5jaG9yIGZvciBjYW52YXMgYW5kIHRvb2x0aXBcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2ZvcmNlLWdyYXBoLWNvbnRhaW5lcicpO1xuICAgIGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgZG9tTm9kZS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIHN0YXRlLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGlmIChzdGF0ZS5iYWNrZ3JvdW5kQ29sb3IpIHN0YXRlLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gc3RhdGUuYmFja2dyb3VuZENvbG9yO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0ZS5jYW52YXMpO1xuICAgIHN0YXRlLnNoYWRvd0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgLy8gU2hvdyBzaGFkb3cgY2FudmFzXG4gICAgLy9zdGF0ZS5zaGFkb3dDYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIC8vc3RhdGUuc2hhZG93Q2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAvL3N0YXRlLnNoYWRvd0NhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIC8vY29udGFpbmVyLmFwcGVuZENoaWxkKHN0YXRlLnNoYWRvd0NhbnZhcyk7XG5cbiAgICB2YXIgY3R4ID0gc3RhdGUuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIHNoYWRvd0N0eCA9IHN0YXRlLnNoYWRvd0NhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBwb2ludGVyUG9zID0ge1xuICAgICAgeDogLTFlMTIsXG4gICAgICB5OiAtMWUxMlxuICAgIH07XG4gICAgdmFyIGdldE9ialVuZGVyUG9pbnRlciA9IGZ1bmN0aW9uIGdldE9ialVuZGVyUG9pbnRlcigpIHtcbiAgICAgIHZhciBvYmogPSBudWxsO1xuICAgICAgdmFyIHB4U2NhbGUgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIHZhciBweCA9IHBvaW50ZXJQb3MueCA+IDAgJiYgcG9pbnRlclBvcy55ID4gMCA/IHNoYWRvd0N0eC5nZXRJbWFnZURhdGEocG9pbnRlclBvcy54ICogcHhTY2FsZSwgcG9pbnRlclBvcy55ICogcHhTY2FsZSwgMSwgMSkgOiBudWxsO1xuICAgICAgLy8gTG9va3VwIG9iamVjdCBwZXIgcGl4ZWwgY29sb3JcbiAgICAgIHB4ICYmIChvYmogPSBzdGF0ZS5jb2xvclRyYWNrZXIubG9va3VwKHB4LmRhdGEpKTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcblxuICAgIC8vIFNldHVwIG5vZGUgZHJhZyBpbnRlcmFjdGlvblxuICAgIHNlbGVjdChzdGF0ZS5jYW52YXMpLmNhbGwoZHJhZygpLnN1YmplY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdGF0ZS5lbmFibGVOb2RlRHJhZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSBnZXRPYmpVbmRlclBvaW50ZXIoKTtcbiAgICAgIHJldHVybiBvYmogJiYgb2JqLnR5cGUgPT09ICdOb2RlJyA/IG9iai5kIDogbnVsbDsgLy8gT25seSBkcmFnIG5vZGVzXG4gICAgfSkub24oJ3N0YXJ0JywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgb2JqID0gZXYuc3ViamVjdDtcbiAgICAgIG9iai5fX2luaXRpYWxEcmFnUG9zID0ge1xuICAgICAgICB4OiBvYmoueCxcbiAgICAgICAgeTogb2JqLnksXG4gICAgICAgIGZ4OiBvYmouZngsXG4gICAgICAgIGZ5OiBvYmouZnlcbiAgICAgIH07XG5cbiAgICAgIC8vIGtlZXAgZW5naW5lIHJ1bm5pbmcgYXQgbG93IGludGVuc2l0eSB0aHJvdWdob3V0IGRyYWdcbiAgICAgIGlmICghZXYuYWN0aXZlKSB7XG4gICAgICAgIG9iai5meCA9IG9iai54O1xuICAgICAgICBvYmouZnkgPSBvYmoueTsgLy8gRml4IHBvaW50c1xuICAgICAgfVxuXG4gICAgICAvLyBkcmFnIGN1cnNvclxuICAgICAgc3RhdGUuY2FudmFzLmNsYXNzTGlzdC5hZGQoJ2dyYWJiYWJsZScpO1xuICAgIH0pLm9uKCdkcmFnJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgb2JqID0gZXYuc3ViamVjdDtcbiAgICAgIHZhciBpbml0UG9zID0gb2JqLl9faW5pdGlhbERyYWdQb3M7XG4gICAgICB2YXIgZHJhZ1BvcyA9IGV2O1xuICAgICAgdmFyIGsgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICAgIHZhciB0cmFuc2xhdGUgPSB7XG4gICAgICAgIHg6IGluaXRQb3MueCArIChkcmFnUG9zLnggLSBpbml0UG9zLngpIC8gayAtIG9iai54LFxuICAgICAgICB5OiBpbml0UG9zLnkgKyAoZHJhZ1Bvcy55IC0gaW5pdFBvcy55KSAvIGsgLSBvYmoueVxuICAgICAgfTtcblxuICAgICAgLy8gTW92ZSBmeC9meSAoYW5kIHgveSkgb2Ygbm9kZXMgYmFzZWQgb24gdGhlIHNjYWxlZCBkcmFnIGRpc3RhbmNlIHNpbmNlIHRoZSBkcmFnIHN0YXJ0XG4gICAgICBbJ3gnLCAneSddLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIG9ialtcImZcIi5jb25jYXQoYyldID0gb2JqW2NdID0gaW5pdFBvc1tjXSArIChkcmFnUG9zW2NdIC0gaW5pdFBvc1tjXSkgLyBrO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByZXZlbnQgZnJlZXplIHdoaWxlIGRyYWdnaW5nXG4gICAgICBzdGF0ZS5mb3JjZUdyYXBoLmQzQWxwaGFUYXJnZXQoMC4zKSAvLyBrZWVwIGVuZ2luZSBydW5uaW5nIGF0IGxvdyBpbnRlbnNpdHkgdGhyb3VnaG91dCBkcmFnXG4gICAgICAucmVzZXRDb3VudGRvd24oKTsgLy8gcHJldmVudCBmcmVlemUgd2hpbGUgZHJhZ2dpbmdcblxuICAgICAgc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgb2JqLl9fZHJhZ2dlZCA9IHRydWU7XG4gICAgICBzdGF0ZS5vbk5vZGVEcmFnKG9iaiwgdHJhbnNsYXRlKTtcbiAgICB9KS5vbignZW5kJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgb2JqID0gZXYuc3ViamVjdDtcbiAgICAgIHZhciBpbml0UG9zID0gb2JqLl9faW5pdGlhbERyYWdQb3M7XG4gICAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgICB4OiBvYmoueCAtIGluaXRQb3MueCxcbiAgICAgICAgeTogb2JqLnkgLSBpbml0UG9zLnlcbiAgICAgIH07XG4gICAgICBpZiAoaW5pdFBvcy5meCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iai5meCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChpbml0UG9zLmZ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2JqLmZ5ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG9iai5fX2luaXRpYWxEcmFnUG9zO1xuICAgICAgaWYgKHN0YXRlLmZvcmNlR3JhcGguZDNBbHBoYVRhcmdldCgpKSB7XG4gICAgICAgIHN0YXRlLmZvcmNlR3JhcGguZDNBbHBoYVRhcmdldCgwKSAvLyByZWxlYXNlIGVuZ2luZSBsb3cgaW50ZW5zaXR5XG4gICAgICAgIC5yZXNldENvdW50ZG93bigpOyAvLyBsZXQgdGhlIGVuZ2luZSByZWFkanVzdCBhZnRlciByZWxlYXNpbmcgZml4ZWQgbm9kZXNcbiAgICAgIH1cblxuICAgICAgLy8gZHJhZyBjdXJzb3JcbiAgICAgIHN0YXRlLmNhbnZhcy5jbGFzc0xpc3QucmVtb3ZlKCdncmFiYmFibGUnKTtcbiAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gZmFsc2U7XG4gICAgICBpZiAob2JqLl9fZHJhZ2dlZCkge1xuICAgICAgICBkZWxldGUgb2JqLl9fZHJhZ2dlZDtcbiAgICAgICAgc3RhdGUub25Ob2RlRHJhZ0VuZChvYmosIHRyYW5zbGF0ZSk7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgLy8gU2V0dXAgem9vbSAvIHBhbiBpbnRlcmFjdGlvblxuICAgIHN0YXRlLnpvb20oc3RhdGUuem9vbS5fX2Jhc2VFbGVtID0gc2VsZWN0KHN0YXRlLmNhbnZhcykpOyAvLyBBdHRhY2ggY29udHJvbGxpbmcgZWxlbSBmb3IgZWFzeSBhY2Nlc3NcblxuICAgIHN0YXRlLnpvb20uX19iYXNlRWxlbS5vbignZGJsY2xpY2suem9vbScsIG51bGwpOyAvLyBEaXNhYmxlIGRvdWJsZS1jbGljayB0byB6b29tXG5cbiAgICBzdGF0ZS56b29tLmZpbHRlcihmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8vIGRpc2FibGUgem9vbSBpbnRlcmFjdGlvblxuICAgICAgICAhZXYuYnV0dG9uICYmIHN0YXRlLmVuYWJsZVpvb21QYW5JbnRlcmFjdGlvbiAmJiAoc3RhdGUuZW5hYmxlWm9vbUludGVyYWN0aW9uIHx8IGV2LnR5cGUgIT09ICd3aGVlbCcpICYmIChzdGF0ZS5lbmFibGVQYW5JbnRlcmFjdGlvbiB8fCBldi50eXBlID09PSAnd2hlZWwnKVxuICAgICAgKTtcbiAgICB9KS5vbignem9vbScsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHQgPSBldi50cmFuc2Zvcm07XG4gICAgICBbY3R4LCBzaGFkb3dDdHhdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmVzZXRUcmFuc2Zvcm0oYyk7XG4gICAgICAgIGMudHJhbnNsYXRlKHQueCwgdC55KTtcbiAgICAgICAgYy5zY2FsZSh0LmssIHQuayk7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlLm9uWm9vbSAmJiBzdGF0ZS5vblpvb20oX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHQpLCBfdGhpcy5jZW50ZXJBdCgpKSk7IC8vIHJlcG9ydCB4LHkgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY2FudmFzIGNlbnRlclxuICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIH0pLm9uKCdlbmQnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5vblpvb21FbmQgJiYgc3RhdGUub25ab29tRW5kKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBldi50cmFuc2Zvcm0pLCBfdGhpcy5jZW50ZXJBdCgpKSk7XG4gICAgfSk7XG4gICAgYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSk7XG4gICAgc3RhdGUuZm9yY2VHcmFwaC5vbk5lZWRzUmVkcmF3KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgfSkub25GaW5pc2hVcGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcmUtem9vbSwgaWYgc3RpbGwgaW4gZGVmYXVsdCBwb3NpdGlvbiAobm90IHVzZXIgbW9kaWZpZWQpXG4gICAgICBpZiAoem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpLmsgPT09IHN0YXRlLmxhc3RTZXRab29tICYmIHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhdGUuem9vbS5zY2FsZVRvKHN0YXRlLnpvb20uX19iYXNlRWxlbSwgc3RhdGUubGFzdFNldFpvb20gPSBaT09NMk5PREVTX0ZBQ1RPUiAvIE1hdGguY2JydChzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNldHVwIHRvb2x0aXBcbiAgICB2YXIgdG9vbFRpcEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0b29sVGlwRWxlbS5jbGFzc0xpc3QuYWRkKCdncmFwaC10b29sdGlwJyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRvb2xUaXBFbGVtKTtcblxuICAgIC8vIENhcHR1cmUgcG9pbnRlciBjb29yZHMgb24gbW92ZSBvciB0b3VjaHN0YXJ0XG4gICAgWydwb2ludGVybW92ZScsICdwb2ludGVyZG93biddLmZvckVhY2goZnVuY3Rpb24gKGV2VHlwZSkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2VHlwZSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChldlR5cGUgPT09ICdwb2ludGVyZG93bicpIHtcbiAgICAgICAgICBzdGF0ZS5pc1BvaW50ZXJQcmVzc2VkID0gdHJ1ZTsgLy8gdHJhY2sgY2xpY2sgc3RhdGVcbiAgICAgICAgICBzdGF0ZS5wb2ludGVyRG93bkV2ZW50ID0gZXY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXRlY3QgcG9pbnRlciBkcmFnIG9uIGNhbnZhcyBwYW5cbiAgICAgICAgIXN0YXRlLmlzUG9pbnRlckRyYWdnaW5nICYmIGV2LnR5cGUgPT09ICdwb2ludGVybW92ZScgJiYgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2sgLy8gb25seSBib3RoZXIgZGV0ZWN0aW5nIGRyYWdzIHRoaXMgd2F5IGlmIGJhY2tncm91bmQgY2xpY2tzIGFyZSBlbmFibGVkIChzbyB0aGV5IGRvbid0IHRyaWdnZXIgYWNjaWRlbnRhbGx5IG9uIGNhbnZhcyBwYW5uaW5nKVxuICAgICAgICAmJiAoZXYucHJlc3N1cmUgPiAwIHx8IHN0YXRlLmlzUG9pbnRlclByZXNzZWQpIC8vIGV2LnByZXNzdXJlIGFsd2F5cyAwIG9uIFNhZmFyaSwgc28gd2UgdXNlIHRoZSBpc1BvaW50ZXJQcmVzc2VkIHRyYWNrZXJcbiAgICAgICAgJiYgKGV2LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnIHx8IGV2Lm1vdmVtZW50WCA9PT0gdW5kZWZpbmVkIHx8IFtldi5tb3ZlbWVudFgsIGV2Lm1vdmVtZW50WV0uc29tZShmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhtKSA+IDE7XG4gICAgICAgIH0pKSAvLyByZWxheCBkcmFnIHRyaWdnZXIgc2Vuc2l0aXZpdHkgb24gdG91Y2ggZXZlbnRzXG4gICAgICAgICYmIChzdGF0ZS5pc1BvaW50ZXJEcmFnZ2luZyA9IHRydWUpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlciBwb3NcbiAgICAgICAgdmFyIG9mZnNldCA9IGdldE9mZnNldChjb250YWluZXIpO1xuICAgICAgICBwb2ludGVyUG9zLnggPSBldi5wYWdlWCAtIG9mZnNldC5sZWZ0O1xuICAgICAgICBwb2ludGVyUG9zLnkgPSBldi5wYWdlWSAtIG9mZnNldC50b3A7XG5cbiAgICAgICAgLy8gTW92ZSB0b29sdGlwXG4gICAgICAgIHRvb2xUaXBFbGVtLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KHBvaW50ZXJQb3MueSwgXCJweFwiKTtcbiAgICAgICAgdG9vbFRpcEVsZW0uc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KHBvaW50ZXJQb3MueCwgXCJweFwiKTtcblxuICAgICAgICAvLyBhZGp1c3QgaG9yaXpvbnRhbCBwb3NpdGlvbiB0byBub3QgZXhjZWVkIGNhbnZhcyBib3VuZGFyaWVzXG4gICAgICAgIHRvb2xUaXBFbGVtLnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKC1cIi5jb25jYXQocG9pbnRlclBvcy54IC8gc3RhdGUud2lkdGggKiAxMDAsIFwiJSwgXCIpLmNvbmNhdChcbiAgICAgICAgLy8gZmxpcCB0byBhYm92ZSBpZiBuZWFyIGJvdHRvbVxuICAgICAgICBzdGF0ZS5oZWlnaHQgLSBwb2ludGVyUG9zLnkgPCAxMDAgPyAnY2FsYygtMTAwJSAtIDhweCknIDogJzIxcHgnLCBcIilcIik7XG5cbiAgICAgICAgLy9cblxuICAgICAgICBmdW5jdGlvbiBnZXRPZmZzZXQoZWwpIHtcbiAgICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgc2Nyb2xsVG9wLFxuICAgICAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgc2Nyb2xsTGVmdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgY2xpY2svdG91Y2ggZXZlbnRzIG9uIG5vZGVzL2xpbmtzXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgc3RhdGUuaXNQb2ludGVyUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgaWYgKHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nKSB7XG4gICAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjsgLy8gZG9uJ3QgdHJpZ2dlciBjbGljayBldmVudHMgYWZ0ZXIgcG9pbnRlciBkcmFnIChwYW4gLyBub2RlIGRyYWcgZnVuY3Rpb25hbGl0eSlcbiAgICAgIH1cblxuICAgICAgdmFyIGNiRXZlbnRzID0gW2V2LCBzdGF0ZS5wb2ludGVyRG93bkV2ZW50XTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2xpY2sgZXZlbnRzIGFzeW5jaHJvbm91c2x5LCB0byBhbGxvdyBob3Zlck9iaiB0byBiZSBzZXQgKG9uIGZyYW1lKVxuICAgICAgICBpZiAoZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgLy8gbW91c2UgbGVmdC1jbGljayBvciB0b3VjaFxuICAgICAgICAgIGlmIChzdGF0ZS5ob3Zlck9iaikge1xuICAgICAgICAgICAgdmFyIGZuID0gc3RhdGVbXCJvblwiLmNvbmNhdChzdGF0ZS5ob3Zlck9iai50eXBlLCBcIkNsaWNrXCIpXTtcbiAgICAgICAgICAgIGZuICYmIGZuLmFwcGx5KHZvaWQgMCwgW3N0YXRlLmhvdmVyT2JqLmRdLmNvbmNhdChjYkV2ZW50cykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5vbkJhY2tncm91bmRDbGljayAmJiBzdGF0ZS5vbkJhY2tncm91bmRDbGljay5hcHBseShzdGF0ZSwgY2JFdmVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXYuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgLy8gbW91c2UgcmlnaHQtY2xpY2tcbiAgICAgICAgICBpZiAoc3RhdGUuaG92ZXJPYmopIHtcbiAgICAgICAgICAgIHZhciBfZm4gPSBzdGF0ZVtcIm9uXCIuY29uY2F0KHN0YXRlLmhvdmVyT2JqLnR5cGUsIFwiUmlnaHRDbGlja1wiKV07XG4gICAgICAgICAgICBfZm4gJiYgX2ZuLmFwcGx5KHZvaWQgMCwgW3N0YXRlLmhvdmVyT2JqLmRdLmNvbmNhdChjYkV2ZW50cykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5vbkJhY2tncm91bmRSaWdodENsaWNrICYmIHN0YXRlLm9uQmFja2dyb3VuZFJpZ2h0Q2xpY2suYXBwbHkoc3RhdGUsIGNiRXZlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmICghc3RhdGUub25CYWNrZ3JvdW5kUmlnaHRDbGljayAmJiAhc3RhdGUub25Ob2RlUmlnaHRDbGljayAmJiAhc3RhdGUub25MaW5rUmlnaHRDbGljaykgcmV0dXJuIHRydWU7IC8vIGRlZmF1bHQgY29udGV4dG1lbnUgYmVoYXZpb3JcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgc3RhdGUuZm9yY2VHcmFwaChjdHgpO1xuICAgIHN0YXRlLnNoYWRvd0dyYXBoKHNoYWRvd0N0eCk7XG5cbiAgICAvL1xuXG4gICAgdmFyIHJlZnJlc2hTaGFkb3dDYW52YXMgPSB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyB3aXBlIGNhbnZhc1xuICAgICAgY2xlYXJDYW52YXMoc2hhZG93Q3R4LCBzdGF0ZS53aWR0aCwgc3RhdGUuaGVpZ2h0KTtcblxuICAgICAgLy8gQWRqdXN0IGxpbmsgaG92ZXIgYXJlYVxuICAgICAgc3RhdGUuc2hhZG93R3JhcGgubGlua1dpZHRoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NvckZuKHN0YXRlLmxpbmtXaWR0aCkobCkgKyBzdGF0ZS5saW5rSG92ZXJQcmVjaXNpb247XG4gICAgICB9KTtcblxuICAgICAgLy8gcmVkcmF3XG4gICAgICB2YXIgdCA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKTtcbiAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLmdsb2JhbFNjYWxlKHQuaykudGlja0ZyYW1lKCk7XG4gICAgfSwgSE9WRVJfQ0FOVkFTX1RIUk9UVExFX0RFTEFZKTtcbiAgICBzdGF0ZS5mbHVzaFNoYWRvd0NhbnZhcyA9IHJlZnJlc2hTaGFkb3dDYW52YXMuZmx1c2g7IC8vIGhvb2sgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHNoYWRvdyBjYW52YXMgcGFpbnRcblxuICAgIC8vIEtpY2stb2ZmIHJlbmRlcmVyXG4gICAgKHRoaXMuX2FuaW1hdGlvbkN5Y2xlID0gZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgIC8vIElJRkVcbiAgICAgIHZhciBkb1JlZHJhdyA9ICFzdGF0ZS5hdXRvUGF1c2VSZWRyYXcgfHwgISFzdGF0ZS5uZWVkc1JlZHJhdyB8fCBzdGF0ZS5mb3JjZUdyYXBoLmlzRW5naW5lUnVubmluZygpIHx8IHN0YXRlLmdyYXBoRGF0YS5saW5rcy5zb21lKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLl9fcGhvdG9ucyAmJiBkLl9fcGhvdG9ucy5sZW5ndGg7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgICBpZiAoc3RhdGUuZW5hYmxlUG9pbnRlckludGVyYWN0aW9uKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0b29sdGlwIGFuZCB0cmlnZ2VyIG9uSG92ZXIgZXZlbnRzXG4gICAgICAgIHZhciBvYmogPSAhc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPyBnZXRPYmpVbmRlclBvaW50ZXIoKSA6IG51bGw7IC8vIGRvbid0IGhvdmVyIGR1cmluZyBkcmFnXG4gICAgICAgIGlmIChvYmogIT09IHN0YXRlLmhvdmVyT2JqKSB7XG4gICAgICAgICAgdmFyIHByZXZPYmogPSBzdGF0ZS5ob3Zlck9iajtcbiAgICAgICAgICB2YXIgcHJldk9ialR5cGUgPSBwcmV2T2JqID8gcHJldk9iai50eXBlIDogbnVsbDtcbiAgICAgICAgICB2YXIgb2JqVHlwZSA9IG9iaiA/IG9iai50eXBlIDogbnVsbDtcbiAgICAgICAgICBpZiAocHJldk9ialR5cGUgJiYgcHJldk9ialR5cGUgIT09IG9ialR5cGUpIHtcbiAgICAgICAgICAgIC8vIEhvdmVyIG91dFxuICAgICAgICAgICAgdmFyIGZuID0gc3RhdGVbXCJvblwiLmNvbmNhdChwcmV2T2JqVHlwZSwgXCJIb3ZlclwiKV07XG4gICAgICAgICAgICBmbiAmJiBmbihudWxsLCBwcmV2T2JqLmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqVHlwZSkge1xuICAgICAgICAgICAgLy8gSG92ZXIgaW5cbiAgICAgICAgICAgIHZhciBfZm4yID0gc3RhdGVbXCJvblwiLmNvbmNhdChvYmpUeXBlLCBcIkhvdmVyXCIpXTtcbiAgICAgICAgICAgIF9mbjIgJiYgX2ZuMihvYmouZCwgcHJldk9ialR5cGUgPT09IG9ialR5cGUgPyBwcmV2T2JqLmQgOiBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRvb2x0aXBDb250ZW50ID0gb2JqID8gYWNjZXNzb3JGbihzdGF0ZVtcIlwiLmNvbmNhdChvYmoudHlwZS50b0xvd2VyQ2FzZSgpLCBcIkxhYmVsXCIpXSkob2JqLmQpIHx8ICcnIDogJyc7XG4gICAgICAgICAgdG9vbFRpcEVsZW0uc3R5bGUudmlzaWJpbGl0eSA9IHRvb2x0aXBDb250ZW50ID8gJ3Zpc2libGUnIDogJ2hpZGRlbic7XG4gICAgICAgICAgdG9vbFRpcEVsZW0uaW5uZXJIVE1MID0gdG9vbHRpcENvbnRlbnQ7XG5cbiAgICAgICAgICAvLyBzZXQgcG9pbnRlciBpZiBob3ZlcmVkIG9iamVjdCBpcyBjbGlja2FibGVcbiAgICAgICAgICBzdGF0ZS5jYW52YXMuY2xhc3NMaXN0W29iaiAmJiBzdGF0ZVtcIm9uXCIuY29uY2F0KG9ialR5cGUsIFwiQ2xpY2tcIildIHx8ICFvYmogJiYgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2sgPyAnYWRkJyA6ICdyZW1vdmUnXSgnY2xpY2thYmxlJyk7XG4gICAgICAgICAgc3RhdGUuaG92ZXJPYmogPSBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgZG9SZWRyYXcgJiYgcmVmcmVzaFNoYWRvd0NhbnZhcygpO1xuICAgICAgfVxuICAgICAgaWYgKGRvUmVkcmF3KSB7XG4gICAgICAgIC8vIFdpcGUgY2FudmFzXG4gICAgICAgIGNsZWFyQ2FudmFzKGN0eCwgc3RhdGUud2lkdGgsIHN0YXRlLmhlaWdodCk7XG5cbiAgICAgICAgLy8gRnJhbWUgY3ljbGVcbiAgICAgICAgdmFyIGdsb2JhbFNjYWxlID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpLms7XG4gICAgICAgIHN0YXRlLm9uUmVuZGVyRnJhbWVQcmUgJiYgc3RhdGUub25SZW5kZXJGcmFtZVByZShjdHgsIGdsb2JhbFNjYWxlKTtcbiAgICAgICAgc3RhdGUuZm9yY2VHcmFwaC5nbG9iYWxTY2FsZShnbG9iYWxTY2FsZSkudGlja0ZyYW1lKCk7XG4gICAgICAgIHN0YXRlLm9uUmVuZGVyRnJhbWVQb3N0ICYmIHN0YXRlLm9uUmVuZGVyRnJhbWVQb3N0KGN0eCwgZ2xvYmFsU2NhbGUpO1xuICAgICAgfVxuICAgICAgVFdFRU4udXBkYXRlKCk7IC8vIHVwZGF0ZSBjYW52YXMgYW5pbWF0aW9uIHR3ZWVuc1xuXG4gICAgICBzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICB9KSgpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZUZuKHN0YXRlKSB7fVxufSk7XG5cbmV4cG9ydCB7IGZvcmNlR3JhcGggYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/force-graph/dist/force-graph.mjs\n");

/***/ })

};
;